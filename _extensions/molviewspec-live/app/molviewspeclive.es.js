function IT(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var hO = { exports: {} }, Qt = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ky;
function FT() {
  if (Ky) return Qt;
  Ky = 1;
  var n = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), e = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), a = Symbol.for("react.consumer"), o = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), h = Symbol.for("react.suspense"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), g = Symbol.iterator;
  function y(T) {
    return T === null || typeof T != "object" ? null : (T = g && T[g] || T["@@iterator"], typeof T == "function" ? T : null);
  }
  var Q = {
    isMounted: function() {
      return !1;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, b = Object.assign, x = {};
  function P(T, L, tt) {
    this.props = T, this.context = L, this.refs = x, this.updater = tt || Q;
  }
  P.prototype.isReactComponent = {}, P.prototype.setState = function(T, L) {
    if (typeof T != "object" && typeof T != "function" && T != null)
      throw Error(
        "takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, T, L, "setState");
  }, P.prototype.forceUpdate = function(T) {
    this.updater.enqueueForceUpdate(this, T, "forceUpdate");
  };
  function A() {
  }
  A.prototype = P.prototype;
  function V(T, L, tt) {
    this.props = T, this.context = L, this.refs = x, this.updater = tt || Q;
  }
  var G = V.prototype = new A();
  G.constructor = V, b(G, P.prototype), G.isPureReactComponent = !0;
  var H = Array.isArray, _ = { H: null, A: null, T: null, S: null, V: null }, W = Object.prototype.hasOwnProperty;
  function q(T, L, tt, F, ct, vt) {
    return tt = vt.ref, {
      $$typeof: n,
      type: T,
      key: L,
      ref: tt !== void 0 ? tt : null,
      props: vt
    };
  }
  function J(T, L) {
    return q(
      T.type,
      L,
      void 0,
      void 0,
      void 0,
      T.props
    );
  }
  function N(T) {
    return typeof T == "object" && T !== null && T.$$typeof === n;
  }
  function I(T) {
    var L = { "=": "=0", ":": "=2" };
    return "$" + T.replace(/[=:]/g, function(tt) {
      return L[tt];
    });
  }
  var K = /\/+/g;
  function Y(T, L) {
    return typeof T == "object" && T !== null && T.key != null ? I("" + T.key) : L.toString(36);
  }
  function ot() {
  }
  function at(T) {
    switch (T.status) {
      case "fulfilled":
        return T.value;
      case "rejected":
        throw T.reason;
      default:
        switch (typeof T.status == "string" ? T.then(ot, ot) : (T.status = "pending", T.then(
          function(L) {
            T.status === "pending" && (T.status = "fulfilled", T.value = L);
          },
          function(L) {
            T.status === "pending" && (T.status = "rejected", T.reason = L);
          }
        )), T.status) {
          case "fulfilled":
            return T.value;
          case "rejected":
            throw T.reason;
        }
    }
    throw T;
  }
  function ht(T, L, tt, F, ct) {
    var vt = typeof T;
    (vt === "undefined" || vt === "boolean") && (T = null);
    var mt = !1;
    if (T === null) mt = !0;
    else
      switch (vt) {
        case "bigint":
        case "string":
        case "number":
          mt = !0;
          break;
        case "object":
          switch (T.$$typeof) {
            case n:
            case t:
              mt = !0;
              break;
            case p:
              return mt = T._init, ht(
                mt(T._payload),
                L,
                tt,
                F,
                ct
              );
          }
      }
    if (mt)
      return ct = ct(T), mt = F === "" ? "." + Y(T, 0) : F, H(ct) ? (tt = "", mt != null && (tt = mt.replace(K, "$&/") + "/"), ht(ct, L, tt, "", function(An) {
        return An;
      })) : ct != null && (N(ct) && (ct = J(
        ct,
        tt + (ct.key == null || T && T.key === ct.key ? "" : ("" + ct.key).replace(
          K,
          "$&/"
        ) + "/") + mt
      )), L.push(ct)), 1;
    mt = 0;
    var $e = F === "" ? "." : F + ":";
    if (H(T))
      for (var Gt = 0; Gt < T.length; Gt++)
        F = T[Gt], vt = $e + Y(F, Gt), mt += ht(
          F,
          L,
          tt,
          vt,
          ct
        );
    else if (Gt = y(T), typeof Gt == "function")
      for (T = Gt.call(T), Gt = 0; !(F = T.next()).done; )
        F = F.value, vt = $e + Y(F, Gt++), mt += ht(
          F,
          L,
          tt,
          vt,
          ct
        );
    else if (vt === "object") {
      if (typeof T.then == "function")
        return ht(
          at(T),
          L,
          tt,
          F,
          ct
        );
      throw L = String(T), Error(
        "Objects are not valid as a React child (found: " + (L === "[object Object]" ? "object with keys {" + Object.keys(T).join(", ") + "}" : L) + "). If you meant to render a collection of children, use an array instead."
      );
    }
    return mt;
  }
  function E(T, L, tt) {
    if (T == null) return T;
    var F = [], ct = 0;
    return ht(T, F, "", "", function(vt) {
      return L.call(tt, vt, ct++);
    }), F;
  }
  function z(T) {
    if (T._status === -1) {
      var L = T._result;
      L = L(), L.then(
        function(tt) {
          (T._status === 0 || T._status === -1) && (T._status = 1, T._result = tt);
        },
        function(tt) {
          (T._status === 0 || T._status === -1) && (T._status = 2, T._result = tt);
        }
      ), T._status === -1 && (T._status = 0, T._result = L);
    }
    if (T._status === 1) return T._result.default;
    throw T._result;
  }
  var nt = typeof reportError == "function" ? reportError : function(T) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var L = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof T == "object" && T !== null && typeof T.message == "string" ? String(T.message) : String(T),
        error: T
      });
      if (!window.dispatchEvent(L)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", T);
      return;
    }
    console.error(T);
  };
  function Ot() {
  }
  return Qt.Children = {
    map: E,
    forEach: function(T, L, tt) {
      E(
        T,
        function() {
          L.apply(this, arguments);
        },
        tt
      );
    },
    count: function(T) {
      var L = 0;
      return E(T, function() {
        L++;
      }), L;
    },
    toArray: function(T) {
      return E(T, function(L) {
        return L;
      }) || [];
    },
    only: function(T) {
      if (!N(T))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return T;
    }
  }, Qt.Component = P, Qt.Fragment = e, Qt.Profiler = s, Qt.PureComponent = V, Qt.StrictMode = i, Qt.Suspense = h, Qt.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = _, Qt.__COMPILER_RUNTIME = {
    __proto__: null,
    c: function(T) {
      return _.H.useMemoCache(T);
    }
  }, Qt.cache = function(T) {
    return function() {
      return T.apply(null, arguments);
    };
  }, Qt.cloneElement = function(T, L, tt) {
    if (T == null)
      throw Error(
        "The argument must be a React element, but you passed " + T + "."
      );
    var F = b({}, T.props), ct = T.key, vt = void 0;
    if (L != null)
      for (mt in L.ref !== void 0 && (vt = void 0), L.key !== void 0 && (ct = "" + L.key), L)
        !W.call(L, mt) || mt === "key" || mt === "__self" || mt === "__source" || mt === "ref" && L.ref === void 0 || (F[mt] = L[mt]);
    var mt = arguments.length - 2;
    if (mt === 1) F.children = tt;
    else if (1 < mt) {
      for (var $e = Array(mt), Gt = 0; Gt < mt; Gt++)
        $e[Gt] = arguments[Gt + 2];
      F.children = $e;
    }
    return q(T.type, ct, void 0, void 0, vt, F);
  }, Qt.createContext = function(T) {
    return T = {
      $$typeof: o,
      _currentValue: T,
      _currentValue2: T,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    }, T.Provider = T, T.Consumer = {
      $$typeof: a,
      _context: T
    }, T;
  }, Qt.createElement = function(T, L, tt) {
    var F, ct = {}, vt = null;
    if (L != null)
      for (F in L.key !== void 0 && (vt = "" + L.key), L)
        W.call(L, F) && F !== "key" && F !== "__self" && F !== "__source" && (ct[F] = L[F]);
    var mt = arguments.length - 2;
    if (mt === 1) ct.children = tt;
    else if (1 < mt) {
      for (var $e = Array(mt), Gt = 0; Gt < mt; Gt++)
        $e[Gt] = arguments[Gt + 2];
      ct.children = $e;
    }
    if (T && T.defaultProps)
      for (F in mt = T.defaultProps, mt)
        ct[F] === void 0 && (ct[F] = mt[F]);
    return q(T, vt, void 0, void 0, null, ct);
  }, Qt.createRef = function() {
    return { current: null };
  }, Qt.forwardRef = function(T) {
    return { $$typeof: u, render: T };
  }, Qt.isValidElement = N, Qt.lazy = function(T) {
    return {
      $$typeof: p,
      _payload: { _status: -1, _result: T },
      _init: z
    };
  }, Qt.memo = function(T, L) {
    return {
      $$typeof: d,
      type: T,
      compare: L === void 0 ? null : L
    };
  }, Qt.startTransition = function(T) {
    var L = _.T, tt = {};
    _.T = tt;
    try {
      var F = T(), ct = _.S;
      ct !== null && ct(tt, F), typeof F == "object" && F !== null && typeof F.then == "function" && F.then(Ot, nt);
    } catch (vt) {
      nt(vt);
    } finally {
      _.T = L;
    }
  }, Qt.unstable_useCacheRefresh = function() {
    return _.H.useCacheRefresh();
  }, Qt.use = function(T) {
    return _.H.use(T);
  }, Qt.useActionState = function(T, L, tt) {
    return _.H.useActionState(T, L, tt);
  }, Qt.useCallback = function(T, L) {
    return _.H.useCallback(T, L);
  }, Qt.useContext = function(T) {
    return _.H.useContext(T);
  }, Qt.useDebugValue = function() {
  }, Qt.useDeferredValue = function(T, L) {
    return _.H.useDeferredValue(T, L);
  }, Qt.useEffect = function(T, L, tt) {
    var F = _.H;
    if (typeof tt == "function")
      throw Error(
        "useEffect CRUD overload is not enabled in this build of React."
      );
    return F.useEffect(T, L);
  }, Qt.useId = function() {
    return _.H.useId();
  }, Qt.useImperativeHandle = function(T, L, tt) {
    return _.H.useImperativeHandle(T, L, tt);
  }, Qt.useInsertionEffect = function(T, L) {
    return _.H.useInsertionEffect(T, L);
  }, Qt.useLayoutEffect = function(T, L) {
    return _.H.useLayoutEffect(T, L);
  }, Qt.useMemo = function(T, L) {
    return _.H.useMemo(T, L);
  }, Qt.useOptimistic = function(T, L) {
    return _.H.useOptimistic(T, L);
  }, Qt.useReducer = function(T, L, tt) {
    return _.H.useReducer(T, L, tt);
  }, Qt.useRef = function(T) {
    return _.H.useRef(T);
  }, Qt.useState = function(T) {
    return _.H.useState(T);
  }, Qt.useSyncExternalStore = function(T, L, tt) {
    return _.H.useSyncExternalStore(
      T,
      L,
      tt
    );
  }, Qt.useTransition = function() {
    return _.H.useTransition();
  }, Qt.version = "19.1.0", Qt;
}
var Jy;
function op() {
  return Jy || (Jy = 1, hO.exports = FT()), hO.exports;
}
var St = op();
const ie = /* @__PURE__ */ IT(St);
var OO = { exports: {} }, aa = {}, dO = { exports: {} }, pO = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Iy;
function t$() {
  return Iy || (Iy = 1, function(n) {
    function t(E, z) {
      var nt = E.length;
      E.push(z);
      t: for (; 0 < nt; ) {
        var Ot = nt - 1 >>> 1, T = E[Ot];
        if (0 < s(T, z))
          E[Ot] = z, E[nt] = T, nt = Ot;
        else break t;
      }
    }
    function e(E) {
      return E.length === 0 ? null : E[0];
    }
    function i(E) {
      if (E.length === 0) return null;
      var z = E[0], nt = E.pop();
      if (nt !== z) {
        E[0] = nt;
        t: for (var Ot = 0, T = E.length, L = T >>> 1; Ot < L; ) {
          var tt = 2 * (Ot + 1) - 1, F = E[tt], ct = tt + 1, vt = E[ct];
          if (0 > s(F, nt))
            ct < T && 0 > s(vt, F) ? (E[Ot] = vt, E[ct] = nt, Ot = ct) : (E[Ot] = F, E[tt] = nt, Ot = tt);
          else if (ct < T && 0 > s(vt, nt))
            E[Ot] = vt, E[ct] = nt, Ot = ct;
          else break t;
        }
      }
      return z;
    }
    function s(E, z) {
      var nt = E.sortIndex - z.sortIndex;
      return nt !== 0 ? nt : E.id - z.id;
    }
    if (n.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var a = performance;
      n.unstable_now = function() {
        return a.now();
      };
    } else {
      var o = Date, u = o.now();
      n.unstable_now = function() {
        return o.now() - u;
      };
    }
    var h = [], d = [], p = 1, g = null, y = 3, Q = !1, b = !1, x = !1, P = !1, A = typeof setTimeout == "function" ? setTimeout : null, V = typeof clearTimeout == "function" ? clearTimeout : null, G = typeof setImmediate < "u" ? setImmediate : null;
    function H(E) {
      for (var z = e(d); z !== null; ) {
        if (z.callback === null) i(d);
        else if (z.startTime <= E)
          i(d), z.sortIndex = z.expirationTime, t(h, z);
        else break;
        z = e(d);
      }
    }
    function _(E) {
      if (x = !1, H(E), !b)
        if (e(h) !== null)
          b = !0, W || (W = !0, Y());
        else {
          var z = e(d);
          z !== null && ht(_, z.startTime - E);
        }
    }
    var W = !1, q = -1, J = 5, N = -1;
    function I() {
      return P ? !0 : !(n.unstable_now() - N < J);
    }
    function K() {
      if (P = !1, W) {
        var E = n.unstable_now();
        N = E;
        var z = !0;
        try {
          t: {
            b = !1, x && (x = !1, V(q), q = -1), Q = !0;
            var nt = y;
            try {
              e: {
                for (H(E), g = e(h); g !== null && !(g.expirationTime > E && I()); ) {
                  var Ot = g.callback;
                  if (typeof Ot == "function") {
                    g.callback = null, y = g.priorityLevel;
                    var T = Ot(
                      g.expirationTime <= E
                    );
                    if (E = n.unstable_now(), typeof T == "function") {
                      g.callback = T, H(E), z = !0;
                      break e;
                    }
                    g === e(h) && i(h), H(E);
                  } else i(h);
                  g = e(h);
                }
                if (g !== null) z = !0;
                else {
                  var L = e(d);
                  L !== null && ht(
                    _,
                    L.startTime - E
                  ), z = !1;
                }
              }
              break t;
            } finally {
              g = null, y = nt, Q = !1;
            }
            z = void 0;
          }
        } finally {
          z ? Y() : W = !1;
        }
      }
    }
    var Y;
    if (typeof G == "function")
      Y = function() {
        G(K);
      };
    else if (typeof MessageChannel < "u") {
      var ot = new MessageChannel(), at = ot.port2;
      ot.port1.onmessage = K, Y = function() {
        at.postMessage(null);
      };
    } else
      Y = function() {
        A(K, 0);
      };
    function ht(E, z) {
      q = A(function() {
        E(n.unstable_now());
      }, z);
    }
    n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function(E) {
      E.callback = null;
    }, n.unstable_forceFrameRate = function(E) {
      0 > E || 125 < E ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : J = 0 < E ? Math.floor(1e3 / E) : 5;
    }, n.unstable_getCurrentPriorityLevel = function() {
      return y;
    }, n.unstable_next = function(E) {
      switch (y) {
        case 1:
        case 2:
        case 3:
          var z = 3;
          break;
        default:
          z = y;
      }
      var nt = y;
      y = z;
      try {
        return E();
      } finally {
        y = nt;
      }
    }, n.unstable_requestPaint = function() {
      P = !0;
    }, n.unstable_runWithPriority = function(E, z) {
      switch (E) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          E = 3;
      }
      var nt = y;
      y = E;
      try {
        return z();
      } finally {
        y = nt;
      }
    }, n.unstable_scheduleCallback = function(E, z, nt) {
      var Ot = n.unstable_now();
      switch (typeof nt == "object" && nt !== null ? (nt = nt.delay, nt = typeof nt == "number" && 0 < nt ? Ot + nt : Ot) : nt = Ot, E) {
        case 1:
          var T = -1;
          break;
        case 2:
          T = 250;
          break;
        case 5:
          T = 1073741823;
          break;
        case 4:
          T = 1e4;
          break;
        default:
          T = 5e3;
      }
      return T = nt + T, E = {
        id: p++,
        callback: z,
        priorityLevel: E,
        startTime: nt,
        expirationTime: T,
        sortIndex: -1
      }, nt > Ot ? (E.sortIndex = nt, t(d, E), e(h) === null && E === e(d) && (x ? (V(q), q = -1) : x = !0, ht(_, nt - Ot))) : (E.sortIndex = T, t(h, E), b || Q || (b = !0, W || (W = !0, Y()))), E;
    }, n.unstable_shouldYield = I, n.unstable_wrapCallback = function(E) {
      var z = y;
      return function() {
        var nt = y;
        y = z;
        try {
          return E.apply(this, arguments);
        } finally {
          y = nt;
        }
      };
    };
  }(pO)), pO;
}
var Fy;
function e$() {
  return Fy || (Fy = 1, dO.exports = t$()), dO.exports;
}
var mO = { exports: {} }, Ae = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tS;
function i$() {
  if (tS) return Ae;
  tS = 1;
  var n = op();
  function t(h) {
    var d = "https://react.dev/errors/" + h;
    if (1 < arguments.length) {
      d += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var p = 2; p < arguments.length; p++)
        d += "&args[]=" + encodeURIComponent(arguments[p]);
    }
    return "Minified React error #" + h + "; visit " + d + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function e() {
  }
  var i = {
    d: {
      f: e,
      r: function() {
        throw Error(t(522));
      },
      D: e,
      C: e,
      L: e,
      m: e,
      X: e,
      S: e,
      M: e
    },
    p: 0,
    findDOMNode: null
  }, s = Symbol.for("react.portal");
  function a(h, d, p) {
    var g = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: s,
      key: g == null ? null : "" + g,
      children: h,
      containerInfo: d,
      implementation: p
    };
  }
  var o = n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function u(h, d) {
    if (h === "font") return "";
    if (typeof d == "string")
      return d === "use-credentials" ? d : "";
  }
  return Ae.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = i, Ae.createPortal = function(h, d) {
    var p = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!d || d.nodeType !== 1 && d.nodeType !== 9 && d.nodeType !== 11)
      throw Error(t(299));
    return a(h, d, null, p);
  }, Ae.flushSync = function(h) {
    var d = o.T, p = i.p;
    try {
      if (o.T = null, i.p = 2, h) return h();
    } finally {
      o.T = d, i.p = p, i.d.f();
    }
  }, Ae.preconnect = function(h, d) {
    typeof h == "string" && (d ? (d = d.crossOrigin, d = typeof d == "string" ? d === "use-credentials" ? d : "" : void 0) : d = null, i.d.C(h, d));
  }, Ae.prefetchDNS = function(h) {
    typeof h == "string" && i.d.D(h);
  }, Ae.preinit = function(h, d) {
    if (typeof h == "string" && d && typeof d.as == "string") {
      var p = d.as, g = u(p, d.crossOrigin), y = typeof d.integrity == "string" ? d.integrity : void 0, Q = typeof d.fetchPriority == "string" ? d.fetchPriority : void 0;
      p === "style" ? i.d.S(
        h,
        typeof d.precedence == "string" ? d.precedence : void 0,
        {
          crossOrigin: g,
          integrity: y,
          fetchPriority: Q
        }
      ) : p === "script" && i.d.X(h, {
        crossOrigin: g,
        integrity: y,
        fetchPriority: Q,
        nonce: typeof d.nonce == "string" ? d.nonce : void 0
      });
    }
  }, Ae.preinitModule = function(h, d) {
    if (typeof h == "string")
      if (typeof d == "object" && d !== null) {
        if (d.as == null || d.as === "script") {
          var p = u(
            d.as,
            d.crossOrigin
          );
          i.d.M(h, {
            crossOrigin: p,
            integrity: typeof d.integrity == "string" ? d.integrity : void 0,
            nonce: typeof d.nonce == "string" ? d.nonce : void 0
          });
        }
      } else d == null && i.d.M(h);
  }, Ae.preload = function(h, d) {
    if (typeof h == "string" && typeof d == "object" && d !== null && typeof d.as == "string") {
      var p = d.as, g = u(p, d.crossOrigin);
      i.d.L(h, p, {
        crossOrigin: g,
        integrity: typeof d.integrity == "string" ? d.integrity : void 0,
        nonce: typeof d.nonce == "string" ? d.nonce : void 0,
        type: typeof d.type == "string" ? d.type : void 0,
        fetchPriority: typeof d.fetchPriority == "string" ? d.fetchPriority : void 0,
        referrerPolicy: typeof d.referrerPolicy == "string" ? d.referrerPolicy : void 0,
        imageSrcSet: typeof d.imageSrcSet == "string" ? d.imageSrcSet : void 0,
        imageSizes: typeof d.imageSizes == "string" ? d.imageSizes : void 0,
        media: typeof d.media == "string" ? d.media : void 0
      });
    }
  }, Ae.preloadModule = function(h, d) {
    if (typeof h == "string")
      if (d) {
        var p = u(d.as, d.crossOrigin);
        i.d.m(h, {
          as: typeof d.as == "string" && d.as !== "script" ? d.as : void 0,
          crossOrigin: p,
          integrity: typeof d.integrity == "string" ? d.integrity : void 0
        });
      } else i.d.m(h);
  }, Ae.requestFormReset = function(h) {
    i.d.r(h);
  }, Ae.unstable_batchedUpdates = function(h, d) {
    return h(d);
  }, Ae.useFormState = function(h, d, p) {
    return o.H.useFormState(h, d, p);
  }, Ae.useFormStatus = function() {
    return o.H.useHostTransitionStatus();
  }, Ae.version = "19.1.0", Ae;
}
var eS;
function n$() {
  if (eS) return mO.exports;
  eS = 1;
  function n() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n);
      } catch (t) {
        console.error(t);
      }
  }
  return n(), mO.exports = i$(), mO.exports;
}
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var iS;
function l$() {
  if (iS) return aa;
  iS = 1;
  var n = e$(), t = op(), e = n$();
  function i(l) {
    var r = "https://react.dev/errors/" + l;
    if (1 < arguments.length) {
      r += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var c = 2; c < arguments.length; c++)
        r += "&args[]=" + encodeURIComponent(arguments[c]);
    }
    return "Minified React error #" + l + "; visit " + r + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function s(l) {
    return !(!l || l.nodeType !== 1 && l.nodeType !== 9 && l.nodeType !== 11);
  }
  function a(l) {
    var r = l, c = l;
    if (l.alternate) for (; r.return; ) r = r.return;
    else {
      l = r;
      do
        r = l, (r.flags & 4098) !== 0 && (c = r.return), l = r.return;
      while (l);
    }
    return r.tag === 3 ? c : null;
  }
  function o(l) {
    if (l.tag === 13) {
      var r = l.memoizedState;
      if (r === null && (l = l.alternate, l !== null && (r = l.memoizedState)), r !== null) return r.dehydrated;
    }
    return null;
  }
  function u(l) {
    if (a(l) !== l)
      throw Error(i(188));
  }
  function h(l) {
    var r = l.alternate;
    if (!r) {
      if (r = a(l), r === null) throw Error(i(188));
      return r !== l ? null : l;
    }
    for (var c = l, f = r; ; ) {
      var O = c.return;
      if (O === null) break;
      var m = O.alternate;
      if (m === null) {
        if (f = O.return, f !== null) {
          c = f;
          continue;
        }
        break;
      }
      if (O.child === m.child) {
        for (m = O.child; m; ) {
          if (m === c) return u(O), l;
          if (m === f) return u(O), r;
          m = m.sibling;
        }
        throw Error(i(188));
      }
      if (c.return !== f.return) c = O, f = m;
      else {
        for (var S = !1, v = O.child; v; ) {
          if (v === c) {
            S = !0, c = O, f = m;
            break;
          }
          if (v === f) {
            S = !0, f = O, c = m;
            break;
          }
          v = v.sibling;
        }
        if (!S) {
          for (v = m.child; v; ) {
            if (v === c) {
              S = !0, c = m, f = O;
              break;
            }
            if (v === f) {
              S = !0, f = m, c = O;
              break;
            }
            v = v.sibling;
          }
          if (!S) throw Error(i(189));
        }
      }
      if (c.alternate !== f) throw Error(i(190));
    }
    if (c.tag !== 3) throw Error(i(188));
    return c.stateNode.current === c ? l : r;
  }
  function d(l) {
    var r = l.tag;
    if (r === 5 || r === 26 || r === 27 || r === 6) return l;
    for (l = l.child; l !== null; ) {
      if (r = d(l), r !== null) return r;
      l = l.sibling;
    }
    return null;
  }
  var p = Object.assign, g = Symbol.for("react.element"), y = Symbol.for("react.transitional.element"), Q = Symbol.for("react.portal"), b = Symbol.for("react.fragment"), x = Symbol.for("react.strict_mode"), P = Symbol.for("react.profiler"), A = Symbol.for("react.provider"), V = Symbol.for("react.consumer"), G = Symbol.for("react.context"), H = Symbol.for("react.forward_ref"), _ = Symbol.for("react.suspense"), W = Symbol.for("react.suspense_list"), q = Symbol.for("react.memo"), J = Symbol.for("react.lazy"), N = Symbol.for("react.activity"), I = Symbol.for("react.memo_cache_sentinel"), K = Symbol.iterator;
  function Y(l) {
    return l === null || typeof l != "object" ? null : (l = K && l[K] || l["@@iterator"], typeof l == "function" ? l : null);
  }
  var ot = Symbol.for("react.client.reference");
  function at(l) {
    if (l == null) return null;
    if (typeof l == "function")
      return l.$$typeof === ot ? null : l.displayName || l.name || null;
    if (typeof l == "string") return l;
    switch (l) {
      case b:
        return "Fragment";
      case P:
        return "Profiler";
      case x:
        return "StrictMode";
      case _:
        return "Suspense";
      case W:
        return "SuspenseList";
      case N:
        return "Activity";
    }
    if (typeof l == "object")
      switch (l.$$typeof) {
        case Q:
          return "Portal";
        case G:
          return (l.displayName || "Context") + ".Provider";
        case V:
          return (l._context.displayName || "Context") + ".Consumer";
        case H:
          var r = l.render;
          return l = l.displayName, l || (l = r.displayName || r.name || "", l = l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef"), l;
        case q:
          return r = l.displayName || null, r !== null ? r : at(l.type) || "Memo";
        case J:
          r = l._payload, l = l._init;
          try {
            return at(l(r));
          } catch {
          }
      }
    return null;
  }
  var ht = Array.isArray, E = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, z = e.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, nt = {
    pending: !1,
    data: null,
    method: null,
    action: null
  }, Ot = [], T = -1;
  function L(l) {
    return { current: l };
  }
  function tt(l) {
    0 > T || (l.current = Ot[T], Ot[T] = null, T--);
  }
  function F(l, r) {
    T++, Ot[T] = l.current, l.current = r;
  }
  var ct = L(null), vt = L(null), mt = L(null), $e = L(null);
  function Gt(l, r) {
    switch (F(mt, r), F(vt, l), F(ct, null), r.nodeType) {
      case 9:
      case 11:
        l = (l = r.documentElement) && (l = l.namespaceURI) ? ky(l) : 0;
        break;
      default:
        if (l = r.tagName, r = r.namespaceURI)
          r = ky(r), l = wy(r, l);
        else
          switch (l) {
            case "svg":
              l = 1;
              break;
            case "math":
              l = 2;
              break;
            default:
              l = 0;
          }
    }
    tt(ct), F(ct, l);
  }
  function An() {
    tt(ct), tt(vt), tt(mt);
  }
  function Ku(l) {
    l.memoizedState !== null && F($e, l);
    var r = ct.current, c = wy(r, l.type);
    r !== c && (F(vt, l), F(ct, c));
  }
  function so(l) {
    vt.current === l && (tt(ct), tt(vt)), $e.current === l && (tt($e), ia._currentValue = nt);
  }
  var Ju = Object.prototype.hasOwnProperty, Iu = n.unstable_scheduleCallback, Fu = n.unstable_cancelCallback, Ak = n.unstable_shouldYield, Mk = n.unstable_requestPaint, Mi = n.unstable_now, qk = n.unstable_getCurrentPriorityLevel, lm = n.unstable_ImmediatePriority, sm = n.unstable_UserBlockingPriority, ro = n.unstable_NormalPriority, Ck = n.unstable_LowPriority, rm = n.unstable_IdlePriority, Zk = n.log, Ek = n.unstable_setDisableYieldValue, ur = null, He = null;
  function Mn(l) {
    if (typeof Zk == "function" && Ek(l), He && typeof He.setStrictMode == "function")
      try {
        He.setStrictMode(ur, l);
      } catch {
      }
  }
  var Ke = Math.clz32 ? Math.clz32 : zk, Xk = Math.log, _k = Math.LN2;
  function zk(l) {
    return l >>>= 0, l === 0 ? 32 : 31 - (Xk(l) / _k | 0) | 0;
  }
  var ao = 256, oo = 4194304;
  function ml(l) {
    var r = l & 42;
    if (r !== 0) return r;
    switch (l & -l) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return l & 4194048;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return l & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return l;
    }
  }
  function co(l, r, c) {
    var f = l.pendingLanes;
    if (f === 0) return 0;
    var O = 0, m = l.suspendedLanes, S = l.pingedLanes;
    l = l.warmLanes;
    var v = f & 134217727;
    return v !== 0 ? (f = v & ~m, f !== 0 ? O = ml(f) : (S &= v, S !== 0 ? O = ml(S) : c || (c = v & ~l, c !== 0 && (O = ml(c))))) : (v = f & ~m, v !== 0 ? O = ml(v) : S !== 0 ? O = ml(S) : c || (c = f & ~l, c !== 0 && (O = ml(c)))), O === 0 ? 0 : r !== 0 && r !== O && (r & m) === 0 && (m = O & -O, c = r & -r, m >= c || m === 32 && (c & 4194048) !== 0) ? r : O;
  }
  function fr(l, r) {
    return (l.pendingLanes & ~(l.suspendedLanes & ~l.pingedLanes) & r) === 0;
  }
  function Dk(l, r) {
    switch (l) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return r + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return r + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function am() {
    var l = ao;
    return ao <<= 1, (ao & 4194048) === 0 && (ao = 256), l;
  }
  function om() {
    var l = oo;
    return oo <<= 1, (oo & 62914560) === 0 && (oo = 4194304), l;
  }
  function tf(l) {
    for (var r = [], c = 0; 31 > c; c++) r.push(l);
    return r;
  }
  function hr(l, r) {
    l.pendingLanes |= r, r !== 268435456 && (l.suspendedLanes = 0, l.pingedLanes = 0, l.warmLanes = 0);
  }
  function Vk(l, r, c, f, O, m) {
    var S = l.pendingLanes;
    l.pendingLanes = c, l.suspendedLanes = 0, l.pingedLanes = 0, l.warmLanes = 0, l.expiredLanes &= c, l.entangledLanes &= c, l.errorRecoveryDisabledLanes &= c, l.shellSuspendCounter = 0;
    var v = l.entanglements, k = l.expirationTimes, C = l.hiddenUpdates;
    for (c = S & ~c; 0 < c; ) {
      var D = 31 - Ke(c), B = 1 << D;
      v[D] = 0, k[D] = -1;
      var Z = C[D];
      if (Z !== null)
        for (C[D] = null, D = 0; D < Z.length; D++) {
          var X = Z[D];
          X !== null && (X.lane &= -536870913);
        }
      c &= ~B;
    }
    f !== 0 && cm(l, f, 0), m !== 0 && O === 0 && l.tag !== 0 && (l.suspendedLanes |= m & ~(S & ~r));
  }
  function cm(l, r, c) {
    l.pendingLanes |= r, l.suspendedLanes &= ~r;
    var f = 31 - Ke(r);
    l.entangledLanes |= r, l.entanglements[f] = l.entanglements[f] | 1073741824 | c & 4194090;
  }
  function um(l, r) {
    var c = l.entangledLanes |= r;
    for (l = l.entanglements; c; ) {
      var f = 31 - Ke(c), O = 1 << f;
      O & r | l[f] & r && (l[f] |= r), c &= ~O;
    }
  }
  function ef(l) {
    switch (l) {
      case 2:
        l = 1;
        break;
      case 8:
        l = 4;
        break;
      case 32:
        l = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        l = 128;
        break;
      case 268435456:
        l = 134217728;
        break;
      default:
        l = 0;
    }
    return l;
  }
  function nf(l) {
    return l &= -l, 2 < l ? 8 < l ? (l & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
  }
  function fm() {
    var l = z.p;
    return l !== 0 ? l : (l = window.event, l === void 0 ? 32 : Ly(l.type));
  }
  function Yk(l, r) {
    var c = z.p;
    try {
      return z.p = l, r();
    } finally {
      z.p = c;
    }
  }
  var qn = Math.random().toString(36).slice(2), Pe = "__reactFiber$" + qn, _e = "__reactProps$" + qn, Il = "__reactContainer$" + qn, lf = "__reactEvents$" + qn, Uk = "__reactListeners$" + qn, jk = "__reactHandles$" + qn, hm = "__reactResources$" + qn, Or = "__reactMarker$" + qn;
  function sf(l) {
    delete l[Pe], delete l[_e], delete l[lf], delete l[Uk], delete l[jk];
  }
  function Fl(l) {
    var r = l[Pe];
    if (r) return r;
    for (var c = l.parentNode; c; ) {
      if (r = c[Il] || c[Pe]) {
        if (c = r.alternate, r.child !== null || c !== null && c.child !== null)
          for (l = Ry(l); l !== null; ) {
            if (c = l[Pe]) return c;
            l = Ry(l);
          }
        return r;
      }
      l = c, c = l.parentNode;
    }
    return null;
  }
  function ts(l) {
    if (l = l[Pe] || l[Il]) {
      var r = l.tag;
      if (r === 5 || r === 6 || r === 13 || r === 26 || r === 27 || r === 3)
        return l;
    }
    return null;
  }
  function dr(l) {
    var r = l.tag;
    if (r === 5 || r === 26 || r === 27 || r === 6) return l.stateNode;
    throw Error(i(33));
  }
  function es(l) {
    var r = l[hm];
    return r || (r = l[hm] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), r;
  }
  function de(l) {
    l[Or] = !0;
  }
  var Om = /* @__PURE__ */ new Set(), dm = {};
  function gl(l, r) {
    is(l, r), is(l + "Capture", r);
  }
  function is(l, r) {
    for (dm[l] = r, l = 0; l < r.length; l++)
      Om.add(r[l]);
  }
  var Lk = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), pm = {}, mm = {};
  function Bk(l) {
    return Ju.call(mm, l) ? !0 : Ju.call(pm, l) ? !1 : Lk.test(l) ? mm[l] = !0 : (pm[l] = !0, !1);
  }
  function uo(l, r, c) {
    if (Bk(r))
      if (c === null) l.removeAttribute(r);
      else {
        switch (typeof c) {
          case "undefined":
          case "function":
          case "symbol":
            l.removeAttribute(r);
            return;
          case "boolean":
            var f = r.toLowerCase().slice(0, 5);
            if (f !== "data-" && f !== "aria-") {
              l.removeAttribute(r);
              return;
            }
        }
        l.setAttribute(r, "" + c);
      }
  }
  function fo(l, r, c) {
    if (c === null) l.removeAttribute(r);
    else {
      switch (typeof c) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          l.removeAttribute(r);
          return;
      }
      l.setAttribute(r, "" + c);
    }
  }
  function nn(l, r, c, f) {
    if (f === null) l.removeAttribute(c);
    else {
      switch (typeof f) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          l.removeAttribute(c);
          return;
      }
      l.setAttributeNS(r, c, "" + f);
    }
  }
  var rf, gm;
  function ns(l) {
    if (rf === void 0)
      try {
        throw Error();
      } catch (c) {
        var r = c.stack.trim().match(/\n( *(at )?)/);
        rf = r && r[1] || "", gm = -1 < c.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < c.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return `
` + rf + l + gm;
  }
  var af = !1;
  function of(l, r) {
    if (!l || af) return "";
    af = !0;
    var c = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var f = {
        DetermineComponentFrameRoot: function() {
          try {
            if (r) {
              var B = function() {
                throw Error();
              };
              if (Object.defineProperty(B.prototype, "props", {
                set: function() {
                  throw Error();
                }
              }), typeof Reflect == "object" && Reflect.construct) {
                try {
                  Reflect.construct(B, []);
                } catch (X) {
                  var Z = X;
                }
                Reflect.construct(l, [], B);
              } else {
                try {
                  B.call();
                } catch (X) {
                  Z = X;
                }
                l.call(B.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (X) {
                Z = X;
              }
              (B = l()) && typeof B.catch == "function" && B.catch(function() {
              });
            }
          } catch (X) {
            if (X && Z && typeof X.stack == "string")
              return [X.stack, Z.stack];
          }
          return [null, null];
        }
      };
      f.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var O = Object.getOwnPropertyDescriptor(
        f.DetermineComponentFrameRoot,
        "name"
      );
      O && O.configurable && Object.defineProperty(
        f.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var m = f.DetermineComponentFrameRoot(), S = m[0], v = m[1];
      if (S && v) {
        var k = S.split(`
`), C = v.split(`
`);
        for (O = f = 0; f < k.length && !k[f].includes("DetermineComponentFrameRoot"); )
          f++;
        for (; O < C.length && !C[O].includes(
          "DetermineComponentFrameRoot"
        ); )
          O++;
        if (f === k.length || O === C.length)
          for (f = k.length - 1, O = C.length - 1; 1 <= f && 0 <= O && k[f] !== C[O]; )
            O--;
        for (; 1 <= f && 0 <= O; f--, O--)
          if (k[f] !== C[O]) {
            if (f !== 1 || O !== 1)
              do
                if (f--, O--, 0 > O || k[f] !== C[O]) {
                  var D = `
` + k[f].replace(" at new ", " at ");
                  return l.displayName && D.includes("<anonymous>") && (D = D.replace("<anonymous>", l.displayName)), D;
                }
              while (1 <= f && 0 <= O);
            break;
          }
      }
    } finally {
      af = !1, Error.prepareStackTrace = c;
    }
    return (c = l ? l.displayName || l.name : "") ? ns(c) : "";
  }
  function Gk(l) {
    switch (l.tag) {
      case 26:
      case 27:
      case 5:
        return ns(l.type);
      case 16:
        return ns("Lazy");
      case 13:
        return ns("Suspense");
      case 19:
        return ns("SuspenseList");
      case 0:
      case 15:
        return of(l.type, !1);
      case 11:
        return of(l.type.render, !1);
      case 1:
        return of(l.type, !0);
      case 31:
        return ns("Activity");
      default:
        return "";
    }
  }
  function ym(l) {
    try {
      var r = "";
      do
        r += Gk(l), l = l.return;
      while (l);
      return r;
    } catch (c) {
      return `
Error generating stack: ` + c.message + `
` + c.stack;
    }
  }
  function ci(l) {
    switch (typeof l) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return l;
      case "object":
        return l;
      default:
        return "";
    }
  }
  function Sm(l) {
    var r = l.type;
    return (l = l.nodeName) && l.toLowerCase() === "input" && (r === "checkbox" || r === "radio");
  }
  function Nk(l) {
    var r = Sm(l) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(
      l.constructor.prototype,
      r
    ), f = "" + l[r];
    if (!l.hasOwnProperty(r) && typeof c < "u" && typeof c.get == "function" && typeof c.set == "function") {
      var O = c.get, m = c.set;
      return Object.defineProperty(l, r, {
        configurable: !0,
        get: function() {
          return O.call(this);
        },
        set: function(S) {
          f = "" + S, m.call(this, S);
        }
      }), Object.defineProperty(l, r, {
        enumerable: c.enumerable
      }), {
        getValue: function() {
          return f;
        },
        setValue: function(S) {
          f = "" + S;
        },
        stopTracking: function() {
          l._valueTracker = null, delete l[r];
        }
      };
    }
  }
  function ho(l) {
    l._valueTracker || (l._valueTracker = Nk(l));
  }
  function Qm(l) {
    if (!l) return !1;
    var r = l._valueTracker;
    if (!r) return !0;
    var c = r.getValue(), f = "";
    return l && (f = Sm(l) ? l.checked ? "true" : "false" : l.value), l = f, l !== c ? (r.setValue(l), !0) : !1;
  }
  function Oo(l) {
    if (l = l || (typeof document < "u" ? document : void 0), typeof l > "u") return null;
    try {
      return l.activeElement || l.body;
    } catch {
      return l.body;
    }
  }
  var Wk = /[\n"\\]/g;
  function ui(l) {
    return l.replace(
      Wk,
      function(r) {
        return "\\" + r.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function cf(l, r, c, f, O, m, S, v) {
    l.name = "", S != null && typeof S != "function" && typeof S != "symbol" && typeof S != "boolean" ? l.type = S : l.removeAttribute("type"), r != null ? S === "number" ? (r === 0 && l.value === "" || l.value != r) && (l.value = "" + ci(r)) : l.value !== "" + ci(r) && (l.value = "" + ci(r)) : S !== "submit" && S !== "reset" || l.removeAttribute("value"), r != null ? uf(l, S, ci(r)) : c != null ? uf(l, S, ci(c)) : f != null && l.removeAttribute("value"), O == null && m != null && (l.defaultChecked = !!m), O != null && (l.checked = O && typeof O != "function" && typeof O != "symbol"), v != null && typeof v != "function" && typeof v != "symbol" && typeof v != "boolean" ? l.name = "" + ci(v) : l.removeAttribute("name");
  }
  function vm(l, r, c, f, O, m, S, v) {
    if (m != null && typeof m != "function" && typeof m != "symbol" && typeof m != "boolean" && (l.type = m), r != null || c != null) {
      if (!(m !== "submit" && m !== "reset" || r != null))
        return;
      c = c != null ? "" + ci(c) : "", r = r != null ? "" + ci(r) : c, v || r === l.value || (l.value = r), l.defaultValue = r;
    }
    f = f ?? O, f = typeof f != "function" && typeof f != "symbol" && !!f, l.checked = v ? l.checked : !!f, l.defaultChecked = !!f, S != null && typeof S != "function" && typeof S != "symbol" && typeof S != "boolean" && (l.name = S);
  }
  function uf(l, r, c) {
    r === "number" && Oo(l.ownerDocument) === l || l.defaultValue === "" + c || (l.defaultValue = "" + c);
  }
  function ls(l, r, c, f) {
    if (l = l.options, r) {
      r = {};
      for (var O = 0; O < c.length; O++)
        r["$" + c[O]] = !0;
      for (c = 0; c < l.length; c++)
        O = r.hasOwnProperty("$" + l[c].value), l[c].selected !== O && (l[c].selected = O), O && f && (l[c].defaultSelected = !0);
    } else {
      for (c = "" + ci(c), r = null, O = 0; O < l.length; O++) {
        if (l[O].value === c) {
          l[O].selected = !0, f && (l[O].defaultSelected = !0);
          return;
        }
        r !== null || l[O].disabled || (r = l[O]);
      }
      r !== null && (r.selected = !0);
    }
  }
  function bm(l, r, c) {
    if (r != null && (r = "" + ci(r), r !== l.value && (l.value = r), c == null)) {
      l.defaultValue !== r && (l.defaultValue = r);
      return;
    }
    l.defaultValue = c != null ? "" + ci(c) : "";
  }
  function xm(l, r, c, f) {
    if (r == null) {
      if (f != null) {
        if (c != null) throw Error(i(92));
        if (ht(f)) {
          if (1 < f.length) throw Error(i(93));
          f = f[0];
        }
        c = f;
      }
      c == null && (c = ""), r = c;
    }
    c = ci(r), l.defaultValue = c, f = l.textContent, f === c && f !== "" && f !== null && (l.value = f);
  }
  function ss(l, r) {
    if (r) {
      var c = l.firstChild;
      if (c && c === l.lastChild && c.nodeType === 3) {
        c.nodeValue = r;
        return;
      }
    }
    l.textContent = r;
  }
  var Hk = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function km(l, r, c) {
    var f = r.indexOf("--") === 0;
    c == null || typeof c == "boolean" || c === "" ? f ? l.setProperty(r, "") : r === "float" ? l.cssFloat = "" : l[r] = "" : f ? l.setProperty(r, c) : typeof c != "number" || c === 0 || Hk.has(r) ? r === "float" ? l.cssFloat = c : l[r] = ("" + c).trim() : l[r] = c + "px";
  }
  function wm(l, r, c) {
    if (r != null && typeof r != "object")
      throw Error(i(62));
    if (l = l.style, c != null) {
      for (var f in c)
        !c.hasOwnProperty(f) || r != null && r.hasOwnProperty(f) || (f.indexOf("--") === 0 ? l.setProperty(f, "") : f === "float" ? l.cssFloat = "" : l[f] = "");
      for (var O in r)
        f = r[O], r.hasOwnProperty(O) && c[O] !== f && km(l, O, f);
    } else
      for (var m in r)
        r.hasOwnProperty(m) && km(l, m, r[m]);
  }
  function ff(l) {
    if (l.indexOf("-") === -1) return !1;
    switch (l) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var Kk = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), Jk = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function po(l) {
    return Jk.test("" + l) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : l;
  }
  var hf = null;
  function Of(l) {
    return l = l.target || l.srcElement || window, l.correspondingUseElement && (l = l.correspondingUseElement), l.nodeType === 3 ? l.parentNode : l;
  }
  var rs = null, as = null;
  function Tm(l) {
    var r = ts(l);
    if (r && (l = r.stateNode)) {
      var c = l[_e] || null;
      t: switch (l = r.stateNode, r.type) {
        case "input":
          if (cf(
            l,
            c.value,
            c.defaultValue,
            c.defaultValue,
            c.checked,
            c.defaultChecked,
            c.type,
            c.name
          ), r = c.name, c.type === "radio" && r != null) {
            for (c = l; c.parentNode; ) c = c.parentNode;
            for (c = c.querySelectorAll(
              'input[name="' + ui(
                "" + r
              ) + '"][type="radio"]'
            ), r = 0; r < c.length; r++) {
              var f = c[r];
              if (f !== l && f.form === l.form) {
                var O = f[_e] || null;
                if (!O) throw Error(i(90));
                cf(
                  f,
                  O.value,
                  O.defaultValue,
                  O.defaultValue,
                  O.checked,
                  O.defaultChecked,
                  O.type,
                  O.name
                );
              }
            }
            for (r = 0; r < c.length; r++)
              f = c[r], f.form === l.form && Qm(f);
          }
          break t;
        case "textarea":
          bm(l, c.value, c.defaultValue);
          break t;
        case "select":
          r = c.value, r != null && ls(l, !!c.multiple, r, !1);
      }
    }
  }
  var df = !1;
  function $m(l, r, c) {
    if (df) return l(r, c);
    df = !0;
    try {
      var f = l(r);
      return f;
    } finally {
      if (df = !1, (rs !== null || as !== null) && (tc(), rs && (r = rs, l = as, as = rs = null, Tm(r), l)))
        for (r = 0; r < l.length; r++) Tm(l[r]);
    }
  }
  function pr(l, r) {
    var c = l.stateNode;
    if (c === null) return null;
    var f = c[_e] || null;
    if (f === null) return null;
    c = f[r];
    t: switch (r) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (f = !f.disabled) || (l = l.type, f = !(l === "button" || l === "input" || l === "select" || l === "textarea")), l = !f;
        break t;
      default:
        l = !1;
    }
    if (l) return null;
    if (c && typeof c != "function")
      throw Error(
        i(231, r, typeof c)
      );
    return c;
  }
  var ln = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), pf = !1;
  if (ln)
    try {
      var mr = {};
      Object.defineProperty(mr, "passive", {
        get: function() {
          pf = !0;
        }
      }), window.addEventListener("test", mr, mr), window.removeEventListener("test", mr, mr);
    } catch {
      pf = !1;
    }
  var Cn = null, mf = null, mo = null;
  function Pm() {
    if (mo) return mo;
    var l, r = mf, c = r.length, f, O = "value" in Cn ? Cn.value : Cn.textContent, m = O.length;
    for (l = 0; l < c && r[l] === O[l]; l++) ;
    var S = c - l;
    for (f = 1; f <= S && r[c - f] === O[m - f]; f++) ;
    return mo = O.slice(l, 1 < f ? 1 - f : void 0);
  }
  function go(l) {
    var r = l.keyCode;
    return "charCode" in l ? (l = l.charCode, l === 0 && r === 13 && (l = 13)) : l = r, l === 10 && (l = 13), 32 <= l || l === 13 ? l : 0;
  }
  function yo() {
    return !0;
  }
  function Rm() {
    return !1;
  }
  function ze(l) {
    function r(c, f, O, m, S) {
      this._reactName = c, this._targetInst = O, this.type = f, this.nativeEvent = m, this.target = S, this.currentTarget = null;
      for (var v in l)
        l.hasOwnProperty(v) && (c = l[v], this[v] = c ? c(m) : m[v]);
      return this.isDefaultPrevented = (m.defaultPrevented != null ? m.defaultPrevented : m.returnValue === !1) ? yo : Rm, this.isPropagationStopped = Rm, this;
    }
    return p(r.prototype, {
      preventDefault: function() {
        this.defaultPrevented = !0;
        var c = this.nativeEvent;
        c && (c.preventDefault ? c.preventDefault() : typeof c.returnValue != "unknown" && (c.returnValue = !1), this.isDefaultPrevented = yo);
      },
      stopPropagation: function() {
        var c = this.nativeEvent;
        c && (c.stopPropagation ? c.stopPropagation() : typeof c.cancelBubble != "unknown" && (c.cancelBubble = !0), this.isPropagationStopped = yo);
      },
      persist: function() {
      },
      isPersistent: yo
    }), r;
  }
  var yl = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(l) {
      return l.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, So = ze(yl), gr = p({}, yl, { view: 0, detail: 0 }), Ik = ze(gr), gf, yf, yr, Qo = p({}, gr, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: Qf,
    button: 0,
    buttons: 0,
    relatedTarget: function(l) {
      return l.relatedTarget === void 0 ? l.fromElement === l.srcElement ? l.toElement : l.fromElement : l.relatedTarget;
    },
    movementX: function(l) {
      return "movementX" in l ? l.movementX : (l !== yr && (yr && l.type === "mousemove" ? (gf = l.screenX - yr.screenX, yf = l.screenY - yr.screenY) : yf = gf = 0, yr = l), gf);
    },
    movementY: function(l) {
      return "movementY" in l ? l.movementY : yf;
    }
  }), Am = ze(Qo), Fk = p({}, Qo, { dataTransfer: 0 }), tw = ze(Fk), ew = p({}, gr, { relatedTarget: 0 }), Sf = ze(ew), iw = p({}, yl, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), nw = ze(iw), lw = p({}, yl, {
    clipboardData: function(l) {
      return "clipboardData" in l ? l.clipboardData : window.clipboardData;
    }
  }), sw = ze(lw), rw = p({}, yl, { data: 0 }), Mm = ze(rw), aw = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, ow = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, cw = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function uw(l) {
    var r = this.nativeEvent;
    return r.getModifierState ? r.getModifierState(l) : (l = cw[l]) ? !!r[l] : !1;
  }
  function Qf() {
    return uw;
  }
  var fw = p({}, gr, {
    key: function(l) {
      if (l.key) {
        var r = aw[l.key] || l.key;
        if (r !== "Unidentified") return r;
      }
      return l.type === "keypress" ? (l = go(l), l === 13 ? "Enter" : String.fromCharCode(l)) : l.type === "keydown" || l.type === "keyup" ? ow[l.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: Qf,
    charCode: function(l) {
      return l.type === "keypress" ? go(l) : 0;
    },
    keyCode: function(l) {
      return l.type === "keydown" || l.type === "keyup" ? l.keyCode : 0;
    },
    which: function(l) {
      return l.type === "keypress" ? go(l) : l.type === "keydown" || l.type === "keyup" ? l.keyCode : 0;
    }
  }), hw = ze(fw), Ow = p({}, Qo, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), qm = ze(Ow), dw = p({}, gr, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: Qf
  }), pw = ze(dw), mw = p({}, yl, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), gw = ze(mw), yw = p({}, Qo, {
    deltaX: function(l) {
      return "deltaX" in l ? l.deltaX : "wheelDeltaX" in l ? -l.wheelDeltaX : 0;
    },
    deltaY: function(l) {
      return "deltaY" in l ? l.deltaY : "wheelDeltaY" in l ? -l.wheelDeltaY : "wheelDelta" in l ? -l.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Sw = ze(yw), Qw = p({}, yl, {
    newState: 0,
    oldState: 0
  }), vw = ze(Qw), bw = [9, 13, 27, 32], vf = ln && "CompositionEvent" in window, Sr = null;
  ln && "documentMode" in document && (Sr = document.documentMode);
  var xw = ln && "TextEvent" in window && !Sr, Cm = ln && (!vf || Sr && 8 < Sr && 11 >= Sr), Zm = " ", Em = !1;
  function Xm(l, r) {
    switch (l) {
      case "keyup":
        return bw.indexOf(r.keyCode) !== -1;
      case "keydown":
        return r.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function _m(l) {
    return l = l.detail, typeof l == "object" && "data" in l ? l.data : null;
  }
  var os = !1;
  function kw(l, r) {
    switch (l) {
      case "compositionend":
        return _m(r);
      case "keypress":
        return r.which !== 32 ? null : (Em = !0, Zm);
      case "textInput":
        return l = r.data, l === Zm && Em ? null : l;
      default:
        return null;
    }
  }
  function ww(l, r) {
    if (os)
      return l === "compositionend" || !vf && Xm(l, r) ? (l = Pm(), mo = mf = Cn = null, os = !1, l) : null;
    switch (l) {
      case "paste":
        return null;
      case "keypress":
        if (!(r.ctrlKey || r.altKey || r.metaKey) || r.ctrlKey && r.altKey) {
          if (r.char && 1 < r.char.length)
            return r.char;
          if (r.which) return String.fromCharCode(r.which);
        }
        return null;
      case "compositionend":
        return Cm && r.locale !== "ko" ? null : r.data;
      default:
        return null;
    }
  }
  var Tw = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };
  function zm(l) {
    var r = l && l.nodeName && l.nodeName.toLowerCase();
    return r === "input" ? !!Tw[l.type] : r === "textarea";
  }
  function Dm(l, r, c, f) {
    rs ? as ? as.push(f) : as = [f] : rs = f, r = rc(r, "onChange"), 0 < r.length && (c = new So(
      "onChange",
      "change",
      null,
      c,
      f
    ), l.push({ event: c, listeners: r }));
  }
  var Qr = null, vr = null;
  function $w(l) {
    Sy(l, 0);
  }
  function vo(l) {
    var r = dr(l);
    if (Qm(r)) return l;
  }
  function Vm(l, r) {
    if (l === "change") return r;
  }
  var Ym = !1;
  if (ln) {
    var bf;
    if (ln) {
      var xf = "oninput" in document;
      if (!xf) {
        var Um = document.createElement("div");
        Um.setAttribute("oninput", "return;"), xf = typeof Um.oninput == "function";
      }
      bf = xf;
    } else bf = !1;
    Ym = bf && (!document.documentMode || 9 < document.documentMode);
  }
  function jm() {
    Qr && (Qr.detachEvent("onpropertychange", Lm), vr = Qr = null);
  }
  function Lm(l) {
    if (l.propertyName === "value" && vo(vr)) {
      var r = [];
      Dm(
        r,
        vr,
        l,
        Of(l)
      ), $m($w, r);
    }
  }
  function Pw(l, r, c) {
    l === "focusin" ? (jm(), Qr = r, vr = c, Qr.attachEvent("onpropertychange", Lm)) : l === "focusout" && jm();
  }
  function Rw(l) {
    if (l === "selectionchange" || l === "keyup" || l === "keydown")
      return vo(vr);
  }
  function Aw(l, r) {
    if (l === "click") return vo(r);
  }
  function Mw(l, r) {
    if (l === "input" || l === "change")
      return vo(r);
  }
  function qw(l, r) {
    return l === r && (l !== 0 || 1 / l === 1 / r) || l !== l && r !== r;
  }
  var Je = typeof Object.is == "function" ? Object.is : qw;
  function br(l, r) {
    if (Je(l, r)) return !0;
    if (typeof l != "object" || l === null || typeof r != "object" || r === null)
      return !1;
    var c = Object.keys(l), f = Object.keys(r);
    if (c.length !== f.length) return !1;
    for (f = 0; f < c.length; f++) {
      var O = c[f];
      if (!Ju.call(r, O) || !Je(l[O], r[O]))
        return !1;
    }
    return !0;
  }
  function Bm(l) {
    for (; l && l.firstChild; ) l = l.firstChild;
    return l;
  }
  function Gm(l, r) {
    var c = Bm(l);
    l = 0;
    for (var f; c; ) {
      if (c.nodeType === 3) {
        if (f = l + c.textContent.length, l <= r && f >= r)
          return { node: c, offset: r - l };
        l = f;
      }
      t: {
        for (; c; ) {
          if (c.nextSibling) {
            c = c.nextSibling;
            break t;
          }
          c = c.parentNode;
        }
        c = void 0;
      }
      c = Bm(c);
    }
  }
  function Nm(l, r) {
    return l && r ? l === r ? !0 : l && l.nodeType === 3 ? !1 : r && r.nodeType === 3 ? Nm(l, r.parentNode) : "contains" in l ? l.contains(r) : l.compareDocumentPosition ? !!(l.compareDocumentPosition(r) & 16) : !1 : !1;
  }
  function Wm(l) {
    l = l != null && l.ownerDocument != null && l.ownerDocument.defaultView != null ? l.ownerDocument.defaultView : window;
    for (var r = Oo(l.document); r instanceof l.HTMLIFrameElement; ) {
      try {
        var c = typeof r.contentWindow.location.href == "string";
      } catch {
        c = !1;
      }
      if (c) l = r.contentWindow;
      else break;
      r = Oo(l.document);
    }
    return r;
  }
  function kf(l) {
    var r = l && l.nodeName && l.nodeName.toLowerCase();
    return r && (r === "input" && (l.type === "text" || l.type === "search" || l.type === "tel" || l.type === "url" || l.type === "password") || r === "textarea" || l.contentEditable === "true");
  }
  var Cw = ln && "documentMode" in document && 11 >= document.documentMode, cs = null, wf = null, xr = null, Tf = !1;
  function Hm(l, r, c) {
    var f = c.window === c ? c.document : c.nodeType === 9 ? c : c.ownerDocument;
    Tf || cs == null || cs !== Oo(f) || (f = cs, "selectionStart" in f && kf(f) ? f = { start: f.selectionStart, end: f.selectionEnd } : (f = (f.ownerDocument && f.ownerDocument.defaultView || window).getSelection(), f = {
      anchorNode: f.anchorNode,
      anchorOffset: f.anchorOffset,
      focusNode: f.focusNode,
      focusOffset: f.focusOffset
    }), xr && br(xr, f) || (xr = f, f = rc(wf, "onSelect"), 0 < f.length && (r = new So(
      "onSelect",
      "select",
      null,
      r,
      c
    ), l.push({ event: r, listeners: f }), r.target = cs)));
  }
  function Sl(l, r) {
    var c = {};
    return c[l.toLowerCase()] = r.toLowerCase(), c["Webkit" + l] = "webkit" + r, c["Moz" + l] = "moz" + r, c;
  }
  var us = {
    animationend: Sl("Animation", "AnimationEnd"),
    animationiteration: Sl("Animation", "AnimationIteration"),
    animationstart: Sl("Animation", "AnimationStart"),
    transitionrun: Sl("Transition", "TransitionRun"),
    transitionstart: Sl("Transition", "TransitionStart"),
    transitioncancel: Sl("Transition", "TransitionCancel"),
    transitionend: Sl("Transition", "TransitionEnd")
  }, $f = {}, Km = {};
  ln && (Km = document.createElement("div").style, "AnimationEvent" in window || (delete us.animationend.animation, delete us.animationiteration.animation, delete us.animationstart.animation), "TransitionEvent" in window || delete us.transitionend.transition);
  function Ql(l) {
    if ($f[l]) return $f[l];
    if (!us[l]) return l;
    var r = us[l], c;
    for (c in r)
      if (r.hasOwnProperty(c) && c in Km)
        return $f[l] = r[c];
    return l;
  }
  var Jm = Ql("animationend"), Im = Ql("animationiteration"), Fm = Ql("animationstart"), Zw = Ql("transitionrun"), Ew = Ql("transitionstart"), Xw = Ql("transitioncancel"), tg = Ql("transitionend"), eg = /* @__PURE__ */ new Map(), Pf = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
    " "
  );
  Pf.push("scrollEnd");
  function ki(l, r) {
    eg.set(l, r), gl(r, [l]);
  }
  var ig = /* @__PURE__ */ new WeakMap();
  function fi(l, r) {
    if (typeof l == "object" && l !== null) {
      var c = ig.get(l);
      return c !== void 0 ? c : (r = {
        value: l,
        source: r,
        stack: ym(r)
      }, ig.set(l, r), r);
    }
    return {
      value: l,
      source: r,
      stack: ym(r)
    };
  }
  var hi = [], fs = 0, Rf = 0;
  function bo() {
    for (var l = fs, r = Rf = fs = 0; r < l; ) {
      var c = hi[r];
      hi[r++] = null;
      var f = hi[r];
      hi[r++] = null;
      var O = hi[r];
      hi[r++] = null;
      var m = hi[r];
      if (hi[r++] = null, f !== null && O !== null) {
        var S = f.pending;
        S === null ? O.next = O : (O.next = S.next, S.next = O), f.pending = O;
      }
      m !== 0 && ng(c, O, m);
    }
  }
  function xo(l, r, c, f) {
    hi[fs++] = l, hi[fs++] = r, hi[fs++] = c, hi[fs++] = f, Rf |= f, l.lanes |= f, l = l.alternate, l !== null && (l.lanes |= f);
  }
  function Af(l, r, c, f) {
    return xo(l, r, c, f), ko(l);
  }
  function hs(l, r) {
    return xo(l, null, null, r), ko(l);
  }
  function ng(l, r, c) {
    l.lanes |= c;
    var f = l.alternate;
    f !== null && (f.lanes |= c);
    for (var O = !1, m = l.return; m !== null; )
      m.childLanes |= c, f = m.alternate, f !== null && (f.childLanes |= c), m.tag === 22 && (l = m.stateNode, l === null || l._visibility & 1 || (O = !0)), l = m, m = m.return;
    return l.tag === 3 ? (m = l.stateNode, O && r !== null && (O = 31 - Ke(c), l = m.hiddenUpdates, f = l[O], f === null ? l[O] = [r] : f.push(r), r.lane = c | 536870912), m) : null;
  }
  function ko(l) {
    if (50 < Wr)
      throw Wr = 0, Xh = null, Error(i(185));
    for (var r = l.return; r !== null; )
      l = r, r = l.return;
    return l.tag === 3 ? l.stateNode : null;
  }
  var Os = {};
  function _w(l, r, c, f) {
    this.tag = l, this.key = c, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = r, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = f, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Ie(l, r, c, f) {
    return new _w(l, r, c, f);
  }
  function Mf(l) {
    return l = l.prototype, !(!l || !l.isReactComponent);
  }
  function sn(l, r) {
    var c = l.alternate;
    return c === null ? (c = Ie(
      l.tag,
      r,
      l.key,
      l.mode
    ), c.elementType = l.elementType, c.type = l.type, c.stateNode = l.stateNode, c.alternate = l, l.alternate = c) : (c.pendingProps = r, c.type = l.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null), c.flags = l.flags & 65011712, c.childLanes = l.childLanes, c.lanes = l.lanes, c.child = l.child, c.memoizedProps = l.memoizedProps, c.memoizedState = l.memoizedState, c.updateQueue = l.updateQueue, r = l.dependencies, c.dependencies = r === null ? null : { lanes: r.lanes, firstContext: r.firstContext }, c.sibling = l.sibling, c.index = l.index, c.ref = l.ref, c.refCleanup = l.refCleanup, c;
  }
  function lg(l, r) {
    l.flags &= 65011714;
    var c = l.alternate;
    return c === null ? (l.childLanes = 0, l.lanes = r, l.child = null, l.subtreeFlags = 0, l.memoizedProps = null, l.memoizedState = null, l.updateQueue = null, l.dependencies = null, l.stateNode = null) : (l.childLanes = c.childLanes, l.lanes = c.lanes, l.child = c.child, l.subtreeFlags = 0, l.deletions = null, l.memoizedProps = c.memoizedProps, l.memoizedState = c.memoizedState, l.updateQueue = c.updateQueue, l.type = c.type, r = c.dependencies, l.dependencies = r === null ? null : {
      lanes: r.lanes,
      firstContext: r.firstContext
    }), l;
  }
  function wo(l, r, c, f, O, m) {
    var S = 0;
    if (f = l, typeof l == "function") Mf(l) && (S = 1);
    else if (typeof l == "string")
      S = DT(
        l,
        c,
        ct.current
      ) ? 26 : l === "html" || l === "head" || l === "body" ? 27 : 5;
    else
      t: switch (l) {
        case N:
          return l = Ie(31, c, r, O), l.elementType = N, l.lanes = m, l;
        case b:
          return vl(c.children, O, m, r);
        case x:
          S = 8, O |= 24;
          break;
        case P:
          return l = Ie(12, c, r, O | 2), l.elementType = P, l.lanes = m, l;
        case _:
          return l = Ie(13, c, r, O), l.elementType = _, l.lanes = m, l;
        case W:
          return l = Ie(19, c, r, O), l.elementType = W, l.lanes = m, l;
        default:
          if (typeof l == "object" && l !== null)
            switch (l.$$typeof) {
              case A:
              case G:
                S = 10;
                break t;
              case V:
                S = 9;
                break t;
              case H:
                S = 11;
                break t;
              case q:
                S = 14;
                break t;
              case J:
                S = 16, f = null;
                break t;
            }
          S = 29, c = Error(
            i(130, l === null ? "null" : typeof l, "")
          ), f = null;
      }
    return r = Ie(S, c, r, O), r.elementType = l, r.type = f, r.lanes = m, r;
  }
  function vl(l, r, c, f) {
    return l = Ie(7, l, f, r), l.lanes = c, l;
  }
  function qf(l, r, c) {
    return l = Ie(6, l, null, r), l.lanes = c, l;
  }
  function Cf(l, r, c) {
    return r = Ie(
      4,
      l.children !== null ? l.children : [],
      l.key,
      r
    ), r.lanes = c, r.stateNode = {
      containerInfo: l.containerInfo,
      pendingChildren: null,
      implementation: l.implementation
    }, r;
  }
  var ds = [], ps = 0, To = null, $o = 0, Oi = [], di = 0, bl = null, rn = 1, an = "";
  function xl(l, r) {
    ds[ps++] = $o, ds[ps++] = To, To = l, $o = r;
  }
  function sg(l, r, c) {
    Oi[di++] = rn, Oi[di++] = an, Oi[di++] = bl, bl = l;
    var f = rn;
    l = an;
    var O = 32 - Ke(f) - 1;
    f &= ~(1 << O), c += 1;
    var m = 32 - Ke(r) + O;
    if (30 < m) {
      var S = O - O % 5;
      m = (f & (1 << S) - 1).toString(32), f >>= S, O -= S, rn = 1 << 32 - Ke(r) + O | c << O | f, an = m + l;
    } else
      rn = 1 << m | c << O | f, an = l;
  }
  function Zf(l) {
    l.return !== null && (xl(l, 1), sg(l, 1, 0));
  }
  function Ef(l) {
    for (; l === To; )
      To = ds[--ps], ds[ps] = null, $o = ds[--ps], ds[ps] = null;
    for (; l === bl; )
      bl = Oi[--di], Oi[di] = null, an = Oi[--di], Oi[di] = null, rn = Oi[--di], Oi[di] = null;
  }
  var Ze = null, Jt = null, Ct = !1, kl = null, qi = !1, Xf = Error(i(519));
  function wl(l) {
    var r = Error(i(418, ""));
    throw Tr(fi(r, l)), Xf;
  }
  function rg(l) {
    var r = l.stateNode, c = l.type, f = l.memoizedProps;
    switch (r[Pe] = l, r[_e] = f, c) {
      case "dialog":
        Tt("cancel", r), Tt("close", r);
        break;
      case "iframe":
      case "object":
      case "embed":
        Tt("load", r);
        break;
      case "video":
      case "audio":
        for (c = 0; c < Kr.length; c++)
          Tt(Kr[c], r);
        break;
      case "source":
        Tt("error", r);
        break;
      case "img":
      case "image":
      case "link":
        Tt("error", r), Tt("load", r);
        break;
      case "details":
        Tt("toggle", r);
        break;
      case "input":
        Tt("invalid", r), vm(
          r,
          f.value,
          f.defaultValue,
          f.checked,
          f.defaultChecked,
          f.type,
          f.name,
          !0
        ), ho(r);
        break;
      case "select":
        Tt("invalid", r);
        break;
      case "textarea":
        Tt("invalid", r), xm(r, f.value, f.defaultValue, f.children), ho(r);
    }
    c = f.children, typeof c != "string" && typeof c != "number" && typeof c != "bigint" || r.textContent === "" + c || f.suppressHydrationWarning === !0 || xy(r.textContent, c) ? (f.popover != null && (Tt("beforetoggle", r), Tt("toggle", r)), f.onScroll != null && Tt("scroll", r), f.onScrollEnd != null && Tt("scrollend", r), f.onClick != null && (r.onclick = ac), r = !0) : r = !1, r || wl(l);
  }
  function ag(l) {
    for (Ze = l.return; Ze; )
      switch (Ze.tag) {
        case 5:
        case 13:
          qi = !1;
          return;
        case 27:
        case 3:
          qi = !0;
          return;
        default:
          Ze = Ze.return;
      }
  }
  function kr(l) {
    if (l !== Ze) return !1;
    if (!Ct) return ag(l), Ct = !0, !1;
    var r = l.tag, c;
    if ((c = r !== 3 && r !== 27) && ((c = r === 5) && (c = l.type, c = !(c !== "form" && c !== "button") || Ih(l.type, l.memoizedProps)), c = !c), c && Jt && wl(l), ag(l), r === 13) {
      if (l = l.memoizedState, l = l !== null ? l.dehydrated : null, !l) throw Error(i(317));
      t: {
        for (l = l.nextSibling, r = 0; l; ) {
          if (l.nodeType === 8)
            if (c = l.data, c === "/$") {
              if (r === 0) {
                Jt = Ti(l.nextSibling);
                break t;
              }
              r--;
            } else
              c !== "$" && c !== "$!" && c !== "$?" || r++;
          l = l.nextSibling;
        }
        Jt = null;
      }
    } else
      r === 27 ? (r = Jt, Hn(l.type) ? (l = iO, iO = null, Jt = l) : Jt = r) : Jt = Ze ? Ti(l.stateNode.nextSibling) : null;
    return !0;
  }
  function wr() {
    Jt = Ze = null, Ct = !1;
  }
  function og() {
    var l = kl;
    return l !== null && (Ye === null ? Ye = l : Ye.push.apply(
      Ye,
      l
    ), kl = null), l;
  }
  function Tr(l) {
    kl === null ? kl = [l] : kl.push(l);
  }
  var _f = L(null), Tl = null, on = null;
  function Zn(l, r, c) {
    F(_f, r._currentValue), r._currentValue = c;
  }
  function cn(l) {
    l._currentValue = _f.current, tt(_f);
  }
  function zf(l, r, c) {
    for (; l !== null; ) {
      var f = l.alternate;
      if ((l.childLanes & r) !== r ? (l.childLanes |= r, f !== null && (f.childLanes |= r)) : f !== null && (f.childLanes & r) !== r && (f.childLanes |= r), l === c) break;
      l = l.return;
    }
  }
  function Df(l, r, c, f) {
    var O = l.child;
    for (O !== null && (O.return = l); O !== null; ) {
      var m = O.dependencies;
      if (m !== null) {
        var S = O.child;
        m = m.firstContext;
        t: for (; m !== null; ) {
          var v = m;
          m = O;
          for (var k = 0; k < r.length; k++)
            if (v.context === r[k]) {
              m.lanes |= c, v = m.alternate, v !== null && (v.lanes |= c), zf(
                m.return,
                c,
                l
              ), f || (S = null);
              break t;
            }
          m = v.next;
        }
      } else if (O.tag === 18) {
        if (S = O.return, S === null) throw Error(i(341));
        S.lanes |= c, m = S.alternate, m !== null && (m.lanes |= c), zf(S, c, l), S = null;
      } else S = O.child;
      if (S !== null) S.return = O;
      else
        for (S = O; S !== null; ) {
          if (S === l) {
            S = null;
            break;
          }
          if (O = S.sibling, O !== null) {
            O.return = S.return, S = O;
            break;
          }
          S = S.return;
        }
      O = S;
    }
  }
  function $r(l, r, c, f) {
    l = null;
    for (var O = r, m = !1; O !== null; ) {
      if (!m) {
        if ((O.flags & 524288) !== 0) m = !0;
        else if ((O.flags & 262144) !== 0) break;
      }
      if (O.tag === 10) {
        var S = O.alternate;
        if (S === null) throw Error(i(387));
        if (S = S.memoizedProps, S !== null) {
          var v = O.type;
          Je(O.pendingProps.value, S.value) || (l !== null ? l.push(v) : l = [v]);
        }
      } else if (O === $e.current) {
        if (S = O.alternate, S === null) throw Error(i(387));
        S.memoizedState.memoizedState !== O.memoizedState.memoizedState && (l !== null ? l.push(ia) : l = [ia]);
      }
      O = O.return;
    }
    l !== null && Df(
      r,
      l,
      c,
      f
    ), r.flags |= 262144;
  }
  function Po(l) {
    for (l = l.firstContext; l !== null; ) {
      if (!Je(
        l.context._currentValue,
        l.memoizedValue
      ))
        return !0;
      l = l.next;
    }
    return !1;
  }
  function $l(l) {
    Tl = l, on = null, l = l.dependencies, l !== null && (l.firstContext = null);
  }
  function Re(l) {
    return cg(Tl, l);
  }
  function Ro(l, r) {
    return Tl === null && $l(l), cg(l, r);
  }
  function cg(l, r) {
    var c = r._currentValue;
    if (r = { context: r, memoizedValue: c, next: null }, on === null) {
      if (l === null) throw Error(i(308));
      on = r, l.dependencies = { lanes: 0, firstContext: r }, l.flags |= 524288;
    } else on = on.next = r;
    return c;
  }
  var zw = typeof AbortController < "u" ? AbortController : function() {
    var l = [], r = this.signal = {
      aborted: !1,
      addEventListener: function(c, f) {
        l.push(f);
      }
    };
    this.abort = function() {
      r.aborted = !0, l.forEach(function(c) {
        return c();
      });
    };
  }, Dw = n.unstable_scheduleCallback, Vw = n.unstable_NormalPriority, fe = {
    $$typeof: G,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function Vf() {
    return {
      controller: new zw(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function Pr(l) {
    l.refCount--, l.refCount === 0 && Dw(Vw, function() {
      l.controller.abort();
    });
  }
  var Rr = null, Yf = 0, ms = 0, gs = null;
  function Yw(l, r) {
    if (Rr === null) {
      var c = Rr = [];
      Yf = 0, ms = jh(), gs = {
        status: "pending",
        value: void 0,
        then: function(f) {
          c.push(f);
        }
      };
    }
    return Yf++, r.then(ug, ug), r;
  }
  function ug() {
    if (--Yf === 0 && Rr !== null) {
      gs !== null && (gs.status = "fulfilled");
      var l = Rr;
      Rr = null, ms = 0, gs = null;
      for (var r = 0; r < l.length; r++) (0, l[r])();
    }
  }
  function Uw(l, r) {
    var c = [], f = {
      status: "pending",
      value: null,
      reason: null,
      then: function(O) {
        c.push(O);
      }
    };
    return l.then(
      function() {
        f.status = "fulfilled", f.value = r;
        for (var O = 0; O < c.length; O++) (0, c[O])(r);
      },
      function(O) {
        for (f.status = "rejected", f.reason = O, O = 0; O < c.length; O++)
          (0, c[O])(void 0);
      }
    ), f;
  }
  var fg = E.S;
  E.S = function(l, r) {
    typeof r == "object" && r !== null && typeof r.then == "function" && Yw(l, r), fg !== null && fg(l, r);
  };
  var Pl = L(null);
  function Uf() {
    var l = Pl.current;
    return l !== null ? l : jt.pooledCache;
  }
  function Ao(l, r) {
    r === null ? F(Pl, Pl.current) : F(Pl, r.pool);
  }
  function hg() {
    var l = Uf();
    return l === null ? null : { parent: fe._currentValue, pool: l };
  }
  var Ar = Error(i(460)), Og = Error(i(474)), Mo = Error(i(542)), jf = { then: function() {
  } };
  function dg(l) {
    return l = l.status, l === "fulfilled" || l === "rejected";
  }
  function qo() {
  }
  function pg(l, r, c) {
    switch (c = l[c], c === void 0 ? l.push(r) : c !== r && (r.then(qo, qo), r = c), r.status) {
      case "fulfilled":
        return r.value;
      case "rejected":
        throw l = r.reason, gg(l), l;
      default:
        if (typeof r.status == "string") r.then(qo, qo);
        else {
          if (l = jt, l !== null && 100 < l.shellSuspendCounter)
            throw Error(i(482));
          l = r, l.status = "pending", l.then(
            function(f) {
              if (r.status === "pending") {
                var O = r;
                O.status = "fulfilled", O.value = f;
              }
            },
            function(f) {
              if (r.status === "pending") {
                var O = r;
                O.status = "rejected", O.reason = f;
              }
            }
          );
        }
        switch (r.status) {
          case "fulfilled":
            return r.value;
          case "rejected":
            throw l = r.reason, gg(l), l;
        }
        throw Mr = r, Ar;
    }
  }
  var Mr = null;
  function mg() {
    if (Mr === null) throw Error(i(459));
    var l = Mr;
    return Mr = null, l;
  }
  function gg(l) {
    if (l === Ar || l === Mo)
      throw Error(i(483));
  }
  var En = !1;
  function Lf(l) {
    l.updateQueue = {
      baseState: l.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function Bf(l, r) {
    l = l.updateQueue, r.updateQueue === l && (r.updateQueue = {
      baseState: l.baseState,
      firstBaseUpdate: l.firstBaseUpdate,
      lastBaseUpdate: l.lastBaseUpdate,
      shared: l.shared,
      callbacks: null
    });
  }
  function Xn(l) {
    return { lane: l, tag: 0, payload: null, callback: null, next: null };
  }
  function _n(l, r, c) {
    var f = l.updateQueue;
    if (f === null) return null;
    if (f = f.shared, (Zt & 2) !== 0) {
      var O = f.pending;
      return O === null ? r.next = r : (r.next = O.next, O.next = r), f.pending = r, r = ko(l), ng(l, null, c), r;
    }
    return xo(l, f, r, c), ko(l);
  }
  function qr(l, r, c) {
    if (r = r.updateQueue, r !== null && (r = r.shared, (c & 4194048) !== 0)) {
      var f = r.lanes;
      f &= l.pendingLanes, c |= f, r.lanes = c, um(l, c);
    }
  }
  function Gf(l, r) {
    var c = l.updateQueue, f = l.alternate;
    if (f !== null && (f = f.updateQueue, c === f)) {
      var O = null, m = null;
      if (c = c.firstBaseUpdate, c !== null) {
        do {
          var S = {
            lane: c.lane,
            tag: c.tag,
            payload: c.payload,
            callback: null,
            next: null
          };
          m === null ? O = m = S : m = m.next = S, c = c.next;
        } while (c !== null);
        m === null ? O = m = r : m = m.next = r;
      } else O = m = r;
      c = {
        baseState: f.baseState,
        firstBaseUpdate: O,
        lastBaseUpdate: m,
        shared: f.shared,
        callbacks: f.callbacks
      }, l.updateQueue = c;
      return;
    }
    l = c.lastBaseUpdate, l === null ? c.firstBaseUpdate = r : l.next = r, c.lastBaseUpdate = r;
  }
  var Nf = !1;
  function Cr() {
    if (Nf) {
      var l = gs;
      if (l !== null) throw l;
    }
  }
  function Zr(l, r, c, f) {
    Nf = !1;
    var O = l.updateQueue;
    En = !1;
    var m = O.firstBaseUpdate, S = O.lastBaseUpdate, v = O.shared.pending;
    if (v !== null) {
      O.shared.pending = null;
      var k = v, C = k.next;
      k.next = null, S === null ? m = C : S.next = C, S = k;
      var D = l.alternate;
      D !== null && (D = D.updateQueue, v = D.lastBaseUpdate, v !== S && (v === null ? D.firstBaseUpdate = C : v.next = C, D.lastBaseUpdate = k));
    }
    if (m !== null) {
      var B = O.baseState;
      S = 0, D = C = k = null, v = m;
      do {
        var Z = v.lane & -536870913, X = Z !== v.lane;
        if (X ? (Pt & Z) === Z : (f & Z) === Z) {
          Z !== 0 && Z === ms && (Nf = !0), D !== null && (D = D.next = {
            lane: 0,
            tag: v.tag,
            payload: v.payload,
            callback: null,
            next: null
          });
          t: {
            var gt = l, dt = v;
            Z = r;
            var zt = c;
            switch (dt.tag) {
              case 1:
                if (gt = dt.payload, typeof gt == "function") {
                  B = gt.call(zt, B, Z);
                  break t;
                }
                B = gt;
                break t;
              case 3:
                gt.flags = gt.flags & -65537 | 128;
              case 0:
                if (gt = dt.payload, Z = typeof gt == "function" ? gt.call(zt, B, Z) : gt, Z == null) break t;
                B = p({}, B, Z);
                break t;
              case 2:
                En = !0;
            }
          }
          Z = v.callback, Z !== null && (l.flags |= 64, X && (l.flags |= 8192), X = O.callbacks, X === null ? O.callbacks = [Z] : X.push(Z));
        } else
          X = {
            lane: Z,
            tag: v.tag,
            payload: v.payload,
            callback: v.callback,
            next: null
          }, D === null ? (C = D = X, k = B) : D = D.next = X, S |= Z;
        if (v = v.next, v === null) {
          if (v = O.shared.pending, v === null)
            break;
          X = v, v = X.next, X.next = null, O.lastBaseUpdate = X, O.shared.pending = null;
        }
      } while (!0);
      D === null && (k = B), O.baseState = k, O.firstBaseUpdate = C, O.lastBaseUpdate = D, m === null && (O.shared.lanes = 0), Bn |= S, l.lanes = S, l.memoizedState = B;
    }
  }
  function yg(l, r) {
    if (typeof l != "function")
      throw Error(i(191, l));
    l.call(r);
  }
  function Sg(l, r) {
    var c = l.callbacks;
    if (c !== null)
      for (l.callbacks = null, l = 0; l < c.length; l++)
        yg(c[l], r);
  }
  var ys = L(null), Co = L(0);
  function Qg(l, r) {
    l = mn, F(Co, l), F(ys, r), mn = l | r.baseLanes;
  }
  function Wf() {
    F(Co, mn), F(ys, ys.current);
  }
  function Hf() {
    mn = Co.current, tt(ys), tt(Co);
  }
  var zn = 0, bt = null, Xt = null, le = null, Zo = !1, Ss = !1, Rl = !1, Eo = 0, Er = 0, Qs = null, jw = 0;
  function Ft() {
    throw Error(i(321));
  }
  function Kf(l, r) {
    if (r === null) return !1;
    for (var c = 0; c < r.length && c < l.length; c++)
      if (!Je(l[c], r[c])) return !1;
    return !0;
  }
  function Jf(l, r, c, f, O, m) {
    return zn = m, bt = r, r.memoizedState = null, r.updateQueue = null, r.lanes = 0, E.H = l === null || l.memoizedState === null ? n0 : l0, Rl = !1, m = c(f, O), Rl = !1, Ss && (m = bg(
      r,
      c,
      f,
      O
    )), vg(l), m;
  }
  function vg(l) {
    E.H = Yo;
    var r = Xt !== null && Xt.next !== null;
    if (zn = 0, le = Xt = bt = null, Zo = !1, Er = 0, Qs = null, r) throw Error(i(300));
    l === null || pe || (l = l.dependencies, l !== null && Po(l) && (pe = !0));
  }
  function bg(l, r, c, f) {
    bt = l;
    var O = 0;
    do {
      if (Ss && (Qs = null), Er = 0, Ss = !1, 25 <= O) throw Error(i(301));
      if (O += 1, le = Xt = null, l.updateQueue != null) {
        var m = l.updateQueue;
        m.lastEffect = null, m.events = null, m.stores = null, m.memoCache != null && (m.memoCache.index = 0);
      }
      E.H = Kw, m = r(c, f);
    } while (Ss);
    return m;
  }
  function Lw() {
    var l = E.H, r = l.useState()[0];
    return r = typeof r.then == "function" ? Xr(r) : r, l = l.useState()[0], (Xt !== null ? Xt.memoizedState : null) !== l && (bt.flags |= 1024), r;
  }
  function If() {
    var l = Eo !== 0;
    return Eo = 0, l;
  }
  function Ff(l, r, c) {
    r.updateQueue = l.updateQueue, r.flags &= -2053, l.lanes &= ~c;
  }
  function th(l) {
    if (Zo) {
      for (l = l.memoizedState; l !== null; ) {
        var r = l.queue;
        r !== null && (r.pending = null), l = l.next;
      }
      Zo = !1;
    }
    zn = 0, le = Xt = bt = null, Ss = !1, Er = Eo = 0, Qs = null;
  }
  function De() {
    var l = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return le === null ? bt.memoizedState = le = l : le = le.next = l, le;
  }
  function se() {
    if (Xt === null) {
      var l = bt.alternate;
      l = l !== null ? l.memoizedState : null;
    } else l = Xt.next;
    var r = le === null ? bt.memoizedState : le.next;
    if (r !== null)
      le = r, Xt = l;
    else {
      if (l === null)
        throw bt.alternate === null ? Error(i(467)) : Error(i(310));
      Xt = l, l = {
        memoizedState: Xt.memoizedState,
        baseState: Xt.baseState,
        baseQueue: Xt.baseQueue,
        queue: Xt.queue,
        next: null
      }, le === null ? bt.memoizedState = le = l : le = le.next = l;
    }
    return le;
  }
  function eh() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function Xr(l) {
    var r = Er;
    return Er += 1, Qs === null && (Qs = []), l = pg(Qs, l, r), r = bt, (le === null ? r.memoizedState : le.next) === null && (r = r.alternate, E.H = r === null || r.memoizedState === null ? n0 : l0), l;
  }
  function Xo(l) {
    if (l !== null && typeof l == "object") {
      if (typeof l.then == "function") return Xr(l);
      if (l.$$typeof === G) return Re(l);
    }
    throw Error(i(438, String(l)));
  }
  function ih(l) {
    var r = null, c = bt.updateQueue;
    if (c !== null && (r = c.memoCache), r == null) {
      var f = bt.alternate;
      f !== null && (f = f.updateQueue, f !== null && (f = f.memoCache, f != null && (r = {
        data: f.data.map(function(O) {
          return O.slice();
        }),
        index: 0
      })));
    }
    if (r == null && (r = { data: [], index: 0 }), c === null && (c = eh(), bt.updateQueue = c), c.memoCache = r, c = r.data[r.index], c === void 0)
      for (c = r.data[r.index] = Array(l), f = 0; f < l; f++)
        c[f] = I;
    return r.index++, c;
  }
  function un(l, r) {
    return typeof r == "function" ? r(l) : r;
  }
  function _o(l) {
    var r = se();
    return nh(r, Xt, l);
  }
  function nh(l, r, c) {
    var f = l.queue;
    if (f === null) throw Error(i(311));
    f.lastRenderedReducer = c;
    var O = l.baseQueue, m = f.pending;
    if (m !== null) {
      if (O !== null) {
        var S = O.next;
        O.next = m.next, m.next = S;
      }
      r.baseQueue = O = m, f.pending = null;
    }
    if (m = l.baseState, O === null) l.memoizedState = m;
    else {
      r = O.next;
      var v = S = null, k = null, C = r, D = !1;
      do {
        var B = C.lane & -536870913;
        if (B !== C.lane ? (Pt & B) === B : (zn & B) === B) {
          var Z = C.revertLane;
          if (Z === 0)
            k !== null && (k = k.next = {
              lane: 0,
              revertLane: 0,
              action: C.action,
              hasEagerState: C.hasEagerState,
              eagerState: C.eagerState,
              next: null
            }), B === ms && (D = !0);
          else if ((zn & Z) === Z) {
            C = C.next, Z === ms && (D = !0);
            continue;
          } else
            B = {
              lane: 0,
              revertLane: C.revertLane,
              action: C.action,
              hasEagerState: C.hasEagerState,
              eagerState: C.eagerState,
              next: null
            }, k === null ? (v = k = B, S = m) : k = k.next = B, bt.lanes |= Z, Bn |= Z;
          B = C.action, Rl && c(m, B), m = C.hasEagerState ? C.eagerState : c(m, B);
        } else
          Z = {
            lane: B,
            revertLane: C.revertLane,
            action: C.action,
            hasEagerState: C.hasEagerState,
            eagerState: C.eagerState,
            next: null
          }, k === null ? (v = k = Z, S = m) : k = k.next = Z, bt.lanes |= B, Bn |= B;
        C = C.next;
      } while (C !== null && C !== r);
      if (k === null ? S = m : k.next = v, !Je(m, l.memoizedState) && (pe = !0, D && (c = gs, c !== null)))
        throw c;
      l.memoizedState = m, l.baseState = S, l.baseQueue = k, f.lastRenderedState = m;
    }
    return O === null && (f.lanes = 0), [l.memoizedState, f.dispatch];
  }
  function lh(l) {
    var r = se(), c = r.queue;
    if (c === null) throw Error(i(311));
    c.lastRenderedReducer = l;
    var f = c.dispatch, O = c.pending, m = r.memoizedState;
    if (O !== null) {
      c.pending = null;
      var S = O = O.next;
      do
        m = l(m, S.action), S = S.next;
      while (S !== O);
      Je(m, r.memoizedState) || (pe = !0), r.memoizedState = m, r.baseQueue === null && (r.baseState = m), c.lastRenderedState = m;
    }
    return [m, f];
  }
  function xg(l, r, c) {
    var f = bt, O = se(), m = Ct;
    if (m) {
      if (c === void 0) throw Error(i(407));
      c = c();
    } else c = r();
    var S = !Je(
      (Xt || O).memoizedState,
      c
    );
    S && (O.memoizedState = c, pe = !0), O = O.queue;
    var v = Tg.bind(null, f, O, l);
    if (_r(2048, 8, v, [l]), O.getSnapshot !== r || S || le !== null && le.memoizedState.tag & 1) {
      if (f.flags |= 2048, vs(
        9,
        zo(),
        wg.bind(
          null,
          f,
          O,
          c,
          r
        ),
        null
      ), jt === null) throw Error(i(349));
      m || (zn & 124) !== 0 || kg(f, r, c);
    }
    return c;
  }
  function kg(l, r, c) {
    l.flags |= 16384, l = { getSnapshot: r, value: c }, r = bt.updateQueue, r === null ? (r = eh(), bt.updateQueue = r, r.stores = [l]) : (c = r.stores, c === null ? r.stores = [l] : c.push(l));
  }
  function wg(l, r, c, f) {
    r.value = c, r.getSnapshot = f, $g(r) && Pg(l);
  }
  function Tg(l, r, c) {
    return c(function() {
      $g(r) && Pg(l);
    });
  }
  function $g(l) {
    var r = l.getSnapshot;
    l = l.value;
    try {
      var c = r();
      return !Je(l, c);
    } catch {
      return !0;
    }
  }
  function Pg(l) {
    var r = hs(l, 2);
    r !== null && ni(r, l, 2);
  }
  function sh(l) {
    var r = De();
    if (typeof l == "function") {
      var c = l;
      if (l = c(), Rl) {
        Mn(!0);
        try {
          c();
        } finally {
          Mn(!1);
        }
      }
    }
    return r.memoizedState = r.baseState = l, r.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: un,
      lastRenderedState: l
    }, r;
  }
  function Rg(l, r, c, f) {
    return l.baseState = c, nh(
      l,
      Xt,
      typeof f == "function" ? f : un
    );
  }
  function Bw(l, r, c, f, O) {
    if (Vo(l)) throw Error(i(485));
    if (l = r.action, l !== null) {
      var m = {
        payload: O,
        action: l,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function(S) {
          m.listeners.push(S);
        }
      };
      E.T !== null ? c(!0) : m.isTransition = !1, f(m), c = r.pending, c === null ? (m.next = r.pending = m, Ag(r, m)) : (m.next = c.next, r.pending = c.next = m);
    }
  }
  function Ag(l, r) {
    var c = r.action, f = r.payload, O = l.state;
    if (r.isTransition) {
      var m = E.T, S = {};
      E.T = S;
      try {
        var v = c(O, f), k = E.S;
        k !== null && k(S, v), Mg(l, r, v);
      } catch (C) {
        rh(l, r, C);
      } finally {
        E.T = m;
      }
    } else
      try {
        m = c(O, f), Mg(l, r, m);
      } catch (C) {
        rh(l, r, C);
      }
  }
  function Mg(l, r, c) {
    c !== null && typeof c == "object" && typeof c.then == "function" ? c.then(
      function(f) {
        qg(l, r, f);
      },
      function(f) {
        return rh(l, r, f);
      }
    ) : qg(l, r, c);
  }
  function qg(l, r, c) {
    r.status = "fulfilled", r.value = c, Cg(r), l.state = c, r = l.pending, r !== null && (c = r.next, c === r ? l.pending = null : (c = c.next, r.next = c, Ag(l, c)));
  }
  function rh(l, r, c) {
    var f = l.pending;
    if (l.pending = null, f !== null) {
      f = f.next;
      do
        r.status = "rejected", r.reason = c, Cg(r), r = r.next;
      while (r !== f);
    }
    l.action = null;
  }
  function Cg(l) {
    l = l.listeners;
    for (var r = 0; r < l.length; r++) (0, l[r])();
  }
  function Zg(l, r) {
    return r;
  }
  function Eg(l, r) {
    if (Ct) {
      var c = jt.formState;
      if (c !== null) {
        t: {
          var f = bt;
          if (Ct) {
            if (Jt) {
              e: {
                for (var O = Jt, m = qi; O.nodeType !== 8; ) {
                  if (!m) {
                    O = null;
                    break e;
                  }
                  if (O = Ti(
                    O.nextSibling
                  ), O === null) {
                    O = null;
                    break e;
                  }
                }
                m = O.data, O = m === "F!" || m === "F" ? O : null;
              }
              if (O) {
                Jt = Ti(
                  O.nextSibling
                ), f = O.data === "F!";
                break t;
              }
            }
            wl(f);
          }
          f = !1;
        }
        f && (r = c[0]);
      }
    }
    return c = De(), c.memoizedState = c.baseState = r, f = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Zg,
      lastRenderedState: r
    }, c.queue = f, c = t0.bind(
      null,
      bt,
      f
    ), f.dispatch = c, f = sh(!1), m = fh.bind(
      null,
      bt,
      !1,
      f.queue
    ), f = De(), O = {
      state: r,
      dispatch: null,
      action: l,
      pending: null
    }, f.queue = O, c = Bw.bind(
      null,
      bt,
      O,
      m,
      c
    ), O.dispatch = c, f.memoizedState = l, [r, c, !1];
  }
  function Xg(l) {
    var r = se();
    return _g(r, Xt, l);
  }
  function _g(l, r, c) {
    if (r = nh(
      l,
      r,
      Zg
    )[0], l = _o(un)[0], typeof r == "object" && r !== null && typeof r.then == "function")
      try {
        var f = Xr(r);
      } catch (S) {
        throw S === Ar ? Mo : S;
      }
    else f = r;
    r = se();
    var O = r.queue, m = O.dispatch;
    return c !== r.memoizedState && (bt.flags |= 2048, vs(
      9,
      zo(),
      Gw.bind(null, O, c),
      null
    )), [f, m, l];
  }
  function Gw(l, r) {
    l.action = r;
  }
  function zg(l) {
    var r = se(), c = Xt;
    if (c !== null)
      return _g(r, c, l);
    se(), r = r.memoizedState, c = se();
    var f = c.queue.dispatch;
    return c.memoizedState = l, [r, f, !1];
  }
  function vs(l, r, c, f) {
    return l = { tag: l, create: c, deps: f, inst: r, next: null }, r = bt.updateQueue, r === null && (r = eh(), bt.updateQueue = r), c = r.lastEffect, c === null ? r.lastEffect = l.next = l : (f = c.next, c.next = l, l.next = f, r.lastEffect = l), l;
  }
  function zo() {
    return { destroy: void 0, resource: void 0 };
  }
  function Dg() {
    return se().memoizedState;
  }
  function Do(l, r, c, f) {
    var O = De();
    f = f === void 0 ? null : f, bt.flags |= l, O.memoizedState = vs(
      1 | r,
      zo(),
      c,
      f
    );
  }
  function _r(l, r, c, f) {
    var O = se();
    f = f === void 0 ? null : f;
    var m = O.memoizedState.inst;
    Xt !== null && f !== null && Kf(f, Xt.memoizedState.deps) ? O.memoizedState = vs(r, m, c, f) : (bt.flags |= l, O.memoizedState = vs(
      1 | r,
      m,
      c,
      f
    ));
  }
  function Vg(l, r) {
    Do(8390656, 8, l, r);
  }
  function Yg(l, r) {
    _r(2048, 8, l, r);
  }
  function Ug(l, r) {
    return _r(4, 2, l, r);
  }
  function jg(l, r) {
    return _r(4, 4, l, r);
  }
  function Lg(l, r) {
    if (typeof r == "function") {
      l = l();
      var c = r(l);
      return function() {
        typeof c == "function" ? c() : r(null);
      };
    }
    if (r != null)
      return l = l(), r.current = l, function() {
        r.current = null;
      };
  }
  function Bg(l, r, c) {
    c = c != null ? c.concat([l]) : null, _r(4, 4, Lg.bind(null, r, l), c);
  }
  function ah() {
  }
  function Gg(l, r) {
    var c = se();
    r = r === void 0 ? null : r;
    var f = c.memoizedState;
    return r !== null && Kf(r, f[1]) ? f[0] : (c.memoizedState = [l, r], l);
  }
  function Ng(l, r) {
    var c = se();
    r = r === void 0 ? null : r;
    var f = c.memoizedState;
    if (r !== null && Kf(r, f[1]))
      return f[0];
    if (f = l(), Rl) {
      Mn(!0);
      try {
        l();
      } finally {
        Mn(!1);
      }
    }
    return c.memoizedState = [f, r], f;
  }
  function oh(l, r, c) {
    return c === void 0 || (zn & 1073741824) !== 0 ? l.memoizedState = r : (l.memoizedState = c, l = K0(), bt.lanes |= l, Bn |= l, c);
  }
  function Wg(l, r, c, f) {
    return Je(c, r) ? c : ys.current !== null ? (l = oh(l, c, f), Je(l, r) || (pe = !0), l) : (zn & 42) === 0 ? (pe = !0, l.memoizedState = c) : (l = K0(), bt.lanes |= l, Bn |= l, r);
  }
  function Hg(l, r, c, f, O) {
    var m = z.p;
    z.p = m !== 0 && 8 > m ? m : 8;
    var S = E.T, v = {};
    E.T = v, fh(l, !1, r, c);
    try {
      var k = O(), C = E.S;
      if (C !== null && C(v, k), k !== null && typeof k == "object" && typeof k.then == "function") {
        var D = Uw(
          k,
          f
        );
        zr(
          l,
          r,
          D,
          ii(l)
        );
      } else
        zr(
          l,
          r,
          f,
          ii(l)
        );
    } catch (B) {
      zr(
        l,
        r,
        { then: function() {
        }, status: "rejected", reason: B },
        ii()
      );
    } finally {
      z.p = m, E.T = S;
    }
  }
  function Nw() {
  }
  function ch(l, r, c, f) {
    if (l.tag !== 5) throw Error(i(476));
    var O = Kg(l).queue;
    Hg(
      l,
      O,
      r,
      nt,
      c === null ? Nw : function() {
        return Jg(l), c(f);
      }
    );
  }
  function Kg(l) {
    var r = l.memoizedState;
    if (r !== null) return r;
    r = {
      memoizedState: nt,
      baseState: nt,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: un,
        lastRenderedState: nt
      },
      next: null
    };
    var c = {};
    return r.next = {
      memoizedState: c,
      baseState: c,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: un,
        lastRenderedState: c
      },
      next: null
    }, l.memoizedState = r, l = l.alternate, l !== null && (l.memoizedState = r), r;
  }
  function Jg(l) {
    var r = Kg(l).next.queue;
    zr(l, r, {}, ii());
  }
  function uh() {
    return Re(ia);
  }
  function Ig() {
    return se().memoizedState;
  }
  function Fg() {
    return se().memoizedState;
  }
  function Ww(l) {
    for (var r = l.return; r !== null; ) {
      switch (r.tag) {
        case 24:
        case 3:
          var c = ii();
          l = Xn(c);
          var f = _n(r, l, c);
          f !== null && (ni(f, r, c), qr(f, r, c)), r = { cache: Vf() }, l.payload = r;
          return;
      }
      r = r.return;
    }
  }
  function Hw(l, r, c) {
    var f = ii();
    c = {
      lane: f,
      revertLane: 0,
      action: c,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, Vo(l) ? e0(r, c) : (c = Af(l, r, c, f), c !== null && (ni(c, l, f), i0(c, r, f)));
  }
  function t0(l, r, c) {
    var f = ii();
    zr(l, r, c, f);
  }
  function zr(l, r, c, f) {
    var O = {
      lane: f,
      revertLane: 0,
      action: c,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    if (Vo(l)) e0(r, O);
    else {
      var m = l.alternate;
      if (l.lanes === 0 && (m === null || m.lanes === 0) && (m = r.lastRenderedReducer, m !== null))
        try {
          var S = r.lastRenderedState, v = m(S, c);
          if (O.hasEagerState = !0, O.eagerState = v, Je(v, S))
            return xo(l, r, O, 0), jt === null && bo(), !1;
        } catch {
        } finally {
        }
      if (c = Af(l, r, O, f), c !== null)
        return ni(c, l, f), i0(c, r, f), !0;
    }
    return !1;
  }
  function fh(l, r, c, f) {
    if (f = {
      lane: 2,
      revertLane: jh(),
      action: f,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, Vo(l)) {
      if (r) throw Error(i(479));
    } else
      r = Af(
        l,
        c,
        f,
        2
      ), r !== null && ni(r, l, 2);
  }
  function Vo(l) {
    var r = l.alternate;
    return l === bt || r !== null && r === bt;
  }
  function e0(l, r) {
    Ss = Zo = !0;
    var c = l.pending;
    c === null ? r.next = r : (r.next = c.next, c.next = r), l.pending = r;
  }
  function i0(l, r, c) {
    if ((c & 4194048) !== 0) {
      var f = r.lanes;
      f &= l.pendingLanes, c |= f, r.lanes = c, um(l, c);
    }
  }
  var Yo = {
    readContext: Re,
    use: Xo,
    useCallback: Ft,
    useContext: Ft,
    useEffect: Ft,
    useImperativeHandle: Ft,
    useLayoutEffect: Ft,
    useInsertionEffect: Ft,
    useMemo: Ft,
    useReducer: Ft,
    useRef: Ft,
    useState: Ft,
    useDebugValue: Ft,
    useDeferredValue: Ft,
    useTransition: Ft,
    useSyncExternalStore: Ft,
    useId: Ft,
    useHostTransitionStatus: Ft,
    useFormState: Ft,
    useActionState: Ft,
    useOptimistic: Ft,
    useMemoCache: Ft,
    useCacheRefresh: Ft
  }, n0 = {
    readContext: Re,
    use: Xo,
    useCallback: function(l, r) {
      return De().memoizedState = [
        l,
        r === void 0 ? null : r
      ], l;
    },
    useContext: Re,
    useEffect: Vg,
    useImperativeHandle: function(l, r, c) {
      c = c != null ? c.concat([l]) : null, Do(
        4194308,
        4,
        Lg.bind(null, r, l),
        c
      );
    },
    useLayoutEffect: function(l, r) {
      return Do(4194308, 4, l, r);
    },
    useInsertionEffect: function(l, r) {
      Do(4, 2, l, r);
    },
    useMemo: function(l, r) {
      var c = De();
      r = r === void 0 ? null : r;
      var f = l();
      if (Rl) {
        Mn(!0);
        try {
          l();
        } finally {
          Mn(!1);
        }
      }
      return c.memoizedState = [f, r], f;
    },
    useReducer: function(l, r, c) {
      var f = De();
      if (c !== void 0) {
        var O = c(r);
        if (Rl) {
          Mn(!0);
          try {
            c(r);
          } finally {
            Mn(!1);
          }
        }
      } else O = r;
      return f.memoizedState = f.baseState = O, l = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: l,
        lastRenderedState: O
      }, f.queue = l, l = l.dispatch = Hw.bind(
        null,
        bt,
        l
      ), [f.memoizedState, l];
    },
    useRef: function(l) {
      var r = De();
      return l = { current: l }, r.memoizedState = l;
    },
    useState: function(l) {
      l = sh(l);
      var r = l.queue, c = t0.bind(null, bt, r);
      return r.dispatch = c, [l.memoizedState, c];
    },
    useDebugValue: ah,
    useDeferredValue: function(l, r) {
      var c = De();
      return oh(c, l, r);
    },
    useTransition: function() {
      var l = sh(!1);
      return l = Hg.bind(
        null,
        bt,
        l.queue,
        !0,
        !1
      ), De().memoizedState = l, [!1, l];
    },
    useSyncExternalStore: function(l, r, c) {
      var f = bt, O = De();
      if (Ct) {
        if (c === void 0)
          throw Error(i(407));
        c = c();
      } else {
        if (c = r(), jt === null)
          throw Error(i(349));
        (Pt & 124) !== 0 || kg(f, r, c);
      }
      O.memoizedState = c;
      var m = { value: c, getSnapshot: r };
      return O.queue = m, Vg(Tg.bind(null, f, m, l), [
        l
      ]), f.flags |= 2048, vs(
        9,
        zo(),
        wg.bind(
          null,
          f,
          m,
          c,
          r
        ),
        null
      ), c;
    },
    useId: function() {
      var l = De(), r = jt.identifierPrefix;
      if (Ct) {
        var c = an, f = rn;
        c = (f & ~(1 << 32 - Ke(f) - 1)).toString(32) + c, r = "«" + r + "R" + c, c = Eo++, 0 < c && (r += "H" + c.toString(32)), r += "»";
      } else
        c = jw++, r = "«" + r + "r" + c.toString(32) + "»";
      return l.memoizedState = r;
    },
    useHostTransitionStatus: uh,
    useFormState: Eg,
    useActionState: Eg,
    useOptimistic: function(l) {
      var r = De();
      r.memoizedState = r.baseState = l;
      var c = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return r.queue = c, r = fh.bind(
        null,
        bt,
        !0,
        c
      ), c.dispatch = r, [l, r];
    },
    useMemoCache: ih,
    useCacheRefresh: function() {
      return De().memoizedState = Ww.bind(
        null,
        bt
      );
    }
  }, l0 = {
    readContext: Re,
    use: Xo,
    useCallback: Gg,
    useContext: Re,
    useEffect: Yg,
    useImperativeHandle: Bg,
    useInsertionEffect: Ug,
    useLayoutEffect: jg,
    useMemo: Ng,
    useReducer: _o,
    useRef: Dg,
    useState: function() {
      return _o(un);
    },
    useDebugValue: ah,
    useDeferredValue: function(l, r) {
      var c = se();
      return Wg(
        c,
        Xt.memoizedState,
        l,
        r
      );
    },
    useTransition: function() {
      var l = _o(un)[0], r = se().memoizedState;
      return [
        typeof l == "boolean" ? l : Xr(l),
        r
      ];
    },
    useSyncExternalStore: xg,
    useId: Ig,
    useHostTransitionStatus: uh,
    useFormState: Xg,
    useActionState: Xg,
    useOptimistic: function(l, r) {
      var c = se();
      return Rg(c, Xt, l, r);
    },
    useMemoCache: ih,
    useCacheRefresh: Fg
  }, Kw = {
    readContext: Re,
    use: Xo,
    useCallback: Gg,
    useContext: Re,
    useEffect: Yg,
    useImperativeHandle: Bg,
    useInsertionEffect: Ug,
    useLayoutEffect: jg,
    useMemo: Ng,
    useReducer: lh,
    useRef: Dg,
    useState: function() {
      return lh(un);
    },
    useDebugValue: ah,
    useDeferredValue: function(l, r) {
      var c = se();
      return Xt === null ? oh(c, l, r) : Wg(
        c,
        Xt.memoizedState,
        l,
        r
      );
    },
    useTransition: function() {
      var l = lh(un)[0], r = se().memoizedState;
      return [
        typeof l == "boolean" ? l : Xr(l),
        r
      ];
    },
    useSyncExternalStore: xg,
    useId: Ig,
    useHostTransitionStatus: uh,
    useFormState: zg,
    useActionState: zg,
    useOptimistic: function(l, r) {
      var c = se();
      return Xt !== null ? Rg(c, Xt, l, r) : (c.baseState = l, [l, c.queue.dispatch]);
    },
    useMemoCache: ih,
    useCacheRefresh: Fg
  }, bs = null, Dr = 0;
  function Uo(l) {
    var r = Dr;
    return Dr += 1, bs === null && (bs = []), pg(bs, l, r);
  }
  function Vr(l, r) {
    r = r.props.ref, l.ref = r !== void 0 ? r : null;
  }
  function jo(l, r) {
    throw r.$$typeof === g ? Error(i(525)) : (l = Object.prototype.toString.call(r), Error(
      i(
        31,
        l === "[object Object]" ? "object with keys {" + Object.keys(r).join(", ") + "}" : l
      )
    ));
  }
  function s0(l) {
    var r = l._init;
    return r(l._payload);
  }
  function r0(l) {
    function r(R, $) {
      if (l) {
        var M = R.deletions;
        M === null ? (R.deletions = [$], R.flags |= 16) : M.push($);
      }
    }
    function c(R, $) {
      if (!l) return null;
      for (; $ !== null; )
        r(R, $), $ = $.sibling;
      return null;
    }
    function f(R) {
      for (var $ = /* @__PURE__ */ new Map(); R !== null; )
        R.key !== null ? $.set(R.key, R) : $.set(R.index, R), R = R.sibling;
      return $;
    }
    function O(R, $) {
      return R = sn(R, $), R.index = 0, R.sibling = null, R;
    }
    function m(R, $, M) {
      return R.index = M, l ? (M = R.alternate, M !== null ? (M = M.index, M < $ ? (R.flags |= 67108866, $) : M) : (R.flags |= 67108866, $)) : (R.flags |= 1048576, $);
    }
    function S(R) {
      return l && R.alternate === null && (R.flags |= 67108866), R;
    }
    function v(R, $, M, U) {
      return $ === null || $.tag !== 6 ? ($ = qf(M, R.mode, U), $.return = R, $) : ($ = O($, M), $.return = R, $);
    }
    function k(R, $, M, U) {
      var rt = M.type;
      return rt === b ? D(
        R,
        $,
        M.props.children,
        U,
        M.key
      ) : $ !== null && ($.elementType === rt || typeof rt == "object" && rt !== null && rt.$$typeof === J && s0(rt) === $.type) ? ($ = O($, M.props), Vr($, M), $.return = R, $) : ($ = wo(
        M.type,
        M.key,
        M.props,
        null,
        R.mode,
        U
      ), Vr($, M), $.return = R, $);
    }
    function C(R, $, M, U) {
      return $ === null || $.tag !== 4 || $.stateNode.containerInfo !== M.containerInfo || $.stateNode.implementation !== M.implementation ? ($ = Cf(M, R.mode, U), $.return = R, $) : ($ = O($, M.children || []), $.return = R, $);
    }
    function D(R, $, M, U, rt) {
      return $ === null || $.tag !== 7 ? ($ = vl(
        M,
        R.mode,
        U,
        rt
      ), $.return = R, $) : ($ = O($, M), $.return = R, $);
    }
    function B(R, $, M) {
      if (typeof $ == "string" && $ !== "" || typeof $ == "number" || typeof $ == "bigint")
        return $ = qf(
          "" + $,
          R.mode,
          M
        ), $.return = R, $;
      if (typeof $ == "object" && $ !== null) {
        switch ($.$$typeof) {
          case y:
            return M = wo(
              $.type,
              $.key,
              $.props,
              null,
              R.mode,
              M
            ), Vr(M, $), M.return = R, M;
          case Q:
            return $ = Cf(
              $,
              R.mode,
              M
            ), $.return = R, $;
          case J:
            var U = $._init;
            return $ = U($._payload), B(R, $, M);
        }
        if (ht($) || Y($))
          return $ = vl(
            $,
            R.mode,
            M,
            null
          ), $.return = R, $;
        if (typeof $.then == "function")
          return B(R, Uo($), M);
        if ($.$$typeof === G)
          return B(
            R,
            Ro(R, $),
            M
          );
        jo(R, $);
      }
      return null;
    }
    function Z(R, $, M, U) {
      var rt = $ !== null ? $.key : null;
      if (typeof M == "string" && M !== "" || typeof M == "number" || typeof M == "bigint")
        return rt !== null ? null : v(R, $, "" + M, U);
      if (typeof M == "object" && M !== null) {
        switch (M.$$typeof) {
          case y:
            return M.key === rt ? k(R, $, M, U) : null;
          case Q:
            return M.key === rt ? C(R, $, M, U) : null;
          case J:
            return rt = M._init, M = rt(M._payload), Z(R, $, M, U);
        }
        if (ht(M) || Y(M))
          return rt !== null ? null : D(R, $, M, U, null);
        if (typeof M.then == "function")
          return Z(
            R,
            $,
            Uo(M),
            U
          );
        if (M.$$typeof === G)
          return Z(
            R,
            $,
            Ro(R, M),
            U
          );
        jo(R, M);
      }
      return null;
    }
    function X(R, $, M, U, rt) {
      if (typeof U == "string" && U !== "" || typeof U == "number" || typeof U == "bigint")
        return R = R.get(M) || null, v($, R, "" + U, rt);
      if (typeof U == "object" && U !== null) {
        switch (U.$$typeof) {
          case y:
            return R = R.get(
              U.key === null ? M : U.key
            ) || null, k($, R, U, rt);
          case Q:
            return R = R.get(
              U.key === null ? M : U.key
            ) || null, C($, R, U, rt);
          case J:
            var xt = U._init;
            return U = xt(U._payload), X(
              R,
              $,
              M,
              U,
              rt
            );
        }
        if (ht(U) || Y(U))
          return R = R.get(M) || null, D($, R, U, rt, null);
        if (typeof U.then == "function")
          return X(
            R,
            $,
            M,
            Uo(U),
            rt
          );
        if (U.$$typeof === G)
          return X(
            R,
            $,
            M,
            Ro($, U),
            rt
          );
        jo($, U);
      }
      return null;
    }
    function gt(R, $, M, U) {
      for (var rt = null, xt = null, ut = $, pt = $ = 0, ge = null; ut !== null && pt < M.length; pt++) {
        ut.index > pt ? (ge = ut, ut = null) : ge = ut.sibling;
        var qt = Z(
          R,
          ut,
          M[pt],
          U
        );
        if (qt === null) {
          ut === null && (ut = ge);
          break;
        }
        l && ut && qt.alternate === null && r(R, ut), $ = m(qt, $, pt), xt === null ? rt = qt : xt.sibling = qt, xt = qt, ut = ge;
      }
      if (pt === M.length)
        return c(R, ut), Ct && xl(R, pt), rt;
      if (ut === null) {
        for (; pt < M.length; pt++)
          ut = B(R, M[pt], U), ut !== null && ($ = m(
            ut,
            $,
            pt
          ), xt === null ? rt = ut : xt.sibling = ut, xt = ut);
        return Ct && xl(R, pt), rt;
      }
      for (ut = f(ut); pt < M.length; pt++)
        ge = X(
          ut,
          R,
          pt,
          M[pt],
          U
        ), ge !== null && (l && ge.alternate !== null && ut.delete(
          ge.key === null ? pt : ge.key
        ), $ = m(
          ge,
          $,
          pt
        ), xt === null ? rt = ge : xt.sibling = ge, xt = ge);
      return l && ut.forEach(function(tl) {
        return r(R, tl);
      }), Ct && xl(R, pt), rt;
    }
    function dt(R, $, M, U) {
      if (M == null) throw Error(i(151));
      for (var rt = null, xt = null, ut = $, pt = $ = 0, ge = null, qt = M.next(); ut !== null && !qt.done; pt++, qt = M.next()) {
        ut.index > pt ? (ge = ut, ut = null) : ge = ut.sibling;
        var tl = Z(R, ut, qt.value, U);
        if (tl === null) {
          ut === null && (ut = ge);
          break;
        }
        l && ut && tl.alternate === null && r(R, ut), $ = m(tl, $, pt), xt === null ? rt = tl : xt.sibling = tl, xt = tl, ut = ge;
      }
      if (qt.done)
        return c(R, ut), Ct && xl(R, pt), rt;
      if (ut === null) {
        for (; !qt.done; pt++, qt = M.next())
          qt = B(R, qt.value, U), qt !== null && ($ = m(qt, $, pt), xt === null ? rt = qt : xt.sibling = qt, xt = qt);
        return Ct && xl(R, pt), rt;
      }
      for (ut = f(ut); !qt.done; pt++, qt = M.next())
        qt = X(ut, R, pt, qt.value, U), qt !== null && (l && qt.alternate !== null && ut.delete(qt.key === null ? pt : qt.key), $ = m(qt, $, pt), xt === null ? rt = qt : xt.sibling = qt, xt = qt);
      return l && ut.forEach(function(JT) {
        return r(R, JT);
      }), Ct && xl(R, pt), rt;
    }
    function zt(R, $, M, U) {
      if (typeof M == "object" && M !== null && M.type === b && M.key === null && (M = M.props.children), typeof M == "object" && M !== null) {
        switch (M.$$typeof) {
          case y:
            t: {
              for (var rt = M.key; $ !== null; ) {
                if ($.key === rt) {
                  if (rt = M.type, rt === b) {
                    if ($.tag === 7) {
                      c(
                        R,
                        $.sibling
                      ), U = O(
                        $,
                        M.props.children
                      ), U.return = R, R = U;
                      break t;
                    }
                  } else if ($.elementType === rt || typeof rt == "object" && rt !== null && rt.$$typeof === J && s0(rt) === $.type) {
                    c(
                      R,
                      $.sibling
                    ), U = O($, M.props), Vr(U, M), U.return = R, R = U;
                    break t;
                  }
                  c(R, $);
                  break;
                } else r(R, $);
                $ = $.sibling;
              }
              M.type === b ? (U = vl(
                M.props.children,
                R.mode,
                U,
                M.key
              ), U.return = R, R = U) : (U = wo(
                M.type,
                M.key,
                M.props,
                null,
                R.mode,
                U
              ), Vr(U, M), U.return = R, R = U);
            }
            return S(R);
          case Q:
            t: {
              for (rt = M.key; $ !== null; ) {
                if ($.key === rt)
                  if ($.tag === 4 && $.stateNode.containerInfo === M.containerInfo && $.stateNode.implementation === M.implementation) {
                    c(
                      R,
                      $.sibling
                    ), U = O($, M.children || []), U.return = R, R = U;
                    break t;
                  } else {
                    c(R, $);
                    break;
                  }
                else r(R, $);
                $ = $.sibling;
              }
              U = Cf(M, R.mode, U), U.return = R, R = U;
            }
            return S(R);
          case J:
            return rt = M._init, M = rt(M._payload), zt(
              R,
              $,
              M,
              U
            );
        }
        if (ht(M))
          return gt(
            R,
            $,
            M,
            U
          );
        if (Y(M)) {
          if (rt = Y(M), typeof rt != "function") throw Error(i(150));
          return M = rt.call(M), dt(
            R,
            $,
            M,
            U
          );
        }
        if (typeof M.then == "function")
          return zt(
            R,
            $,
            Uo(M),
            U
          );
        if (M.$$typeof === G)
          return zt(
            R,
            $,
            Ro(R, M),
            U
          );
        jo(R, M);
      }
      return typeof M == "string" && M !== "" || typeof M == "number" || typeof M == "bigint" ? (M = "" + M, $ !== null && $.tag === 6 ? (c(R, $.sibling), U = O($, M), U.return = R, R = U) : (c(R, $), U = qf(M, R.mode, U), U.return = R, R = U), S(R)) : c(R, $);
    }
    return function(R, $, M, U) {
      try {
        Dr = 0;
        var rt = zt(
          R,
          $,
          M,
          U
        );
        return bs = null, rt;
      } catch (ut) {
        if (ut === Ar || ut === Mo) throw ut;
        var xt = Ie(29, ut, null, R.mode);
        return xt.lanes = U, xt.return = R, xt;
      } finally {
      }
    };
  }
  var xs = r0(!0), a0 = r0(!1), pi = L(null), Ci = null;
  function Dn(l) {
    var r = l.alternate;
    F(he, he.current & 1), F(pi, l), Ci === null && (r === null || ys.current !== null || r.memoizedState !== null) && (Ci = l);
  }
  function o0(l) {
    if (l.tag === 22) {
      if (F(he, he.current), F(pi, l), Ci === null) {
        var r = l.alternate;
        r !== null && r.memoizedState !== null && (Ci = l);
      }
    } else Vn();
  }
  function Vn() {
    F(he, he.current), F(pi, pi.current);
  }
  function fn(l) {
    tt(pi), Ci === l && (Ci = null), tt(he);
  }
  var he = L(0);
  function Lo(l) {
    for (var r = l; r !== null; ) {
      if (r.tag === 13) {
        var c = r.memoizedState;
        if (c !== null && (c = c.dehydrated, c === null || c.data === "$?" || eO(c)))
          return r;
      } else if (r.tag === 19 && r.memoizedProps.revealOrder !== void 0) {
        if ((r.flags & 128) !== 0) return r;
      } else if (r.child !== null) {
        r.child.return = r, r = r.child;
        continue;
      }
      if (r === l) break;
      for (; r.sibling === null; ) {
        if (r.return === null || r.return === l) return null;
        r = r.return;
      }
      r.sibling.return = r.return, r = r.sibling;
    }
    return null;
  }
  function hh(l, r, c, f) {
    r = l.memoizedState, c = c(f, r), c = c == null ? r : p({}, r, c), l.memoizedState = c, l.lanes === 0 && (l.updateQueue.baseState = c);
  }
  var Oh = {
    enqueueSetState: function(l, r, c) {
      l = l._reactInternals;
      var f = ii(), O = Xn(f);
      O.payload = r, c != null && (O.callback = c), r = _n(l, O, f), r !== null && (ni(r, l, f), qr(r, l, f));
    },
    enqueueReplaceState: function(l, r, c) {
      l = l._reactInternals;
      var f = ii(), O = Xn(f);
      O.tag = 1, O.payload = r, c != null && (O.callback = c), r = _n(l, O, f), r !== null && (ni(r, l, f), qr(r, l, f));
    },
    enqueueForceUpdate: function(l, r) {
      l = l._reactInternals;
      var c = ii(), f = Xn(c);
      f.tag = 2, r != null && (f.callback = r), r = _n(l, f, c), r !== null && (ni(r, l, c), qr(r, l, c));
    }
  };
  function c0(l, r, c, f, O, m, S) {
    return l = l.stateNode, typeof l.shouldComponentUpdate == "function" ? l.shouldComponentUpdate(f, m, S) : r.prototype && r.prototype.isPureReactComponent ? !br(c, f) || !br(O, m) : !0;
  }
  function u0(l, r, c, f) {
    l = r.state, typeof r.componentWillReceiveProps == "function" && r.componentWillReceiveProps(c, f), typeof r.UNSAFE_componentWillReceiveProps == "function" && r.UNSAFE_componentWillReceiveProps(c, f), r.state !== l && Oh.enqueueReplaceState(r, r.state, null);
  }
  function Al(l, r) {
    var c = r;
    if ("ref" in r) {
      c = {};
      for (var f in r)
        f !== "ref" && (c[f] = r[f]);
    }
    if (l = l.defaultProps) {
      c === r && (c = p({}, c));
      for (var O in l)
        c[O] === void 0 && (c[O] = l[O]);
    }
    return c;
  }
  var Bo = typeof reportError == "function" ? reportError : function(l) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var r = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof l == "object" && l !== null && typeof l.message == "string" ? String(l.message) : String(l),
        error: l
      });
      if (!window.dispatchEvent(r)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", l);
      return;
    }
    console.error(l);
  };
  function f0(l) {
    Bo(l);
  }
  function h0(l) {
    console.error(l);
  }
  function O0(l) {
    Bo(l);
  }
  function Go(l, r) {
    try {
      var c = l.onUncaughtError;
      c(r.value, { componentStack: r.stack });
    } catch (f) {
      setTimeout(function() {
        throw f;
      });
    }
  }
  function d0(l, r, c) {
    try {
      var f = l.onCaughtError;
      f(c.value, {
        componentStack: c.stack,
        errorBoundary: r.tag === 1 ? r.stateNode : null
      });
    } catch (O) {
      setTimeout(function() {
        throw O;
      });
    }
  }
  function dh(l, r, c) {
    return c = Xn(c), c.tag = 3, c.payload = { element: null }, c.callback = function() {
      Go(l, r);
    }, c;
  }
  function p0(l) {
    return l = Xn(l), l.tag = 3, l;
  }
  function m0(l, r, c, f) {
    var O = c.type.getDerivedStateFromError;
    if (typeof O == "function") {
      var m = f.value;
      l.payload = function() {
        return O(m);
      }, l.callback = function() {
        d0(r, c, f);
      };
    }
    var S = c.stateNode;
    S !== null && typeof S.componentDidCatch == "function" && (l.callback = function() {
      d0(r, c, f), typeof O != "function" && (Gn === null ? Gn = /* @__PURE__ */ new Set([this]) : Gn.add(this));
      var v = f.stack;
      this.componentDidCatch(f.value, {
        componentStack: v !== null ? v : ""
      });
    });
  }
  function Jw(l, r, c, f, O) {
    if (c.flags |= 32768, f !== null && typeof f == "object" && typeof f.then == "function") {
      if (r = c.alternate, r !== null && $r(
        r,
        c,
        O,
        !0
      ), c = pi.current, c !== null) {
        switch (c.tag) {
          case 13:
            return Ci === null ? zh() : c.alternate === null && It === 0 && (It = 3), c.flags &= -257, c.flags |= 65536, c.lanes = O, f === jf ? c.flags |= 16384 : (r = c.updateQueue, r === null ? c.updateQueue = /* @__PURE__ */ new Set([f]) : r.add(f), Vh(l, f, O)), !1;
          case 22:
            return c.flags |= 65536, f === jf ? c.flags |= 16384 : (r = c.updateQueue, r === null ? (r = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([f])
            }, c.updateQueue = r) : (c = r.retryQueue, c === null ? r.retryQueue = /* @__PURE__ */ new Set([f]) : c.add(f)), Vh(l, f, O)), !1;
        }
        throw Error(i(435, c.tag));
      }
      return Vh(l, f, O), zh(), !1;
    }
    if (Ct)
      return r = pi.current, r !== null ? ((r.flags & 65536) === 0 && (r.flags |= 256), r.flags |= 65536, r.lanes = O, f !== Xf && (l = Error(i(422), { cause: f }), Tr(fi(l, c)))) : (f !== Xf && (r = Error(i(423), {
        cause: f
      }), Tr(
        fi(r, c)
      )), l = l.current.alternate, l.flags |= 65536, O &= -O, l.lanes |= O, f = fi(f, c), O = dh(
        l.stateNode,
        f,
        O
      ), Gf(l, O), It !== 4 && (It = 2)), !1;
    var m = Error(i(520), { cause: f });
    if (m = fi(m, c), Nr === null ? Nr = [m] : Nr.push(m), It !== 4 && (It = 2), r === null) return !0;
    f = fi(f, c), c = r;
    do {
      switch (c.tag) {
        case 3:
          return c.flags |= 65536, l = O & -O, c.lanes |= l, l = dh(c.stateNode, f, l), Gf(c, l), !1;
        case 1:
          if (r = c.type, m = c.stateNode, (c.flags & 128) === 0 && (typeof r.getDerivedStateFromError == "function" || m !== null && typeof m.componentDidCatch == "function" && (Gn === null || !Gn.has(m))))
            return c.flags |= 65536, O &= -O, c.lanes |= O, O = p0(O), m0(
              O,
              l,
              c,
              f
            ), Gf(c, O), !1;
      }
      c = c.return;
    } while (c !== null);
    return !1;
  }
  var g0 = Error(i(461)), pe = !1;
  function Qe(l, r, c, f) {
    r.child = l === null ? a0(r, null, c, f) : xs(
      r,
      l.child,
      c,
      f
    );
  }
  function y0(l, r, c, f, O) {
    c = c.render;
    var m = r.ref;
    if ("ref" in f) {
      var S = {};
      for (var v in f)
        v !== "ref" && (S[v] = f[v]);
    } else S = f;
    return $l(r), f = Jf(
      l,
      r,
      c,
      S,
      m,
      O
    ), v = If(), l !== null && !pe ? (Ff(l, r, O), hn(l, r, O)) : (Ct && v && Zf(r), r.flags |= 1, Qe(l, r, f, O), r.child);
  }
  function S0(l, r, c, f, O) {
    if (l === null) {
      var m = c.type;
      return typeof m == "function" && !Mf(m) && m.defaultProps === void 0 && c.compare === null ? (r.tag = 15, r.type = m, Q0(
        l,
        r,
        m,
        f,
        O
      )) : (l = wo(
        c.type,
        null,
        f,
        r,
        r.mode,
        O
      ), l.ref = r.ref, l.return = r, r.child = l);
    }
    if (m = l.child, !bh(l, O)) {
      var S = m.memoizedProps;
      if (c = c.compare, c = c !== null ? c : br, c(S, f) && l.ref === r.ref)
        return hn(l, r, O);
    }
    return r.flags |= 1, l = sn(m, f), l.ref = r.ref, l.return = r, r.child = l;
  }
  function Q0(l, r, c, f, O) {
    if (l !== null) {
      var m = l.memoizedProps;
      if (br(m, f) && l.ref === r.ref)
        if (pe = !1, r.pendingProps = f = m, bh(l, O))
          (l.flags & 131072) !== 0 && (pe = !0);
        else
          return r.lanes = l.lanes, hn(l, r, O);
    }
    return ph(
      l,
      r,
      c,
      f,
      O
    );
  }
  function v0(l, r, c) {
    var f = r.pendingProps, O = f.children, m = l !== null ? l.memoizedState : null;
    if (f.mode === "hidden") {
      if ((r.flags & 128) !== 0) {
        if (f = m !== null ? m.baseLanes | c : c, l !== null) {
          for (O = r.child = l.child, m = 0; O !== null; )
            m = m | O.lanes | O.childLanes, O = O.sibling;
          r.childLanes = m & ~f;
        } else r.childLanes = 0, r.child = null;
        return b0(
          l,
          r,
          f,
          c
        );
      }
      if ((c & 536870912) !== 0)
        r.memoizedState = { baseLanes: 0, cachePool: null }, l !== null && Ao(
          r,
          m !== null ? m.cachePool : null
        ), m !== null ? Qg(r, m) : Wf(), o0(r);
      else
        return r.lanes = r.childLanes = 536870912, b0(
          l,
          r,
          m !== null ? m.baseLanes | c : c,
          c
        );
    } else
      m !== null ? (Ao(r, m.cachePool), Qg(r, m), Vn(), r.memoizedState = null) : (l !== null && Ao(r, null), Wf(), Vn());
    return Qe(l, r, O, c), r.child;
  }
  function b0(l, r, c, f) {
    var O = Uf();
    return O = O === null ? null : { parent: fe._currentValue, pool: O }, r.memoizedState = {
      baseLanes: c,
      cachePool: O
    }, l !== null && Ao(r, null), Wf(), o0(r), l !== null && $r(l, r, f, !0), null;
  }
  function No(l, r) {
    var c = r.ref;
    if (c === null)
      l !== null && l.ref !== null && (r.flags |= 4194816);
    else {
      if (typeof c != "function" && typeof c != "object")
        throw Error(i(284));
      (l === null || l.ref !== c) && (r.flags |= 4194816);
    }
  }
  function ph(l, r, c, f, O) {
    return $l(r), c = Jf(
      l,
      r,
      c,
      f,
      void 0,
      O
    ), f = If(), l !== null && !pe ? (Ff(l, r, O), hn(l, r, O)) : (Ct && f && Zf(r), r.flags |= 1, Qe(l, r, c, O), r.child);
  }
  function x0(l, r, c, f, O, m) {
    return $l(r), r.updateQueue = null, c = bg(
      r,
      f,
      c,
      O
    ), vg(l), f = If(), l !== null && !pe ? (Ff(l, r, m), hn(l, r, m)) : (Ct && f && Zf(r), r.flags |= 1, Qe(l, r, c, m), r.child);
  }
  function k0(l, r, c, f, O) {
    if ($l(r), r.stateNode === null) {
      var m = Os, S = c.contextType;
      typeof S == "object" && S !== null && (m = Re(S)), m = new c(f, m), r.memoizedState = m.state !== null && m.state !== void 0 ? m.state : null, m.updater = Oh, r.stateNode = m, m._reactInternals = r, m = r.stateNode, m.props = f, m.state = r.memoizedState, m.refs = {}, Lf(r), S = c.contextType, m.context = typeof S == "object" && S !== null ? Re(S) : Os, m.state = r.memoizedState, S = c.getDerivedStateFromProps, typeof S == "function" && (hh(
        r,
        c,
        S,
        f
      ), m.state = r.memoizedState), typeof c.getDerivedStateFromProps == "function" || typeof m.getSnapshotBeforeUpdate == "function" || typeof m.UNSAFE_componentWillMount != "function" && typeof m.componentWillMount != "function" || (S = m.state, typeof m.componentWillMount == "function" && m.componentWillMount(), typeof m.UNSAFE_componentWillMount == "function" && m.UNSAFE_componentWillMount(), S !== m.state && Oh.enqueueReplaceState(m, m.state, null), Zr(r, f, m, O), Cr(), m.state = r.memoizedState), typeof m.componentDidMount == "function" && (r.flags |= 4194308), f = !0;
    } else if (l === null) {
      m = r.stateNode;
      var v = r.memoizedProps, k = Al(c, v);
      m.props = k;
      var C = m.context, D = c.contextType;
      S = Os, typeof D == "object" && D !== null && (S = Re(D));
      var B = c.getDerivedStateFromProps;
      D = typeof B == "function" || typeof m.getSnapshotBeforeUpdate == "function", v = r.pendingProps !== v, D || typeof m.UNSAFE_componentWillReceiveProps != "function" && typeof m.componentWillReceiveProps != "function" || (v || C !== S) && u0(
        r,
        m,
        f,
        S
      ), En = !1;
      var Z = r.memoizedState;
      m.state = Z, Zr(r, f, m, O), Cr(), C = r.memoizedState, v || Z !== C || En ? (typeof B == "function" && (hh(
        r,
        c,
        B,
        f
      ), C = r.memoizedState), (k = En || c0(
        r,
        c,
        k,
        f,
        Z,
        C,
        S
      )) ? (D || typeof m.UNSAFE_componentWillMount != "function" && typeof m.componentWillMount != "function" || (typeof m.componentWillMount == "function" && m.componentWillMount(), typeof m.UNSAFE_componentWillMount == "function" && m.UNSAFE_componentWillMount()), typeof m.componentDidMount == "function" && (r.flags |= 4194308)) : (typeof m.componentDidMount == "function" && (r.flags |= 4194308), r.memoizedProps = f, r.memoizedState = C), m.props = f, m.state = C, m.context = S, f = k) : (typeof m.componentDidMount == "function" && (r.flags |= 4194308), f = !1);
    } else {
      m = r.stateNode, Bf(l, r), S = r.memoizedProps, D = Al(c, S), m.props = D, B = r.pendingProps, Z = m.context, C = c.contextType, k = Os, typeof C == "object" && C !== null && (k = Re(C)), v = c.getDerivedStateFromProps, (C = typeof v == "function" || typeof m.getSnapshotBeforeUpdate == "function") || typeof m.UNSAFE_componentWillReceiveProps != "function" && typeof m.componentWillReceiveProps != "function" || (S !== B || Z !== k) && u0(
        r,
        m,
        f,
        k
      ), En = !1, Z = r.memoizedState, m.state = Z, Zr(r, f, m, O), Cr();
      var X = r.memoizedState;
      S !== B || Z !== X || En || l !== null && l.dependencies !== null && Po(l.dependencies) ? (typeof v == "function" && (hh(
        r,
        c,
        v,
        f
      ), X = r.memoizedState), (D = En || c0(
        r,
        c,
        D,
        f,
        Z,
        X,
        k
      ) || l !== null && l.dependencies !== null && Po(l.dependencies)) ? (C || typeof m.UNSAFE_componentWillUpdate != "function" && typeof m.componentWillUpdate != "function" || (typeof m.componentWillUpdate == "function" && m.componentWillUpdate(f, X, k), typeof m.UNSAFE_componentWillUpdate == "function" && m.UNSAFE_componentWillUpdate(
        f,
        X,
        k
      )), typeof m.componentDidUpdate == "function" && (r.flags |= 4), typeof m.getSnapshotBeforeUpdate == "function" && (r.flags |= 1024)) : (typeof m.componentDidUpdate != "function" || S === l.memoizedProps && Z === l.memoizedState || (r.flags |= 4), typeof m.getSnapshotBeforeUpdate != "function" || S === l.memoizedProps && Z === l.memoizedState || (r.flags |= 1024), r.memoizedProps = f, r.memoizedState = X), m.props = f, m.state = X, m.context = k, f = D) : (typeof m.componentDidUpdate != "function" || S === l.memoizedProps && Z === l.memoizedState || (r.flags |= 4), typeof m.getSnapshotBeforeUpdate != "function" || S === l.memoizedProps && Z === l.memoizedState || (r.flags |= 1024), f = !1);
    }
    return m = f, No(l, r), f = (r.flags & 128) !== 0, m || f ? (m = r.stateNode, c = f && typeof c.getDerivedStateFromError != "function" ? null : m.render(), r.flags |= 1, l !== null && f ? (r.child = xs(
      r,
      l.child,
      null,
      O
    ), r.child = xs(
      r,
      null,
      c,
      O
    )) : Qe(l, r, c, O), r.memoizedState = m.state, l = r.child) : l = hn(
      l,
      r,
      O
    ), l;
  }
  function w0(l, r, c, f) {
    return wr(), r.flags |= 256, Qe(l, r, c, f), r.child;
  }
  var mh = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  function gh(l) {
    return { baseLanes: l, cachePool: hg() };
  }
  function yh(l, r, c) {
    return l = l !== null ? l.childLanes & ~c : 0, r && (l |= mi), l;
  }
  function T0(l, r, c) {
    var f = r.pendingProps, O = !1, m = (r.flags & 128) !== 0, S;
    if ((S = m) || (S = l !== null && l.memoizedState === null ? !1 : (he.current & 2) !== 0), S && (O = !0, r.flags &= -129), S = (r.flags & 32) !== 0, r.flags &= -33, l === null) {
      if (Ct) {
        if (O ? Dn(r) : Vn(), Ct) {
          var v = Jt, k;
          if (k = v) {
            t: {
              for (k = v, v = qi; k.nodeType !== 8; ) {
                if (!v) {
                  v = null;
                  break t;
                }
                if (k = Ti(
                  k.nextSibling
                ), k === null) {
                  v = null;
                  break t;
                }
              }
              v = k;
            }
            v !== null ? (r.memoizedState = {
              dehydrated: v,
              treeContext: bl !== null ? { id: rn, overflow: an } : null,
              retryLane: 536870912,
              hydrationErrors: null
            }, k = Ie(
              18,
              null,
              null,
              0
            ), k.stateNode = v, k.return = r, r.child = k, Ze = r, Jt = null, k = !0) : k = !1;
          }
          k || wl(r);
        }
        if (v = r.memoizedState, v !== null && (v = v.dehydrated, v !== null))
          return eO(v) ? r.lanes = 32 : r.lanes = 536870912, null;
        fn(r);
      }
      return v = f.children, f = f.fallback, O ? (Vn(), O = r.mode, v = Wo(
        { mode: "hidden", children: v },
        O
      ), f = vl(
        f,
        O,
        c,
        null
      ), v.return = r, f.return = r, v.sibling = f, r.child = v, O = r.child, O.memoizedState = gh(c), O.childLanes = yh(
        l,
        S,
        c
      ), r.memoizedState = mh, f) : (Dn(r), Sh(r, v));
    }
    if (k = l.memoizedState, k !== null && (v = k.dehydrated, v !== null)) {
      if (m)
        r.flags & 256 ? (Dn(r), r.flags &= -257, r = Qh(
          l,
          r,
          c
        )) : r.memoizedState !== null ? (Vn(), r.child = l.child, r.flags |= 128, r = null) : (Vn(), O = f.fallback, v = r.mode, f = Wo(
          { mode: "visible", children: f.children },
          v
        ), O = vl(
          O,
          v,
          c,
          null
        ), O.flags |= 2, f.return = r, O.return = r, f.sibling = O, r.child = f, xs(
          r,
          l.child,
          null,
          c
        ), f = r.child, f.memoizedState = gh(c), f.childLanes = yh(
          l,
          S,
          c
        ), r.memoizedState = mh, r = O);
      else if (Dn(r), eO(v)) {
        if (S = v.nextSibling && v.nextSibling.dataset, S) var C = S.dgst;
        S = C, f = Error(i(419)), f.stack = "", f.digest = S, Tr({ value: f, source: null, stack: null }), r = Qh(
          l,
          r,
          c
        );
      } else if (pe || $r(l, r, c, !1), S = (c & l.childLanes) !== 0, pe || S) {
        if (S = jt, S !== null && (f = c & -c, f = (f & 42) !== 0 ? 1 : ef(f), f = (f & (S.suspendedLanes | c)) !== 0 ? 0 : f, f !== 0 && f !== k.retryLane))
          throw k.retryLane = f, hs(l, f), ni(S, l, f), g0;
        v.data === "$?" || zh(), r = Qh(
          l,
          r,
          c
        );
      } else
        v.data === "$?" ? (r.flags |= 192, r.child = l.child, r = null) : (l = k.treeContext, Jt = Ti(
          v.nextSibling
        ), Ze = r, Ct = !0, kl = null, qi = !1, l !== null && (Oi[di++] = rn, Oi[di++] = an, Oi[di++] = bl, rn = l.id, an = l.overflow, bl = r), r = Sh(
          r,
          f.children
        ), r.flags |= 4096);
      return r;
    }
    return O ? (Vn(), O = f.fallback, v = r.mode, k = l.child, C = k.sibling, f = sn(k, {
      mode: "hidden",
      children: f.children
    }), f.subtreeFlags = k.subtreeFlags & 65011712, C !== null ? O = sn(C, O) : (O = vl(
      O,
      v,
      c,
      null
    ), O.flags |= 2), O.return = r, f.return = r, f.sibling = O, r.child = f, f = O, O = r.child, v = l.child.memoizedState, v === null ? v = gh(c) : (k = v.cachePool, k !== null ? (C = fe._currentValue, k = k.parent !== C ? { parent: C, pool: C } : k) : k = hg(), v = {
      baseLanes: v.baseLanes | c,
      cachePool: k
    }), O.memoizedState = v, O.childLanes = yh(
      l,
      S,
      c
    ), r.memoizedState = mh, f) : (Dn(r), c = l.child, l = c.sibling, c = sn(c, {
      mode: "visible",
      children: f.children
    }), c.return = r, c.sibling = null, l !== null && (S = r.deletions, S === null ? (r.deletions = [l], r.flags |= 16) : S.push(l)), r.child = c, r.memoizedState = null, c);
  }
  function Sh(l, r) {
    return r = Wo(
      { mode: "visible", children: r },
      l.mode
    ), r.return = l, l.child = r;
  }
  function Wo(l, r) {
    return l = Ie(22, l, null, r), l.lanes = 0, l.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }, l;
  }
  function Qh(l, r, c) {
    return xs(r, l.child, null, c), l = Sh(
      r,
      r.pendingProps.children
    ), l.flags |= 2, r.memoizedState = null, l;
  }
  function $0(l, r, c) {
    l.lanes |= r;
    var f = l.alternate;
    f !== null && (f.lanes |= r), zf(l.return, r, c);
  }
  function vh(l, r, c, f, O) {
    var m = l.memoizedState;
    m === null ? l.memoizedState = {
      isBackwards: r,
      rendering: null,
      renderingStartTime: 0,
      last: f,
      tail: c,
      tailMode: O
    } : (m.isBackwards = r, m.rendering = null, m.renderingStartTime = 0, m.last = f, m.tail = c, m.tailMode = O);
  }
  function P0(l, r, c) {
    var f = r.pendingProps, O = f.revealOrder, m = f.tail;
    if (Qe(l, r, f.children, c), f = he.current, (f & 2) !== 0)
      f = f & 1 | 2, r.flags |= 128;
    else {
      if (l !== null && (l.flags & 128) !== 0)
        t: for (l = r.child; l !== null; ) {
          if (l.tag === 13)
            l.memoizedState !== null && $0(l, c, r);
          else if (l.tag === 19)
            $0(l, c, r);
          else if (l.child !== null) {
            l.child.return = l, l = l.child;
            continue;
          }
          if (l === r) break t;
          for (; l.sibling === null; ) {
            if (l.return === null || l.return === r)
              break t;
            l = l.return;
          }
          l.sibling.return = l.return, l = l.sibling;
        }
      f &= 1;
    }
    switch (F(he, f), O) {
      case "forwards":
        for (c = r.child, O = null; c !== null; )
          l = c.alternate, l !== null && Lo(l) === null && (O = c), c = c.sibling;
        c = O, c === null ? (O = r.child, r.child = null) : (O = c.sibling, c.sibling = null), vh(
          r,
          !1,
          O,
          c,
          m
        );
        break;
      case "backwards":
        for (c = null, O = r.child, r.child = null; O !== null; ) {
          if (l = O.alternate, l !== null && Lo(l) === null) {
            r.child = O;
            break;
          }
          l = O.sibling, O.sibling = c, c = O, O = l;
        }
        vh(
          r,
          !0,
          c,
          null,
          m
        );
        break;
      case "together":
        vh(r, !1, null, null, void 0);
        break;
      default:
        r.memoizedState = null;
    }
    return r.child;
  }
  function hn(l, r, c) {
    if (l !== null && (r.dependencies = l.dependencies), Bn |= r.lanes, (c & r.childLanes) === 0)
      if (l !== null) {
        if ($r(
          l,
          r,
          c,
          !1
        ), (c & r.childLanes) === 0)
          return null;
      } else return null;
    if (l !== null && r.child !== l.child)
      throw Error(i(153));
    if (r.child !== null) {
      for (l = r.child, c = sn(l, l.pendingProps), r.child = c, c.return = r; l.sibling !== null; )
        l = l.sibling, c = c.sibling = sn(l, l.pendingProps), c.return = r;
      c.sibling = null;
    }
    return r.child;
  }
  function bh(l, r) {
    return (l.lanes & r) !== 0 ? !0 : (l = l.dependencies, !!(l !== null && Po(l)));
  }
  function Iw(l, r, c) {
    switch (r.tag) {
      case 3:
        Gt(r, r.stateNode.containerInfo), Zn(r, fe, l.memoizedState.cache), wr();
        break;
      case 27:
      case 5:
        Ku(r);
        break;
      case 4:
        Gt(r, r.stateNode.containerInfo);
        break;
      case 10:
        Zn(
          r,
          r.type,
          r.memoizedProps.value
        );
        break;
      case 13:
        var f = r.memoizedState;
        if (f !== null)
          return f.dehydrated !== null ? (Dn(r), r.flags |= 128, null) : (c & r.child.childLanes) !== 0 ? T0(l, r, c) : (Dn(r), l = hn(
            l,
            r,
            c
          ), l !== null ? l.sibling : null);
        Dn(r);
        break;
      case 19:
        var O = (l.flags & 128) !== 0;
        if (f = (c & r.childLanes) !== 0, f || ($r(
          l,
          r,
          c,
          !1
        ), f = (c & r.childLanes) !== 0), O) {
          if (f)
            return P0(
              l,
              r,
              c
            );
          r.flags |= 128;
        }
        if (O = r.memoizedState, O !== null && (O.rendering = null, O.tail = null, O.lastEffect = null), F(he, he.current), f) break;
        return null;
      case 22:
      case 23:
        return r.lanes = 0, v0(l, r, c);
      case 24:
        Zn(r, fe, l.memoizedState.cache);
    }
    return hn(l, r, c);
  }
  function R0(l, r, c) {
    if (l !== null)
      if (l.memoizedProps !== r.pendingProps)
        pe = !0;
      else {
        if (!bh(l, c) && (r.flags & 128) === 0)
          return pe = !1, Iw(
            l,
            r,
            c
          );
        pe = (l.flags & 131072) !== 0;
      }
    else
      pe = !1, Ct && (r.flags & 1048576) !== 0 && sg(r, $o, r.index);
    switch (r.lanes = 0, r.tag) {
      case 16:
        t: {
          l = r.pendingProps;
          var f = r.elementType, O = f._init;
          if (f = O(f._payload), r.type = f, typeof f == "function")
            Mf(f) ? (l = Al(f, l), r.tag = 1, r = k0(
              null,
              r,
              f,
              l,
              c
            )) : (r.tag = 0, r = ph(
              null,
              r,
              f,
              l,
              c
            ));
          else {
            if (f != null) {
              if (O = f.$$typeof, O === H) {
                r.tag = 11, r = y0(
                  null,
                  r,
                  f,
                  l,
                  c
                );
                break t;
              } else if (O === q) {
                r.tag = 14, r = S0(
                  null,
                  r,
                  f,
                  l,
                  c
                );
                break t;
              }
            }
            throw r = at(f) || f, Error(i(306, r, ""));
          }
        }
        return r;
      case 0:
        return ph(
          l,
          r,
          r.type,
          r.pendingProps,
          c
        );
      case 1:
        return f = r.type, O = Al(
          f,
          r.pendingProps
        ), k0(
          l,
          r,
          f,
          O,
          c
        );
      case 3:
        t: {
          if (Gt(
            r,
            r.stateNode.containerInfo
          ), l === null) throw Error(i(387));
          f = r.pendingProps;
          var m = r.memoizedState;
          O = m.element, Bf(l, r), Zr(r, f, null, c);
          var S = r.memoizedState;
          if (f = S.cache, Zn(r, fe, f), f !== m.cache && Df(
            r,
            [fe],
            c,
            !0
          ), Cr(), f = S.element, m.isDehydrated)
            if (m = {
              element: f,
              isDehydrated: !1,
              cache: S.cache
            }, r.updateQueue.baseState = m, r.memoizedState = m, r.flags & 256) {
              r = w0(
                l,
                r,
                f,
                c
              );
              break t;
            } else if (f !== O) {
              O = fi(
                Error(i(424)),
                r
              ), Tr(O), r = w0(
                l,
                r,
                f,
                c
              );
              break t;
            } else {
              switch (l = r.stateNode.containerInfo, l.nodeType) {
                case 9:
                  l = l.body;
                  break;
                default:
                  l = l.nodeName === "HTML" ? l.ownerDocument.body : l;
              }
              for (Jt = Ti(l.firstChild), Ze = r, Ct = !0, kl = null, qi = !0, c = a0(
                r,
                null,
                f,
                c
              ), r.child = c; c; )
                c.flags = c.flags & -3 | 4096, c = c.sibling;
            }
          else {
            if (wr(), f === O) {
              r = hn(
                l,
                r,
                c
              );
              break t;
            }
            Qe(
              l,
              r,
              f,
              c
            );
          }
          r = r.child;
        }
        return r;
      case 26:
        return No(l, r), l === null ? (c = Cy(
          r.type,
          null,
          r.pendingProps,
          null
        )) ? r.memoizedState = c : Ct || (c = r.type, l = r.pendingProps, f = oc(
          mt.current
        ).createElement(c), f[Pe] = r, f[_e] = l, be(f, c, l), de(f), r.stateNode = f) : r.memoizedState = Cy(
          r.type,
          l.memoizedProps,
          r.pendingProps,
          l.memoizedState
        ), null;
      case 27:
        return Ku(r), l === null && Ct && (f = r.stateNode = Ay(
          r.type,
          r.pendingProps,
          mt.current
        ), Ze = r, qi = !0, O = Jt, Hn(r.type) ? (iO = O, Jt = Ti(
          f.firstChild
        )) : Jt = O), Qe(
          l,
          r,
          r.pendingProps.children,
          c
        ), No(l, r), l === null && (r.flags |= 4194304), r.child;
      case 5:
        return l === null && Ct && ((O = f = Jt) && (f = TT(
          f,
          r.type,
          r.pendingProps,
          qi
        ), f !== null ? (r.stateNode = f, Ze = r, Jt = Ti(
          f.firstChild
        ), qi = !1, O = !0) : O = !1), O || wl(r)), Ku(r), O = r.type, m = r.pendingProps, S = l !== null ? l.memoizedProps : null, f = m.children, Ih(O, m) ? f = null : S !== null && Ih(O, S) && (r.flags |= 32), r.memoizedState !== null && (O = Jf(
          l,
          r,
          Lw,
          null,
          null,
          c
        ), ia._currentValue = O), No(l, r), Qe(l, r, f, c), r.child;
      case 6:
        return l === null && Ct && ((l = c = Jt) && (c = $T(
          c,
          r.pendingProps,
          qi
        ), c !== null ? (r.stateNode = c, Ze = r, Jt = null, l = !0) : l = !1), l || wl(r)), null;
      case 13:
        return T0(l, r, c);
      case 4:
        return Gt(
          r,
          r.stateNode.containerInfo
        ), f = r.pendingProps, l === null ? r.child = xs(
          r,
          null,
          f,
          c
        ) : Qe(
          l,
          r,
          f,
          c
        ), r.child;
      case 11:
        return y0(
          l,
          r,
          r.type,
          r.pendingProps,
          c
        );
      case 7:
        return Qe(
          l,
          r,
          r.pendingProps,
          c
        ), r.child;
      case 8:
        return Qe(
          l,
          r,
          r.pendingProps.children,
          c
        ), r.child;
      case 12:
        return Qe(
          l,
          r,
          r.pendingProps.children,
          c
        ), r.child;
      case 10:
        return f = r.pendingProps, Zn(r, r.type, f.value), Qe(
          l,
          r,
          f.children,
          c
        ), r.child;
      case 9:
        return O = r.type._context, f = r.pendingProps.children, $l(r), O = Re(O), f = f(O), r.flags |= 1, Qe(l, r, f, c), r.child;
      case 14:
        return S0(
          l,
          r,
          r.type,
          r.pendingProps,
          c
        );
      case 15:
        return Q0(
          l,
          r,
          r.type,
          r.pendingProps,
          c
        );
      case 19:
        return P0(l, r, c);
      case 31:
        return f = r.pendingProps, c = r.mode, f = {
          mode: f.mode,
          children: f.children
        }, l === null ? (c = Wo(
          f,
          c
        ), c.ref = r.ref, r.child = c, c.return = r, r = c) : (c = sn(l.child, f), c.ref = r.ref, r.child = c, c.return = r, r = c), r;
      case 22:
        return v0(l, r, c);
      case 24:
        return $l(r), f = Re(fe), l === null ? (O = Uf(), O === null && (O = jt, m = Vf(), O.pooledCache = m, m.refCount++, m !== null && (O.pooledCacheLanes |= c), O = m), r.memoizedState = {
          parent: f,
          cache: O
        }, Lf(r), Zn(r, fe, O)) : ((l.lanes & c) !== 0 && (Bf(l, r), Zr(r, null, null, c), Cr()), O = l.memoizedState, m = r.memoizedState, O.parent !== f ? (O = { parent: f, cache: f }, r.memoizedState = O, r.lanes === 0 && (r.memoizedState = r.updateQueue.baseState = O), Zn(r, fe, f)) : (f = m.cache, Zn(r, fe, f), f !== O.cache && Df(
          r,
          [fe],
          c,
          !0
        ))), Qe(
          l,
          r,
          r.pendingProps.children,
          c
        ), r.child;
      case 29:
        throw r.pendingProps;
    }
    throw Error(i(156, r.tag));
  }
  function On(l) {
    l.flags |= 4;
  }
  function A0(l, r) {
    if (r.type !== "stylesheet" || (r.state.loading & 4) !== 0)
      l.flags &= -16777217;
    else if (l.flags |= 16777216, !zy(r)) {
      if (r = pi.current, r !== null && ((Pt & 4194048) === Pt ? Ci !== null : (Pt & 62914560) !== Pt && (Pt & 536870912) === 0 || r !== Ci))
        throw Mr = jf, Og;
      l.flags |= 8192;
    }
  }
  function Ho(l, r) {
    r !== null && (l.flags |= 4), l.flags & 16384 && (r = l.tag !== 22 ? om() : 536870912, l.lanes |= r, $s |= r);
  }
  function Yr(l, r) {
    if (!Ct)
      switch (l.tailMode) {
        case "hidden":
          r = l.tail;
          for (var c = null; r !== null; )
            r.alternate !== null && (c = r), r = r.sibling;
          c === null ? l.tail = null : c.sibling = null;
          break;
        case "collapsed":
          c = l.tail;
          for (var f = null; c !== null; )
            c.alternate !== null && (f = c), c = c.sibling;
          f === null ? r || l.tail === null ? l.tail = null : l.tail.sibling = null : f.sibling = null;
      }
  }
  function Ht(l) {
    var r = l.alternate !== null && l.alternate.child === l.child, c = 0, f = 0;
    if (r)
      for (var O = l.child; O !== null; )
        c |= O.lanes | O.childLanes, f |= O.subtreeFlags & 65011712, f |= O.flags & 65011712, O.return = l, O = O.sibling;
    else
      for (O = l.child; O !== null; )
        c |= O.lanes | O.childLanes, f |= O.subtreeFlags, f |= O.flags, O.return = l, O = O.sibling;
    return l.subtreeFlags |= f, l.childLanes = c, r;
  }
  function Fw(l, r, c) {
    var f = r.pendingProps;
    switch (Ef(r), r.tag) {
      case 31:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Ht(r), null;
      case 1:
        return Ht(r), null;
      case 3:
        return c = r.stateNode, f = null, l !== null && (f = l.memoizedState.cache), r.memoizedState.cache !== f && (r.flags |= 2048), cn(fe), An(), c.pendingContext && (c.context = c.pendingContext, c.pendingContext = null), (l === null || l.child === null) && (kr(r) ? On(r) : l === null || l.memoizedState.isDehydrated && (r.flags & 256) === 0 || (r.flags |= 1024, og())), Ht(r), null;
      case 26:
        return c = r.memoizedState, l === null ? (On(r), c !== null ? (Ht(r), A0(r, c)) : (Ht(r), r.flags &= -16777217)) : c ? c !== l.memoizedState ? (On(r), Ht(r), A0(r, c)) : (Ht(r), r.flags &= -16777217) : (l.memoizedProps !== f && On(r), Ht(r), r.flags &= -16777217), null;
      case 27:
        so(r), c = mt.current;
        var O = r.type;
        if (l !== null && r.stateNode != null)
          l.memoizedProps !== f && On(r);
        else {
          if (!f) {
            if (r.stateNode === null)
              throw Error(i(166));
            return Ht(r), null;
          }
          l = ct.current, kr(r) ? rg(r) : (l = Ay(O, f, c), r.stateNode = l, On(r));
        }
        return Ht(r), null;
      case 5:
        if (so(r), c = r.type, l !== null && r.stateNode != null)
          l.memoizedProps !== f && On(r);
        else {
          if (!f) {
            if (r.stateNode === null)
              throw Error(i(166));
            return Ht(r), null;
          }
          if (l = ct.current, kr(r))
            rg(r);
          else {
            switch (O = oc(
              mt.current
            ), l) {
              case 1:
                l = O.createElementNS(
                  "http://www.w3.org/2000/svg",
                  c
                );
                break;
              case 2:
                l = O.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  c
                );
                break;
              default:
                switch (c) {
                  case "svg":
                    l = O.createElementNS(
                      "http://www.w3.org/2000/svg",
                      c
                    );
                    break;
                  case "math":
                    l = O.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      c
                    );
                    break;
                  case "script":
                    l = O.createElement("div"), l.innerHTML = "<script><\/script>", l = l.removeChild(l.firstChild);
                    break;
                  case "select":
                    l = typeof f.is == "string" ? O.createElement("select", { is: f.is }) : O.createElement("select"), f.multiple ? l.multiple = !0 : f.size && (l.size = f.size);
                    break;
                  default:
                    l = typeof f.is == "string" ? O.createElement(c, { is: f.is }) : O.createElement(c);
                }
            }
            l[Pe] = r, l[_e] = f;
            t: for (O = r.child; O !== null; ) {
              if (O.tag === 5 || O.tag === 6)
                l.appendChild(O.stateNode);
              else if (O.tag !== 4 && O.tag !== 27 && O.child !== null) {
                O.child.return = O, O = O.child;
                continue;
              }
              if (O === r) break t;
              for (; O.sibling === null; ) {
                if (O.return === null || O.return === r)
                  break t;
                O = O.return;
              }
              O.sibling.return = O.return, O = O.sibling;
            }
            r.stateNode = l;
            t: switch (be(l, c, f), c) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                l = !!f.autoFocus;
                break t;
              case "img":
                l = !0;
                break t;
              default:
                l = !1;
            }
            l && On(r);
          }
        }
        return Ht(r), r.flags &= -16777217, null;
      case 6:
        if (l && r.stateNode != null)
          l.memoizedProps !== f && On(r);
        else {
          if (typeof f != "string" && r.stateNode === null)
            throw Error(i(166));
          if (l = mt.current, kr(r)) {
            if (l = r.stateNode, c = r.memoizedProps, f = null, O = Ze, O !== null)
              switch (O.tag) {
                case 27:
                case 5:
                  f = O.memoizedProps;
              }
            l[Pe] = r, l = !!(l.nodeValue === c || f !== null && f.suppressHydrationWarning === !0 || xy(l.nodeValue, c)), l || wl(r);
          } else
            l = oc(l).createTextNode(
              f
            ), l[Pe] = r, r.stateNode = l;
        }
        return Ht(r), null;
      case 13:
        if (f = r.memoizedState, l === null || l.memoizedState !== null && l.memoizedState.dehydrated !== null) {
          if (O = kr(r), f !== null && f.dehydrated !== null) {
            if (l === null) {
              if (!O) throw Error(i(318));
              if (O = r.memoizedState, O = O !== null ? O.dehydrated : null, !O) throw Error(i(317));
              O[Pe] = r;
            } else
              wr(), (r.flags & 128) === 0 && (r.memoizedState = null), r.flags |= 4;
            Ht(r), O = !1;
          } else
            O = og(), l !== null && l.memoizedState !== null && (l.memoizedState.hydrationErrors = O), O = !0;
          if (!O)
            return r.flags & 256 ? (fn(r), r) : (fn(r), null);
        }
        if (fn(r), (r.flags & 128) !== 0)
          return r.lanes = c, r;
        if (c = f !== null, l = l !== null && l.memoizedState !== null, c) {
          f = r.child, O = null, f.alternate !== null && f.alternate.memoizedState !== null && f.alternate.memoizedState.cachePool !== null && (O = f.alternate.memoizedState.cachePool.pool);
          var m = null;
          f.memoizedState !== null && f.memoizedState.cachePool !== null && (m = f.memoizedState.cachePool.pool), m !== O && (f.flags |= 2048);
        }
        return c !== l && c && (r.child.flags |= 8192), Ho(r, r.updateQueue), Ht(r), null;
      case 4:
        return An(), l === null && Nh(r.stateNode.containerInfo), Ht(r), null;
      case 10:
        return cn(r.type), Ht(r), null;
      case 19:
        if (tt(he), O = r.memoizedState, O === null) return Ht(r), null;
        if (f = (r.flags & 128) !== 0, m = O.rendering, m === null)
          if (f) Yr(O, !1);
          else {
            if (It !== 0 || l !== null && (l.flags & 128) !== 0)
              for (l = r.child; l !== null; ) {
                if (m = Lo(l), m !== null) {
                  for (r.flags |= 128, Yr(O, !1), l = m.updateQueue, r.updateQueue = l, Ho(r, l), r.subtreeFlags = 0, l = c, c = r.child; c !== null; )
                    lg(c, l), c = c.sibling;
                  return F(
                    he,
                    he.current & 1 | 2
                  ), r.child;
                }
                l = l.sibling;
              }
            O.tail !== null && Mi() > Io && (r.flags |= 128, f = !0, Yr(O, !1), r.lanes = 4194304);
          }
        else {
          if (!f)
            if (l = Lo(m), l !== null) {
              if (r.flags |= 128, f = !0, l = l.updateQueue, r.updateQueue = l, Ho(r, l), Yr(O, !0), O.tail === null && O.tailMode === "hidden" && !m.alternate && !Ct)
                return Ht(r), null;
            } else
              2 * Mi() - O.renderingStartTime > Io && c !== 536870912 && (r.flags |= 128, f = !0, Yr(O, !1), r.lanes = 4194304);
          O.isBackwards ? (m.sibling = r.child, r.child = m) : (l = O.last, l !== null ? l.sibling = m : r.child = m, O.last = m);
        }
        return O.tail !== null ? (r = O.tail, O.rendering = r, O.tail = r.sibling, O.renderingStartTime = Mi(), r.sibling = null, l = he.current, F(he, f ? l & 1 | 2 : l & 1), r) : (Ht(r), null);
      case 22:
      case 23:
        return fn(r), Hf(), f = r.memoizedState !== null, l !== null ? l.memoizedState !== null !== f && (r.flags |= 8192) : f && (r.flags |= 8192), f ? (c & 536870912) !== 0 && (r.flags & 128) === 0 && (Ht(r), r.subtreeFlags & 6 && (r.flags |= 8192)) : Ht(r), c = r.updateQueue, c !== null && Ho(r, c.retryQueue), c = null, l !== null && l.memoizedState !== null && l.memoizedState.cachePool !== null && (c = l.memoizedState.cachePool.pool), f = null, r.memoizedState !== null && r.memoizedState.cachePool !== null && (f = r.memoizedState.cachePool.pool), f !== c && (r.flags |= 2048), l !== null && tt(Pl), null;
      case 24:
        return c = null, l !== null && (c = l.memoizedState.cache), r.memoizedState.cache !== c && (r.flags |= 2048), cn(fe), Ht(r), null;
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(i(156, r.tag));
  }
  function tT(l, r) {
    switch (Ef(r), r.tag) {
      case 1:
        return l = r.flags, l & 65536 ? (r.flags = l & -65537 | 128, r) : null;
      case 3:
        return cn(fe), An(), l = r.flags, (l & 65536) !== 0 && (l & 128) === 0 ? (r.flags = l & -65537 | 128, r) : null;
      case 26:
      case 27:
      case 5:
        return so(r), null;
      case 13:
        if (fn(r), l = r.memoizedState, l !== null && l.dehydrated !== null) {
          if (r.alternate === null)
            throw Error(i(340));
          wr();
        }
        return l = r.flags, l & 65536 ? (r.flags = l & -65537 | 128, r) : null;
      case 19:
        return tt(he), null;
      case 4:
        return An(), null;
      case 10:
        return cn(r.type), null;
      case 22:
      case 23:
        return fn(r), Hf(), l !== null && tt(Pl), l = r.flags, l & 65536 ? (r.flags = l & -65537 | 128, r) : null;
      case 24:
        return cn(fe), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function M0(l, r) {
    switch (Ef(r), r.tag) {
      case 3:
        cn(fe), An();
        break;
      case 26:
      case 27:
      case 5:
        so(r);
        break;
      case 4:
        An();
        break;
      case 13:
        fn(r);
        break;
      case 19:
        tt(he);
        break;
      case 10:
        cn(r.type);
        break;
      case 22:
      case 23:
        fn(r), Hf(), l !== null && tt(Pl);
        break;
      case 24:
        cn(fe);
    }
  }
  function Ur(l, r) {
    try {
      var c = r.updateQueue, f = c !== null ? c.lastEffect : null;
      if (f !== null) {
        var O = f.next;
        c = O;
        do {
          if ((c.tag & l) === l) {
            f = void 0;
            var m = c.create, S = c.inst;
            f = m(), S.destroy = f;
          }
          c = c.next;
        } while (c !== O);
      }
    } catch (v) {
      Dt(r, r.return, v);
    }
  }
  function Yn(l, r, c) {
    try {
      var f = r.updateQueue, O = f !== null ? f.lastEffect : null;
      if (O !== null) {
        var m = O.next;
        f = m;
        do {
          if ((f.tag & l) === l) {
            var S = f.inst, v = S.destroy;
            if (v !== void 0) {
              S.destroy = void 0, O = r;
              var k = c, C = v;
              try {
                C();
              } catch (D) {
                Dt(
                  O,
                  k,
                  D
                );
              }
            }
          }
          f = f.next;
        } while (f !== m);
      }
    } catch (D) {
      Dt(r, r.return, D);
    }
  }
  function q0(l) {
    var r = l.updateQueue;
    if (r !== null) {
      var c = l.stateNode;
      try {
        Sg(r, c);
      } catch (f) {
        Dt(l, l.return, f);
      }
    }
  }
  function C0(l, r, c) {
    c.props = Al(
      l.type,
      l.memoizedProps
    ), c.state = l.memoizedState;
    try {
      c.componentWillUnmount();
    } catch (f) {
      Dt(l, r, f);
    }
  }
  function jr(l, r) {
    try {
      var c = l.ref;
      if (c !== null) {
        switch (l.tag) {
          case 26:
          case 27:
          case 5:
            var f = l.stateNode;
            break;
          case 30:
            f = l.stateNode;
            break;
          default:
            f = l.stateNode;
        }
        typeof c == "function" ? l.refCleanup = c(f) : c.current = f;
      }
    } catch (O) {
      Dt(l, r, O);
    }
  }
  function Zi(l, r) {
    var c = l.ref, f = l.refCleanup;
    if (c !== null)
      if (typeof f == "function")
        try {
          f();
        } catch (O) {
          Dt(l, r, O);
        } finally {
          l.refCleanup = null, l = l.alternate, l != null && (l.refCleanup = null);
        }
      else if (typeof c == "function")
        try {
          c(null);
        } catch (O) {
          Dt(l, r, O);
        }
      else c.current = null;
  }
  function Z0(l) {
    var r = l.type, c = l.memoizedProps, f = l.stateNode;
    try {
      t: switch (r) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          c.autoFocus && f.focus();
          break t;
        case "img":
          c.src ? f.src = c.src : c.srcSet && (f.srcset = c.srcSet);
      }
    } catch (O) {
      Dt(l, l.return, O);
    }
  }
  function xh(l, r, c) {
    try {
      var f = l.stateNode;
      vT(f, l.type, c, r), f[_e] = r;
    } catch (O) {
      Dt(l, l.return, O);
    }
  }
  function E0(l) {
    return l.tag === 5 || l.tag === 3 || l.tag === 26 || l.tag === 27 && Hn(l.type) || l.tag === 4;
  }
  function kh(l) {
    t: for (; ; ) {
      for (; l.sibling === null; ) {
        if (l.return === null || E0(l.return)) return null;
        l = l.return;
      }
      for (l.sibling.return = l.return, l = l.sibling; l.tag !== 5 && l.tag !== 6 && l.tag !== 18; ) {
        if (l.tag === 27 && Hn(l.type) || l.flags & 2 || l.child === null || l.tag === 4) continue t;
        l.child.return = l, l = l.child;
      }
      if (!(l.flags & 2)) return l.stateNode;
    }
  }
  function wh(l, r, c) {
    var f = l.tag;
    if (f === 5 || f === 6)
      l = l.stateNode, r ? (c.nodeType === 9 ? c.body : c.nodeName === "HTML" ? c.ownerDocument.body : c).insertBefore(l, r) : (r = c.nodeType === 9 ? c.body : c.nodeName === "HTML" ? c.ownerDocument.body : c, r.appendChild(l), c = c._reactRootContainer, c != null || r.onclick !== null || (r.onclick = ac));
    else if (f !== 4 && (f === 27 && Hn(l.type) && (c = l.stateNode, r = null), l = l.child, l !== null))
      for (wh(l, r, c), l = l.sibling; l !== null; )
        wh(l, r, c), l = l.sibling;
  }
  function Ko(l, r, c) {
    var f = l.tag;
    if (f === 5 || f === 6)
      l = l.stateNode, r ? c.insertBefore(l, r) : c.appendChild(l);
    else if (f !== 4 && (f === 27 && Hn(l.type) && (c = l.stateNode), l = l.child, l !== null))
      for (Ko(l, r, c), l = l.sibling; l !== null; )
        Ko(l, r, c), l = l.sibling;
  }
  function X0(l) {
    var r = l.stateNode, c = l.memoizedProps;
    try {
      for (var f = l.type, O = r.attributes; O.length; )
        r.removeAttributeNode(O[0]);
      be(r, f, c), r[Pe] = l, r[_e] = c;
    } catch (m) {
      Dt(l, l.return, m);
    }
  }
  var dn = !1, te = !1, Th = !1, _0 = typeof WeakSet == "function" ? WeakSet : Set, me = null;
  function eT(l, r) {
    if (l = l.containerInfo, Kh = dc, l = Wm(l), kf(l)) {
      if ("selectionStart" in l)
        var c = {
          start: l.selectionStart,
          end: l.selectionEnd
        };
      else
        t: {
          c = (c = l.ownerDocument) && c.defaultView || window;
          var f = c.getSelection && c.getSelection();
          if (f && f.rangeCount !== 0) {
            c = f.anchorNode;
            var O = f.anchorOffset, m = f.focusNode;
            f = f.focusOffset;
            try {
              c.nodeType, m.nodeType;
            } catch {
              c = null;
              break t;
            }
            var S = 0, v = -1, k = -1, C = 0, D = 0, B = l, Z = null;
            e: for (; ; ) {
              for (var X; B !== c || O !== 0 && B.nodeType !== 3 || (v = S + O), B !== m || f !== 0 && B.nodeType !== 3 || (k = S + f), B.nodeType === 3 && (S += B.nodeValue.length), (X = B.firstChild) !== null; )
                Z = B, B = X;
              for (; ; ) {
                if (B === l) break e;
                if (Z === c && ++C === O && (v = S), Z === m && ++D === f && (k = S), (X = B.nextSibling) !== null) break;
                B = Z, Z = B.parentNode;
              }
              B = X;
            }
            c = v === -1 || k === -1 ? null : { start: v, end: k };
          } else c = null;
        }
      c = c || { start: 0, end: 0 };
    } else c = null;
    for (Jh = { focusedElem: l, selectionRange: c }, dc = !1, me = r; me !== null; )
      if (r = me, l = r.child, (r.subtreeFlags & 1024) !== 0 && l !== null)
        l.return = r, me = l;
      else
        for (; me !== null; ) {
          switch (r = me, m = r.alternate, l = r.flags, r.tag) {
            case 0:
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((l & 1024) !== 0 && m !== null) {
                l = void 0, c = r, O = m.memoizedProps, m = m.memoizedState, f = c.stateNode;
                try {
                  var gt = Al(
                    c.type,
                    O,
                    c.elementType === c.type
                  );
                  l = f.getSnapshotBeforeUpdate(
                    gt,
                    m
                  ), f.__reactInternalSnapshotBeforeUpdate = l;
                } catch (dt) {
                  Dt(
                    c,
                    c.return,
                    dt
                  );
                }
              }
              break;
            case 3:
              if ((l & 1024) !== 0) {
                if (l = r.stateNode.containerInfo, c = l.nodeType, c === 9)
                  tO(l);
                else if (c === 1)
                  switch (l.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      tO(l);
                      break;
                    default:
                      l.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((l & 1024) !== 0) throw Error(i(163));
          }
          if (l = r.sibling, l !== null) {
            l.return = r.return, me = l;
            break;
          }
          me = r.return;
        }
  }
  function z0(l, r, c) {
    var f = c.flags;
    switch (c.tag) {
      case 0:
      case 11:
      case 15:
        Un(l, c), f & 4 && Ur(5, c);
        break;
      case 1:
        if (Un(l, c), f & 4)
          if (l = c.stateNode, r === null)
            try {
              l.componentDidMount();
            } catch (S) {
              Dt(c, c.return, S);
            }
          else {
            var O = Al(
              c.type,
              r.memoizedProps
            );
            r = r.memoizedState;
            try {
              l.componentDidUpdate(
                O,
                r,
                l.__reactInternalSnapshotBeforeUpdate
              );
            } catch (S) {
              Dt(
                c,
                c.return,
                S
              );
            }
          }
        f & 64 && q0(c), f & 512 && jr(c, c.return);
        break;
      case 3:
        if (Un(l, c), f & 64 && (l = c.updateQueue, l !== null)) {
          if (r = null, c.child !== null)
            switch (c.child.tag) {
              case 27:
              case 5:
                r = c.child.stateNode;
                break;
              case 1:
                r = c.child.stateNode;
            }
          try {
            Sg(l, r);
          } catch (S) {
            Dt(c, c.return, S);
          }
        }
        break;
      case 27:
        r === null && f & 4 && X0(c);
      case 26:
      case 5:
        Un(l, c), r === null && f & 4 && Z0(c), f & 512 && jr(c, c.return);
        break;
      case 12:
        Un(l, c);
        break;
      case 13:
        Un(l, c), f & 4 && Y0(l, c), f & 64 && (l = c.memoizedState, l !== null && (l = l.dehydrated, l !== null && (c = uT.bind(
          null,
          c
        ), PT(l, c))));
        break;
      case 22:
        if (f = c.memoizedState !== null || dn, !f) {
          r = r !== null && r.memoizedState !== null || te, O = dn;
          var m = te;
          dn = f, (te = r) && !m ? jn(
            l,
            c,
            (c.subtreeFlags & 8772) !== 0
          ) : Un(l, c), dn = O, te = m;
        }
        break;
      case 30:
        break;
      default:
        Un(l, c);
    }
  }
  function D0(l) {
    var r = l.alternate;
    r !== null && (l.alternate = null, D0(r)), l.child = null, l.deletions = null, l.sibling = null, l.tag === 5 && (r = l.stateNode, r !== null && sf(r)), l.stateNode = null, l.return = null, l.dependencies = null, l.memoizedProps = null, l.memoizedState = null, l.pendingProps = null, l.stateNode = null, l.updateQueue = null;
  }
  var Nt = null, Ve = !1;
  function pn(l, r, c) {
    for (c = c.child; c !== null; )
      V0(l, r, c), c = c.sibling;
  }
  function V0(l, r, c) {
    if (He && typeof He.onCommitFiberUnmount == "function")
      try {
        He.onCommitFiberUnmount(ur, c);
      } catch {
      }
    switch (c.tag) {
      case 26:
        te || Zi(c, r), pn(
          l,
          r,
          c
        ), c.memoizedState ? c.memoizedState.count-- : c.stateNode && (c = c.stateNode, c.parentNode.removeChild(c));
        break;
      case 27:
        te || Zi(c, r);
        var f = Nt, O = Ve;
        Hn(c.type) && (Nt = c.stateNode, Ve = !1), pn(
          l,
          r,
          c
        ), Ir(c.stateNode), Nt = f, Ve = O;
        break;
      case 5:
        te || Zi(c, r);
      case 6:
        if (f = Nt, O = Ve, Nt = null, pn(
          l,
          r,
          c
        ), Nt = f, Ve = O, Nt !== null)
          if (Ve)
            try {
              (Nt.nodeType === 9 ? Nt.body : Nt.nodeName === "HTML" ? Nt.ownerDocument.body : Nt).removeChild(c.stateNode);
            } catch (m) {
              Dt(
                c,
                r,
                m
              );
            }
          else
            try {
              Nt.removeChild(c.stateNode);
            } catch (m) {
              Dt(
                c,
                r,
                m
              );
            }
        break;
      case 18:
        Nt !== null && (Ve ? (l = Nt, Py(
          l.nodeType === 9 ? l.body : l.nodeName === "HTML" ? l.ownerDocument.body : l,
          c.stateNode
        ), ra(l)) : Py(Nt, c.stateNode));
        break;
      case 4:
        f = Nt, O = Ve, Nt = c.stateNode.containerInfo, Ve = !0, pn(
          l,
          r,
          c
        ), Nt = f, Ve = O;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        te || Yn(2, c, r), te || Yn(4, c, r), pn(
          l,
          r,
          c
        );
        break;
      case 1:
        te || (Zi(c, r), f = c.stateNode, typeof f.componentWillUnmount == "function" && C0(
          c,
          r,
          f
        )), pn(
          l,
          r,
          c
        );
        break;
      case 21:
        pn(
          l,
          r,
          c
        );
        break;
      case 22:
        te = (f = te) || c.memoizedState !== null, pn(
          l,
          r,
          c
        ), te = f;
        break;
      default:
        pn(
          l,
          r,
          c
        );
    }
  }
  function Y0(l, r) {
    if (r.memoizedState === null && (l = r.alternate, l !== null && (l = l.memoizedState, l !== null && (l = l.dehydrated, l !== null))))
      try {
        ra(l);
      } catch (c) {
        Dt(r, r.return, c);
      }
  }
  function iT(l) {
    switch (l.tag) {
      case 13:
      case 19:
        var r = l.stateNode;
        return r === null && (r = l.stateNode = new _0()), r;
      case 22:
        return l = l.stateNode, r = l._retryCache, r === null && (r = l._retryCache = new _0()), r;
      default:
        throw Error(i(435, l.tag));
    }
  }
  function $h(l, r) {
    var c = iT(l);
    r.forEach(function(f) {
      var O = fT.bind(null, l, f);
      c.has(f) || (c.add(f), f.then(O, O));
    });
  }
  function Fe(l, r) {
    var c = r.deletions;
    if (c !== null)
      for (var f = 0; f < c.length; f++) {
        var O = c[f], m = l, S = r, v = S;
        t: for (; v !== null; ) {
          switch (v.tag) {
            case 27:
              if (Hn(v.type)) {
                Nt = v.stateNode, Ve = !1;
                break t;
              }
              break;
            case 5:
              Nt = v.stateNode, Ve = !1;
              break t;
            case 3:
            case 4:
              Nt = v.stateNode.containerInfo, Ve = !0;
              break t;
          }
          v = v.return;
        }
        if (Nt === null) throw Error(i(160));
        V0(m, S, O), Nt = null, Ve = !1, m = O.alternate, m !== null && (m.return = null), O.return = null;
      }
    if (r.subtreeFlags & 13878)
      for (r = r.child; r !== null; )
        U0(r, l), r = r.sibling;
  }
  var wi = null;
  function U0(l, r) {
    var c = l.alternate, f = l.flags;
    switch (l.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Fe(r, l), ti(l), f & 4 && (Yn(3, l, l.return), Ur(3, l), Yn(5, l, l.return));
        break;
      case 1:
        Fe(r, l), ti(l), f & 512 && (te || c === null || Zi(c, c.return)), f & 64 && dn && (l = l.updateQueue, l !== null && (f = l.callbacks, f !== null && (c = l.shared.hiddenCallbacks, l.shared.hiddenCallbacks = c === null ? f : c.concat(f))));
        break;
      case 26:
        var O = wi;
        if (Fe(r, l), ti(l), f & 512 && (te || c === null || Zi(c, c.return)), f & 4) {
          var m = c !== null ? c.memoizedState : null;
          if (f = l.memoizedState, c === null)
            if (f === null)
              if (l.stateNode === null) {
                t: {
                  f = l.type, c = l.memoizedProps, O = O.ownerDocument || O;
                  e: switch (f) {
                    case "title":
                      m = O.getElementsByTagName("title")[0], (!m || m[Or] || m[Pe] || m.namespaceURI === "http://www.w3.org/2000/svg" || m.hasAttribute("itemprop")) && (m = O.createElement(f), O.head.insertBefore(
                        m,
                        O.querySelector("head > title")
                      )), be(m, f, c), m[Pe] = l, de(m), f = m;
                      break t;
                    case "link":
                      var S = Xy(
                        "link",
                        "href",
                        O
                      ).get(f + (c.href || ""));
                      if (S) {
                        for (var v = 0; v < S.length; v++)
                          if (m = S[v], m.getAttribute("href") === (c.href == null || c.href === "" ? null : c.href) && m.getAttribute("rel") === (c.rel == null ? null : c.rel) && m.getAttribute("title") === (c.title == null ? null : c.title) && m.getAttribute("crossorigin") === (c.crossOrigin == null ? null : c.crossOrigin)) {
                            S.splice(v, 1);
                            break e;
                          }
                      }
                      m = O.createElement(f), be(m, f, c), O.head.appendChild(m);
                      break;
                    case "meta":
                      if (S = Xy(
                        "meta",
                        "content",
                        O
                      ).get(f + (c.content || ""))) {
                        for (v = 0; v < S.length; v++)
                          if (m = S[v], m.getAttribute("content") === (c.content == null ? null : "" + c.content) && m.getAttribute("name") === (c.name == null ? null : c.name) && m.getAttribute("property") === (c.property == null ? null : c.property) && m.getAttribute("http-equiv") === (c.httpEquiv == null ? null : c.httpEquiv) && m.getAttribute("charset") === (c.charSet == null ? null : c.charSet)) {
                            S.splice(v, 1);
                            break e;
                          }
                      }
                      m = O.createElement(f), be(m, f, c), O.head.appendChild(m);
                      break;
                    default:
                      throw Error(i(468, f));
                  }
                  m[Pe] = l, de(m), f = m;
                }
                l.stateNode = f;
              } else
                _y(
                  O,
                  l.type,
                  l.stateNode
                );
            else
              l.stateNode = Ey(
                O,
                f,
                l.memoizedProps
              );
          else
            m !== f ? (m === null ? c.stateNode !== null && (c = c.stateNode, c.parentNode.removeChild(c)) : m.count--, f === null ? _y(
              O,
              l.type,
              l.stateNode
            ) : Ey(
              O,
              f,
              l.memoizedProps
            )) : f === null && l.stateNode !== null && xh(
              l,
              l.memoizedProps,
              c.memoizedProps
            );
        }
        break;
      case 27:
        Fe(r, l), ti(l), f & 512 && (te || c === null || Zi(c, c.return)), c !== null && f & 4 && xh(
          l,
          l.memoizedProps,
          c.memoizedProps
        );
        break;
      case 5:
        if (Fe(r, l), ti(l), f & 512 && (te || c === null || Zi(c, c.return)), l.flags & 32) {
          O = l.stateNode;
          try {
            ss(O, "");
          } catch (X) {
            Dt(l, l.return, X);
          }
        }
        f & 4 && l.stateNode != null && (O = l.memoizedProps, xh(
          l,
          O,
          c !== null ? c.memoizedProps : O
        )), f & 1024 && (Th = !0);
        break;
      case 6:
        if (Fe(r, l), ti(l), f & 4) {
          if (l.stateNode === null)
            throw Error(i(162));
          f = l.memoizedProps, c = l.stateNode;
          try {
            c.nodeValue = f;
          } catch (X) {
            Dt(l, l.return, X);
          }
        }
        break;
      case 3:
        if (fc = null, O = wi, wi = cc(r.containerInfo), Fe(r, l), wi = O, ti(l), f & 4 && c !== null && c.memoizedState.isDehydrated)
          try {
            ra(r.containerInfo);
          } catch (X) {
            Dt(l, l.return, X);
          }
        Th && (Th = !1, j0(l));
        break;
      case 4:
        f = wi, wi = cc(
          l.stateNode.containerInfo
        ), Fe(r, l), ti(l), wi = f;
        break;
      case 12:
        Fe(r, l), ti(l);
        break;
      case 13:
        Fe(r, l), ti(l), l.child.flags & 8192 && l.memoizedState !== null != (c !== null && c.memoizedState !== null) && (Ch = Mi()), f & 4 && (f = l.updateQueue, f !== null && (l.updateQueue = null, $h(l, f)));
        break;
      case 22:
        O = l.memoizedState !== null;
        var k = c !== null && c.memoizedState !== null, C = dn, D = te;
        if (dn = C || O, te = D || k, Fe(r, l), te = D, dn = C, ti(l), f & 8192)
          t: for (r = l.stateNode, r._visibility = O ? r._visibility & -2 : r._visibility | 1, O && (c === null || k || dn || te || Ml(l)), c = null, r = l; ; ) {
            if (r.tag === 5 || r.tag === 26) {
              if (c === null) {
                k = c = r;
                try {
                  if (m = k.stateNode, O)
                    S = m.style, typeof S.setProperty == "function" ? S.setProperty("display", "none", "important") : S.display = "none";
                  else {
                    v = k.stateNode;
                    var B = k.memoizedProps.style, Z = B != null && B.hasOwnProperty("display") ? B.display : null;
                    v.style.display = Z == null || typeof Z == "boolean" ? "" : ("" + Z).trim();
                  }
                } catch (X) {
                  Dt(k, k.return, X);
                }
              }
            } else if (r.tag === 6) {
              if (c === null) {
                k = r;
                try {
                  k.stateNode.nodeValue = O ? "" : k.memoizedProps;
                } catch (X) {
                  Dt(k, k.return, X);
                }
              }
            } else if ((r.tag !== 22 && r.tag !== 23 || r.memoizedState === null || r === l) && r.child !== null) {
              r.child.return = r, r = r.child;
              continue;
            }
            if (r === l) break t;
            for (; r.sibling === null; ) {
              if (r.return === null || r.return === l) break t;
              c === r && (c = null), r = r.return;
            }
            c === r && (c = null), r.sibling.return = r.return, r = r.sibling;
          }
        f & 4 && (f = l.updateQueue, f !== null && (c = f.retryQueue, c !== null && (f.retryQueue = null, $h(l, c))));
        break;
      case 19:
        Fe(r, l), ti(l), f & 4 && (f = l.updateQueue, f !== null && (l.updateQueue = null, $h(l, f)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        Fe(r, l), ti(l);
    }
  }
  function ti(l) {
    var r = l.flags;
    if (r & 2) {
      try {
        for (var c, f = l.return; f !== null; ) {
          if (E0(f)) {
            c = f;
            break;
          }
          f = f.return;
        }
        if (c == null) throw Error(i(160));
        switch (c.tag) {
          case 27:
            var O = c.stateNode, m = kh(l);
            Ko(l, m, O);
            break;
          case 5:
            var S = c.stateNode;
            c.flags & 32 && (ss(S, ""), c.flags &= -33);
            var v = kh(l);
            Ko(l, v, S);
            break;
          case 3:
          case 4:
            var k = c.stateNode.containerInfo, C = kh(l);
            wh(
              l,
              C,
              k
            );
            break;
          default:
            throw Error(i(161));
        }
      } catch (D) {
        Dt(l, l.return, D);
      }
      l.flags &= -3;
    }
    r & 4096 && (l.flags &= -4097);
  }
  function j0(l) {
    if (l.subtreeFlags & 1024)
      for (l = l.child; l !== null; ) {
        var r = l;
        j0(r), r.tag === 5 && r.flags & 1024 && r.stateNode.reset(), l = l.sibling;
      }
  }
  function Un(l, r) {
    if (r.subtreeFlags & 8772)
      for (r = r.child; r !== null; )
        z0(l, r.alternate, r), r = r.sibling;
  }
  function Ml(l) {
    for (l = l.child; l !== null; ) {
      var r = l;
      switch (r.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Yn(4, r, r.return), Ml(r);
          break;
        case 1:
          Zi(r, r.return);
          var c = r.stateNode;
          typeof c.componentWillUnmount == "function" && C0(
            r,
            r.return,
            c
          ), Ml(r);
          break;
        case 27:
          Ir(r.stateNode);
        case 26:
        case 5:
          Zi(r, r.return), Ml(r);
          break;
        case 22:
          r.memoizedState === null && Ml(r);
          break;
        case 30:
          Ml(r);
          break;
        default:
          Ml(r);
      }
      l = l.sibling;
    }
  }
  function jn(l, r, c) {
    for (c = c && (r.subtreeFlags & 8772) !== 0, r = r.child; r !== null; ) {
      var f = r.alternate, O = l, m = r, S = m.flags;
      switch (m.tag) {
        case 0:
        case 11:
        case 15:
          jn(
            O,
            m,
            c
          ), Ur(4, m);
          break;
        case 1:
          if (jn(
            O,
            m,
            c
          ), f = m, O = f.stateNode, typeof O.componentDidMount == "function")
            try {
              O.componentDidMount();
            } catch (C) {
              Dt(f, f.return, C);
            }
          if (f = m, O = f.updateQueue, O !== null) {
            var v = f.stateNode;
            try {
              var k = O.shared.hiddenCallbacks;
              if (k !== null)
                for (O.shared.hiddenCallbacks = null, O = 0; O < k.length; O++)
                  yg(k[O], v);
            } catch (C) {
              Dt(f, f.return, C);
            }
          }
          c && S & 64 && q0(m), jr(m, m.return);
          break;
        case 27:
          X0(m);
        case 26:
        case 5:
          jn(
            O,
            m,
            c
          ), c && f === null && S & 4 && Z0(m), jr(m, m.return);
          break;
        case 12:
          jn(
            O,
            m,
            c
          );
          break;
        case 13:
          jn(
            O,
            m,
            c
          ), c && S & 4 && Y0(O, m);
          break;
        case 22:
          m.memoizedState === null && jn(
            O,
            m,
            c
          ), jr(m, m.return);
          break;
        case 30:
          break;
        default:
          jn(
            O,
            m,
            c
          );
      }
      r = r.sibling;
    }
  }
  function Ph(l, r) {
    var c = null;
    l !== null && l.memoizedState !== null && l.memoizedState.cachePool !== null && (c = l.memoizedState.cachePool.pool), l = null, r.memoizedState !== null && r.memoizedState.cachePool !== null && (l = r.memoizedState.cachePool.pool), l !== c && (l != null && l.refCount++, c != null && Pr(c));
  }
  function Rh(l, r) {
    l = null, r.alternate !== null && (l = r.alternate.memoizedState.cache), r = r.memoizedState.cache, r !== l && (r.refCount++, l != null && Pr(l));
  }
  function Ei(l, r, c, f) {
    if (r.subtreeFlags & 10256)
      for (r = r.child; r !== null; )
        L0(
          l,
          r,
          c,
          f
        ), r = r.sibling;
  }
  function L0(l, r, c, f) {
    var O = r.flags;
    switch (r.tag) {
      case 0:
      case 11:
      case 15:
        Ei(
          l,
          r,
          c,
          f
        ), O & 2048 && Ur(9, r);
        break;
      case 1:
        Ei(
          l,
          r,
          c,
          f
        );
        break;
      case 3:
        Ei(
          l,
          r,
          c,
          f
        ), O & 2048 && (l = null, r.alternate !== null && (l = r.alternate.memoizedState.cache), r = r.memoizedState.cache, r !== l && (r.refCount++, l != null && Pr(l)));
        break;
      case 12:
        if (O & 2048) {
          Ei(
            l,
            r,
            c,
            f
          ), l = r.stateNode;
          try {
            var m = r.memoizedProps, S = m.id, v = m.onPostCommit;
            typeof v == "function" && v(
              S,
              r.alternate === null ? "mount" : "update",
              l.passiveEffectDuration,
              -0
            );
          } catch (k) {
            Dt(r, r.return, k);
          }
        } else
          Ei(
            l,
            r,
            c,
            f
          );
        break;
      case 13:
        Ei(
          l,
          r,
          c,
          f
        );
        break;
      case 23:
        break;
      case 22:
        m = r.stateNode, S = r.alternate, r.memoizedState !== null ? m._visibility & 2 ? Ei(
          l,
          r,
          c,
          f
        ) : Lr(l, r) : m._visibility & 2 ? Ei(
          l,
          r,
          c,
          f
        ) : (m._visibility |= 2, ks(
          l,
          r,
          c,
          f,
          (r.subtreeFlags & 10256) !== 0
        )), O & 2048 && Ph(S, r);
        break;
      case 24:
        Ei(
          l,
          r,
          c,
          f
        ), O & 2048 && Rh(r.alternate, r);
        break;
      default:
        Ei(
          l,
          r,
          c,
          f
        );
    }
  }
  function ks(l, r, c, f, O) {
    for (O = O && (r.subtreeFlags & 10256) !== 0, r = r.child; r !== null; ) {
      var m = l, S = r, v = c, k = f, C = S.flags;
      switch (S.tag) {
        case 0:
        case 11:
        case 15:
          ks(
            m,
            S,
            v,
            k,
            O
          ), Ur(8, S);
          break;
        case 23:
          break;
        case 22:
          var D = S.stateNode;
          S.memoizedState !== null ? D._visibility & 2 ? ks(
            m,
            S,
            v,
            k,
            O
          ) : Lr(
            m,
            S
          ) : (D._visibility |= 2, ks(
            m,
            S,
            v,
            k,
            O
          )), O && C & 2048 && Ph(
            S.alternate,
            S
          );
          break;
        case 24:
          ks(
            m,
            S,
            v,
            k,
            O
          ), O && C & 2048 && Rh(S.alternate, S);
          break;
        default:
          ks(
            m,
            S,
            v,
            k,
            O
          );
      }
      r = r.sibling;
    }
  }
  function Lr(l, r) {
    if (r.subtreeFlags & 10256)
      for (r = r.child; r !== null; ) {
        var c = l, f = r, O = f.flags;
        switch (f.tag) {
          case 22:
            Lr(c, f), O & 2048 && Ph(
              f.alternate,
              f
            );
            break;
          case 24:
            Lr(c, f), O & 2048 && Rh(f.alternate, f);
            break;
          default:
            Lr(c, f);
        }
        r = r.sibling;
      }
  }
  var Br = 8192;
  function ws(l) {
    if (l.subtreeFlags & Br)
      for (l = l.child; l !== null; )
        B0(l), l = l.sibling;
  }
  function B0(l) {
    switch (l.tag) {
      case 26:
        ws(l), l.flags & Br && l.memoizedState !== null && YT(
          wi,
          l.memoizedState,
          l.memoizedProps
        );
        break;
      case 5:
        ws(l);
        break;
      case 3:
      case 4:
        var r = wi;
        wi = cc(l.stateNode.containerInfo), ws(l), wi = r;
        break;
      case 22:
        l.memoizedState === null && (r = l.alternate, r !== null && r.memoizedState !== null ? (r = Br, Br = 16777216, ws(l), Br = r) : ws(l));
        break;
      default:
        ws(l);
    }
  }
  function G0(l) {
    var r = l.alternate;
    if (r !== null && (l = r.child, l !== null)) {
      r.child = null;
      do
        r = l.sibling, l.sibling = null, l = r;
      while (l !== null);
    }
  }
  function Gr(l) {
    var r = l.deletions;
    if ((l.flags & 16) !== 0) {
      if (r !== null)
        for (var c = 0; c < r.length; c++) {
          var f = r[c];
          me = f, W0(
            f,
            l
          );
        }
      G0(l);
    }
    if (l.subtreeFlags & 10256)
      for (l = l.child; l !== null; )
        N0(l), l = l.sibling;
  }
  function N0(l) {
    switch (l.tag) {
      case 0:
      case 11:
      case 15:
        Gr(l), l.flags & 2048 && Yn(9, l, l.return);
        break;
      case 3:
        Gr(l);
        break;
      case 12:
        Gr(l);
        break;
      case 22:
        var r = l.stateNode;
        l.memoizedState !== null && r._visibility & 2 && (l.return === null || l.return.tag !== 13) ? (r._visibility &= -3, Jo(l)) : Gr(l);
        break;
      default:
        Gr(l);
    }
  }
  function Jo(l) {
    var r = l.deletions;
    if ((l.flags & 16) !== 0) {
      if (r !== null)
        for (var c = 0; c < r.length; c++) {
          var f = r[c];
          me = f, W0(
            f,
            l
          );
        }
      G0(l);
    }
    for (l = l.child; l !== null; ) {
      switch (r = l, r.tag) {
        case 0:
        case 11:
        case 15:
          Yn(8, r, r.return), Jo(r);
          break;
        case 22:
          c = r.stateNode, c._visibility & 2 && (c._visibility &= -3, Jo(r));
          break;
        default:
          Jo(r);
      }
      l = l.sibling;
    }
  }
  function W0(l, r) {
    for (; me !== null; ) {
      var c = me;
      switch (c.tag) {
        case 0:
        case 11:
        case 15:
          Yn(8, c, r);
          break;
        case 23:
        case 22:
          if (c.memoizedState !== null && c.memoizedState.cachePool !== null) {
            var f = c.memoizedState.cachePool.pool;
            f != null && f.refCount++;
          }
          break;
        case 24:
          Pr(c.memoizedState.cache);
      }
      if (f = c.child, f !== null) f.return = c, me = f;
      else
        t: for (c = l; me !== null; ) {
          f = me;
          var O = f.sibling, m = f.return;
          if (D0(f), f === c) {
            me = null;
            break t;
          }
          if (O !== null) {
            O.return = m, me = O;
            break t;
          }
          me = m;
        }
    }
  }
  var nT = {
    getCacheForType: function(l) {
      var r = Re(fe), c = r.data.get(l);
      return c === void 0 && (c = l(), r.data.set(l, c)), c;
    }
  }, lT = typeof WeakMap == "function" ? WeakMap : Map, Zt = 0, jt = null, wt = null, Pt = 0, Et = 0, ei = null, Ln = !1, Ts = !1, Ah = !1, mn = 0, It = 0, Bn = 0, ql = 0, Mh = 0, mi = 0, $s = 0, Nr = null, Ye = null, qh = !1, Ch = 0, Io = 1 / 0, Fo = null, Gn = null, ve = 0, Nn = null, Ps = null, Rs = 0, Zh = 0, Eh = null, H0 = null, Wr = 0, Xh = null;
  function ii() {
    if ((Zt & 2) !== 0 && Pt !== 0)
      return Pt & -Pt;
    if (E.T !== null) {
      var l = ms;
      return l !== 0 ? l : jh();
    }
    return fm();
  }
  function K0() {
    mi === 0 && (mi = (Pt & 536870912) === 0 || Ct ? am() : 536870912);
    var l = pi.current;
    return l !== null && (l.flags |= 32), mi;
  }
  function ni(l, r, c) {
    (l === jt && (Et === 2 || Et === 9) || l.cancelPendingCommit !== null) && (As(l, 0), Wn(
      l,
      Pt,
      mi,
      !1
    )), hr(l, c), ((Zt & 2) === 0 || l !== jt) && (l === jt && ((Zt & 2) === 0 && (ql |= c), It === 4 && Wn(
      l,
      Pt,
      mi,
      !1
    )), Xi(l));
  }
  function J0(l, r, c) {
    if ((Zt & 6) !== 0) throw Error(i(327));
    var f = !c && (r & 124) === 0 && (r & l.expiredLanes) === 0 || fr(l, r), O = f ? aT(l, r) : Dh(l, r, !0), m = f;
    do {
      if (O === 0) {
        Ts && !f && Wn(l, r, 0, !1);
        break;
      } else {
        if (c = l.current.alternate, m && !sT(c)) {
          O = Dh(l, r, !1), m = !1;
          continue;
        }
        if (O === 2) {
          if (m = r, l.errorRecoveryDisabledLanes & m)
            var S = 0;
          else
            S = l.pendingLanes & -536870913, S = S !== 0 ? S : S & 536870912 ? 536870912 : 0;
          if (S !== 0) {
            r = S;
            t: {
              var v = l;
              O = Nr;
              var k = v.current.memoizedState.isDehydrated;
              if (k && (As(v, S).flags |= 256), S = Dh(
                v,
                S,
                !1
              ), S !== 2) {
                if (Ah && !k) {
                  v.errorRecoveryDisabledLanes |= m, ql |= m, O = 4;
                  break t;
                }
                m = Ye, Ye = O, m !== null && (Ye === null ? Ye = m : Ye.push.apply(
                  Ye,
                  m
                ));
              }
              O = S;
            }
            if (m = !1, O !== 2) continue;
          }
        }
        if (O === 1) {
          As(l, 0), Wn(l, r, 0, !0);
          break;
        }
        t: {
          switch (f = l, m = O, m) {
            case 0:
            case 1:
              throw Error(i(345));
            case 4:
              if ((r & 4194048) !== r) break;
            case 6:
              Wn(
                f,
                r,
                mi,
                !Ln
              );
              break t;
            case 2:
              Ye = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(i(329));
          }
          if ((r & 62914560) === r && (O = Ch + 300 - Mi(), 10 < O)) {
            if (Wn(
              f,
              r,
              mi,
              !Ln
            ), co(f, 0, !0) !== 0) break t;
            f.timeoutHandle = Ty(
              I0.bind(
                null,
                f,
                c,
                Ye,
                Fo,
                qh,
                r,
                mi,
                ql,
                $s,
                Ln,
                m,
                2,
                -0,
                0
              ),
              O
            );
            break t;
          }
          I0(
            f,
            c,
            Ye,
            Fo,
            qh,
            r,
            mi,
            ql,
            $s,
            Ln,
            m,
            0,
            -0,
            0
          );
        }
      }
      break;
    } while (!0);
    Xi(l);
  }
  function I0(l, r, c, f, O, m, S, v, k, C, D, B, Z, X) {
    if (l.timeoutHandle = -1, B = r.subtreeFlags, (B & 8192 || (B & 16785408) === 16785408) && (ea = { stylesheets: null, count: 0, unsuspend: VT }, B0(r), B = UT(), B !== null)) {
      l.cancelPendingCommit = B(
        sy.bind(
          null,
          l,
          r,
          m,
          c,
          f,
          O,
          S,
          v,
          k,
          D,
          1,
          Z,
          X
        )
      ), Wn(l, m, S, !C);
      return;
    }
    sy(
      l,
      r,
      m,
      c,
      f,
      O,
      S,
      v,
      k
    );
  }
  function sT(l) {
    for (var r = l; ; ) {
      var c = r.tag;
      if ((c === 0 || c === 11 || c === 15) && r.flags & 16384 && (c = r.updateQueue, c !== null && (c = c.stores, c !== null)))
        for (var f = 0; f < c.length; f++) {
          var O = c[f], m = O.getSnapshot;
          O = O.value;
          try {
            if (!Je(m(), O)) return !1;
          } catch {
            return !1;
          }
        }
      if (c = r.child, r.subtreeFlags & 16384 && c !== null)
        c.return = r, r = c;
      else {
        if (r === l) break;
        for (; r.sibling === null; ) {
          if (r.return === null || r.return === l) return !0;
          r = r.return;
        }
        r.sibling.return = r.return, r = r.sibling;
      }
    }
    return !0;
  }
  function Wn(l, r, c, f) {
    r &= ~Mh, r &= ~ql, l.suspendedLanes |= r, l.pingedLanes &= ~r, f && (l.warmLanes |= r), f = l.expirationTimes;
    for (var O = r; 0 < O; ) {
      var m = 31 - Ke(O), S = 1 << m;
      f[m] = -1, O &= ~S;
    }
    c !== 0 && cm(l, c, r);
  }
  function tc() {
    return (Zt & 6) === 0 ? (Hr(0), !1) : !0;
  }
  function _h() {
    if (wt !== null) {
      if (Et === 0)
        var l = wt.return;
      else
        l = wt, on = Tl = null, th(l), bs = null, Dr = 0, l = wt;
      for (; l !== null; )
        M0(l.alternate, l), l = l.return;
      wt = null;
    }
  }
  function As(l, r) {
    var c = l.timeoutHandle;
    c !== -1 && (l.timeoutHandle = -1, xT(c)), c = l.cancelPendingCommit, c !== null && (l.cancelPendingCommit = null, c()), _h(), jt = l, wt = c = sn(l.current, null), Pt = r, Et = 0, ei = null, Ln = !1, Ts = fr(l, r), Ah = !1, $s = mi = Mh = ql = Bn = It = 0, Ye = Nr = null, qh = !1, (r & 8) !== 0 && (r |= r & 32);
    var f = l.entangledLanes;
    if (f !== 0)
      for (l = l.entanglements, f &= r; 0 < f; ) {
        var O = 31 - Ke(f), m = 1 << O;
        r |= l[O], f &= ~m;
      }
    return mn = r, bo(), c;
  }
  function F0(l, r) {
    bt = null, E.H = Yo, r === Ar || r === Mo ? (r = mg(), Et = 3) : r === Og ? (r = mg(), Et = 4) : Et = r === g0 ? 8 : r !== null && typeof r == "object" && typeof r.then == "function" ? 6 : 1, ei = r, wt === null && (It = 1, Go(
      l,
      fi(r, l.current)
    ));
  }
  function ty() {
    var l = E.H;
    return E.H = Yo, l === null ? Yo : l;
  }
  function ey() {
    var l = E.A;
    return E.A = nT, l;
  }
  function zh() {
    It = 4, Ln || (Pt & 4194048) !== Pt && pi.current !== null || (Ts = !0), (Bn & 134217727) === 0 && (ql & 134217727) === 0 || jt === null || Wn(
      jt,
      Pt,
      mi,
      !1
    );
  }
  function Dh(l, r, c) {
    var f = Zt;
    Zt |= 2;
    var O = ty(), m = ey();
    (jt !== l || Pt !== r) && (Fo = null, As(l, r)), r = !1;
    var S = It;
    t: do
      try {
        if (Et !== 0 && wt !== null) {
          var v = wt, k = ei;
          switch (Et) {
            case 8:
              _h(), S = 6;
              break t;
            case 3:
            case 2:
            case 9:
            case 6:
              pi.current === null && (r = !0);
              var C = Et;
              if (Et = 0, ei = null, Ms(l, v, k, C), c && Ts) {
                S = 0;
                break t;
              }
              break;
            default:
              C = Et, Et = 0, ei = null, Ms(l, v, k, C);
          }
        }
        rT(), S = It;
        break;
      } catch (D) {
        F0(l, D);
      }
    while (!0);
    return r && l.shellSuspendCounter++, on = Tl = null, Zt = f, E.H = O, E.A = m, wt === null && (jt = null, Pt = 0, bo()), S;
  }
  function rT() {
    for (; wt !== null; ) iy(wt);
  }
  function aT(l, r) {
    var c = Zt;
    Zt |= 2;
    var f = ty(), O = ey();
    jt !== l || Pt !== r ? (Fo = null, Io = Mi() + 500, As(l, r)) : Ts = fr(
      l,
      r
    );
    t: do
      try {
        if (Et !== 0 && wt !== null) {
          r = wt;
          var m = ei;
          e: switch (Et) {
            case 1:
              Et = 0, ei = null, Ms(l, r, m, 1);
              break;
            case 2:
            case 9:
              if (dg(m)) {
                Et = 0, ei = null, ny(r);
                break;
              }
              r = function() {
                Et !== 2 && Et !== 9 || jt !== l || (Et = 7), Xi(l);
              }, m.then(r, r);
              break t;
            case 3:
              Et = 7;
              break t;
            case 4:
              Et = 5;
              break t;
            case 7:
              dg(m) ? (Et = 0, ei = null, ny(r)) : (Et = 0, ei = null, Ms(l, r, m, 7));
              break;
            case 5:
              var S = null;
              switch (wt.tag) {
                case 26:
                  S = wt.memoizedState;
                case 5:
                case 27:
                  var v = wt;
                  if (!S || zy(S)) {
                    Et = 0, ei = null;
                    var k = v.sibling;
                    if (k !== null) wt = k;
                    else {
                      var C = v.return;
                      C !== null ? (wt = C, ec(C)) : wt = null;
                    }
                    break e;
                  }
              }
              Et = 0, ei = null, Ms(l, r, m, 5);
              break;
            case 6:
              Et = 0, ei = null, Ms(l, r, m, 6);
              break;
            case 8:
              _h(), It = 6;
              break t;
            default:
              throw Error(i(462));
          }
        }
        oT();
        break;
      } catch (D) {
        F0(l, D);
      }
    while (!0);
    return on = Tl = null, E.H = f, E.A = O, Zt = c, wt !== null ? 0 : (jt = null, Pt = 0, bo(), It);
  }
  function oT() {
    for (; wt !== null && !Ak(); )
      iy(wt);
  }
  function iy(l) {
    var r = R0(l.alternate, l, mn);
    l.memoizedProps = l.pendingProps, r === null ? ec(l) : wt = r;
  }
  function ny(l) {
    var r = l, c = r.alternate;
    switch (r.tag) {
      case 15:
      case 0:
        r = x0(
          c,
          r,
          r.pendingProps,
          r.type,
          void 0,
          Pt
        );
        break;
      case 11:
        r = x0(
          c,
          r,
          r.pendingProps,
          r.type.render,
          r.ref,
          Pt
        );
        break;
      case 5:
        th(r);
      default:
        M0(c, r), r = wt = lg(r, mn), r = R0(c, r, mn);
    }
    l.memoizedProps = l.pendingProps, r === null ? ec(l) : wt = r;
  }
  function Ms(l, r, c, f) {
    on = Tl = null, th(r), bs = null, Dr = 0;
    var O = r.return;
    try {
      if (Jw(
        l,
        O,
        r,
        c,
        Pt
      )) {
        It = 1, Go(
          l,
          fi(c, l.current)
        ), wt = null;
        return;
      }
    } catch (m) {
      if (O !== null) throw wt = O, m;
      It = 1, Go(
        l,
        fi(c, l.current)
      ), wt = null;
      return;
    }
    r.flags & 32768 ? (Ct || f === 1 ? l = !0 : Ts || (Pt & 536870912) !== 0 ? l = !1 : (Ln = l = !0, (f === 2 || f === 9 || f === 3 || f === 6) && (f = pi.current, f !== null && f.tag === 13 && (f.flags |= 16384))), ly(r, l)) : ec(r);
  }
  function ec(l) {
    var r = l;
    do {
      if ((r.flags & 32768) !== 0) {
        ly(
          r,
          Ln
        );
        return;
      }
      l = r.return;
      var c = Fw(
        r.alternate,
        r,
        mn
      );
      if (c !== null) {
        wt = c;
        return;
      }
      if (r = r.sibling, r !== null) {
        wt = r;
        return;
      }
      wt = r = l;
    } while (r !== null);
    It === 0 && (It = 5);
  }
  function ly(l, r) {
    do {
      var c = tT(l.alternate, l);
      if (c !== null) {
        c.flags &= 32767, wt = c;
        return;
      }
      if (c = l.return, c !== null && (c.flags |= 32768, c.subtreeFlags = 0, c.deletions = null), !r && (l = l.sibling, l !== null)) {
        wt = l;
        return;
      }
      wt = l = c;
    } while (l !== null);
    It = 6, wt = null;
  }
  function sy(l, r, c, f, O, m, S, v, k) {
    l.cancelPendingCommit = null;
    do
      ic();
    while (ve !== 0);
    if ((Zt & 6) !== 0) throw Error(i(327));
    if (r !== null) {
      if (r === l.current) throw Error(i(177));
      if (m = r.lanes | r.childLanes, m |= Rf, Vk(
        l,
        c,
        m,
        S,
        v,
        k
      ), l === jt && (wt = jt = null, Pt = 0), Ps = r, Nn = l, Rs = c, Zh = m, Eh = O, H0 = f, (r.subtreeFlags & 10256) !== 0 || (r.flags & 10256) !== 0 ? (l.callbackNode = null, l.callbackPriority = 0, hT(ro, function() {
        return uy(), null;
      })) : (l.callbackNode = null, l.callbackPriority = 0), f = (r.flags & 13878) !== 0, (r.subtreeFlags & 13878) !== 0 || f) {
        f = E.T, E.T = null, O = z.p, z.p = 2, S = Zt, Zt |= 4;
        try {
          eT(l, r, c);
        } finally {
          Zt = S, z.p = O, E.T = f;
        }
      }
      ve = 1, ry(), ay(), oy();
    }
  }
  function ry() {
    if (ve === 1) {
      ve = 0;
      var l = Nn, r = Ps, c = (r.flags & 13878) !== 0;
      if ((r.subtreeFlags & 13878) !== 0 || c) {
        c = E.T, E.T = null;
        var f = z.p;
        z.p = 2;
        var O = Zt;
        Zt |= 4;
        try {
          U0(r, l);
          var m = Jh, S = Wm(l.containerInfo), v = m.focusedElem, k = m.selectionRange;
          if (S !== v && v && v.ownerDocument && Nm(
            v.ownerDocument.documentElement,
            v
          )) {
            if (k !== null && kf(v)) {
              var C = k.start, D = k.end;
              if (D === void 0 && (D = C), "selectionStart" in v)
                v.selectionStart = C, v.selectionEnd = Math.min(
                  D,
                  v.value.length
                );
              else {
                var B = v.ownerDocument || document, Z = B && B.defaultView || window;
                if (Z.getSelection) {
                  var X = Z.getSelection(), gt = v.textContent.length, dt = Math.min(k.start, gt), zt = k.end === void 0 ? dt : Math.min(k.end, gt);
                  !X.extend && dt > zt && (S = zt, zt = dt, dt = S);
                  var R = Gm(
                    v,
                    dt
                  ), $ = Gm(
                    v,
                    zt
                  );
                  if (R && $ && (X.rangeCount !== 1 || X.anchorNode !== R.node || X.anchorOffset !== R.offset || X.focusNode !== $.node || X.focusOffset !== $.offset)) {
                    var M = B.createRange();
                    M.setStart(R.node, R.offset), X.removeAllRanges(), dt > zt ? (X.addRange(M), X.extend($.node, $.offset)) : (M.setEnd($.node, $.offset), X.addRange(M));
                  }
                }
              }
            }
            for (B = [], X = v; X = X.parentNode; )
              X.nodeType === 1 && B.push({
                element: X,
                left: X.scrollLeft,
                top: X.scrollTop
              });
            for (typeof v.focus == "function" && v.focus(), v = 0; v < B.length; v++) {
              var U = B[v];
              U.element.scrollLeft = U.left, U.element.scrollTop = U.top;
            }
          }
          dc = !!Kh, Jh = Kh = null;
        } finally {
          Zt = O, z.p = f, E.T = c;
        }
      }
      l.current = r, ve = 2;
    }
  }
  function ay() {
    if (ve === 2) {
      ve = 0;
      var l = Nn, r = Ps, c = (r.flags & 8772) !== 0;
      if ((r.subtreeFlags & 8772) !== 0 || c) {
        c = E.T, E.T = null;
        var f = z.p;
        z.p = 2;
        var O = Zt;
        Zt |= 4;
        try {
          z0(l, r.alternate, r);
        } finally {
          Zt = O, z.p = f, E.T = c;
        }
      }
      ve = 3;
    }
  }
  function oy() {
    if (ve === 4 || ve === 3) {
      ve = 0, Mk();
      var l = Nn, r = Ps, c = Rs, f = H0;
      (r.subtreeFlags & 10256) !== 0 || (r.flags & 10256) !== 0 ? ve = 5 : (ve = 0, Ps = Nn = null, cy(l, l.pendingLanes));
      var O = l.pendingLanes;
      if (O === 0 && (Gn = null), nf(c), r = r.stateNode, He && typeof He.onCommitFiberRoot == "function")
        try {
          He.onCommitFiberRoot(
            ur,
            r,
            void 0,
            (r.current.flags & 128) === 128
          );
        } catch {
        }
      if (f !== null) {
        r = E.T, O = z.p, z.p = 2, E.T = null;
        try {
          for (var m = l.onRecoverableError, S = 0; S < f.length; S++) {
            var v = f[S];
            m(v.value, {
              componentStack: v.stack
            });
          }
        } finally {
          E.T = r, z.p = O;
        }
      }
      (Rs & 3) !== 0 && ic(), Xi(l), O = l.pendingLanes, (c & 4194090) !== 0 && (O & 42) !== 0 ? l === Xh ? Wr++ : (Wr = 0, Xh = l) : Wr = 0, Hr(0);
    }
  }
  function cy(l, r) {
    (l.pooledCacheLanes &= r) === 0 && (r = l.pooledCache, r != null && (l.pooledCache = null, Pr(r)));
  }
  function ic(l) {
    return ry(), ay(), oy(), uy();
  }
  function uy() {
    if (ve !== 5) return !1;
    var l = Nn, r = Zh;
    Zh = 0;
    var c = nf(Rs), f = E.T, O = z.p;
    try {
      z.p = 32 > c ? 32 : c, E.T = null, c = Eh, Eh = null;
      var m = Nn, S = Rs;
      if (ve = 0, Ps = Nn = null, Rs = 0, (Zt & 6) !== 0) throw Error(i(331));
      var v = Zt;
      if (Zt |= 4, N0(m.current), L0(
        m,
        m.current,
        S,
        c
      ), Zt = v, Hr(0, !1), He && typeof He.onPostCommitFiberRoot == "function")
        try {
          He.onPostCommitFiberRoot(ur, m);
        } catch {
        }
      return !0;
    } finally {
      z.p = O, E.T = f, cy(l, r);
    }
  }
  function fy(l, r, c) {
    r = fi(c, r), r = dh(l.stateNode, r, 2), l = _n(l, r, 2), l !== null && (hr(l, 2), Xi(l));
  }
  function Dt(l, r, c) {
    if (l.tag === 3)
      fy(l, l, c);
    else
      for (; r !== null; ) {
        if (r.tag === 3) {
          fy(
            r,
            l,
            c
          );
          break;
        } else if (r.tag === 1) {
          var f = r.stateNode;
          if (typeof r.type.getDerivedStateFromError == "function" || typeof f.componentDidCatch == "function" && (Gn === null || !Gn.has(f))) {
            l = fi(c, l), c = p0(2), f = _n(r, c, 2), f !== null && (m0(
              c,
              f,
              r,
              l
            ), hr(f, 2), Xi(f));
            break;
          }
        }
        r = r.return;
      }
  }
  function Vh(l, r, c) {
    var f = l.pingCache;
    if (f === null) {
      f = l.pingCache = new lT();
      var O = /* @__PURE__ */ new Set();
      f.set(r, O);
    } else
      O = f.get(r), O === void 0 && (O = /* @__PURE__ */ new Set(), f.set(r, O));
    O.has(c) || (Ah = !0, O.add(c), l = cT.bind(null, l, r, c), r.then(l, l));
  }
  function cT(l, r, c) {
    var f = l.pingCache;
    f !== null && f.delete(r), l.pingedLanes |= l.suspendedLanes & c, l.warmLanes &= ~c, jt === l && (Pt & c) === c && (It === 4 || It === 3 && (Pt & 62914560) === Pt && 300 > Mi() - Ch ? (Zt & 2) === 0 && As(l, 0) : Mh |= c, $s === Pt && ($s = 0)), Xi(l);
  }
  function hy(l, r) {
    r === 0 && (r = om()), l = hs(l, r), l !== null && (hr(l, r), Xi(l));
  }
  function uT(l) {
    var r = l.memoizedState, c = 0;
    r !== null && (c = r.retryLane), hy(l, c);
  }
  function fT(l, r) {
    var c = 0;
    switch (l.tag) {
      case 13:
        var f = l.stateNode, O = l.memoizedState;
        O !== null && (c = O.retryLane);
        break;
      case 19:
        f = l.stateNode;
        break;
      case 22:
        f = l.stateNode._retryCache;
        break;
      default:
        throw Error(i(314));
    }
    f !== null && f.delete(r), hy(l, c);
  }
  function hT(l, r) {
    return Iu(l, r);
  }
  var nc = null, qs = null, Yh = !1, lc = !1, Uh = !1, Cl = 0;
  function Xi(l) {
    l !== qs && l.next === null && (qs === null ? nc = qs = l : qs = qs.next = l), lc = !0, Yh || (Yh = !0, dT());
  }
  function Hr(l, r) {
    if (!Uh && lc) {
      Uh = !0;
      do
        for (var c = !1, f = nc; f !== null; ) {
          if (l !== 0) {
            var O = f.pendingLanes;
            if (O === 0) var m = 0;
            else {
              var S = f.suspendedLanes, v = f.pingedLanes;
              m = (1 << 31 - Ke(42 | l) + 1) - 1, m &= O & ~(S & ~v), m = m & 201326741 ? m & 201326741 | 1 : m ? m | 2 : 0;
            }
            m !== 0 && (c = !0, my(f, m));
          } else
            m = Pt, m = co(
              f,
              f === jt ? m : 0,
              f.cancelPendingCommit !== null || f.timeoutHandle !== -1
            ), (m & 3) === 0 || fr(f, m) || (c = !0, my(f, m));
          f = f.next;
        }
      while (c);
      Uh = !1;
    }
  }
  function OT() {
    Oy();
  }
  function Oy() {
    lc = Yh = !1;
    var l = 0;
    Cl !== 0 && (bT() && (l = Cl), Cl = 0);
    for (var r = Mi(), c = null, f = nc; f !== null; ) {
      var O = f.next, m = dy(f, r);
      m === 0 ? (f.next = null, c === null ? nc = O : c.next = O, O === null && (qs = c)) : (c = f, (l !== 0 || (m & 3) !== 0) && (lc = !0)), f = O;
    }
    Hr(l);
  }
  function dy(l, r) {
    for (var c = l.suspendedLanes, f = l.pingedLanes, O = l.expirationTimes, m = l.pendingLanes & -62914561; 0 < m; ) {
      var S = 31 - Ke(m), v = 1 << S, k = O[S];
      k === -1 ? ((v & c) === 0 || (v & f) !== 0) && (O[S] = Dk(v, r)) : k <= r && (l.expiredLanes |= v), m &= ~v;
    }
    if (r = jt, c = Pt, c = co(
      l,
      l === r ? c : 0,
      l.cancelPendingCommit !== null || l.timeoutHandle !== -1
    ), f = l.callbackNode, c === 0 || l === r && (Et === 2 || Et === 9) || l.cancelPendingCommit !== null)
      return f !== null && f !== null && Fu(f), l.callbackNode = null, l.callbackPriority = 0;
    if ((c & 3) === 0 || fr(l, c)) {
      if (r = c & -c, r === l.callbackPriority) return r;
      switch (f !== null && Fu(f), nf(c)) {
        case 2:
        case 8:
          c = sm;
          break;
        case 32:
          c = ro;
          break;
        case 268435456:
          c = rm;
          break;
        default:
          c = ro;
      }
      return f = py.bind(null, l), c = Iu(c, f), l.callbackPriority = r, l.callbackNode = c, r;
    }
    return f !== null && f !== null && Fu(f), l.callbackPriority = 2, l.callbackNode = null, 2;
  }
  function py(l, r) {
    if (ve !== 0 && ve !== 5)
      return l.callbackNode = null, l.callbackPriority = 0, null;
    var c = l.callbackNode;
    if (ic() && l.callbackNode !== c)
      return null;
    var f = Pt;
    return f = co(
      l,
      l === jt ? f : 0,
      l.cancelPendingCommit !== null || l.timeoutHandle !== -1
    ), f === 0 ? null : (J0(l, f, r), dy(l, Mi()), l.callbackNode != null && l.callbackNode === c ? py.bind(null, l) : null);
  }
  function my(l, r) {
    if (ic()) return null;
    J0(l, r, !0);
  }
  function dT() {
    kT(function() {
      (Zt & 6) !== 0 ? Iu(
        lm,
        OT
      ) : Oy();
    });
  }
  function jh() {
    return Cl === 0 && (Cl = am()), Cl;
  }
  function gy(l) {
    return l == null || typeof l == "symbol" || typeof l == "boolean" ? null : typeof l == "function" ? l : po("" + l);
  }
  function yy(l, r) {
    var c = r.ownerDocument.createElement("input");
    return c.name = r.name, c.value = r.value, l.id && c.setAttribute("form", l.id), r.parentNode.insertBefore(c, r), l = new FormData(l), c.parentNode.removeChild(c), l;
  }
  function pT(l, r, c, f, O) {
    if (r === "submit" && c && c.stateNode === O) {
      var m = gy(
        (O[_e] || null).action
      ), S = f.submitter;
      S && (r = (r = S[_e] || null) ? gy(r.formAction) : S.getAttribute("formAction"), r !== null && (m = r, S = null));
      var v = new So(
        "action",
        "action",
        null,
        f,
        O
      );
      l.push({
        event: v,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (f.defaultPrevented) {
                if (Cl !== 0) {
                  var k = S ? yy(O, S) : new FormData(O);
                  ch(
                    c,
                    {
                      pending: !0,
                      data: k,
                      method: O.method,
                      action: m
                    },
                    null,
                    k
                  );
                }
              } else
                typeof m == "function" && (v.preventDefault(), k = S ? yy(O, S) : new FormData(O), ch(
                  c,
                  {
                    pending: !0,
                    data: k,
                    method: O.method,
                    action: m
                  },
                  m,
                  k
                ));
            },
            currentTarget: O
          }
        ]
      });
    }
  }
  for (var Lh = 0; Lh < Pf.length; Lh++) {
    var Bh = Pf[Lh], mT = Bh.toLowerCase(), gT = Bh[0].toUpperCase() + Bh.slice(1);
    ki(
      mT,
      "on" + gT
    );
  }
  ki(Jm, "onAnimationEnd"), ki(Im, "onAnimationIteration"), ki(Fm, "onAnimationStart"), ki("dblclick", "onDoubleClick"), ki("focusin", "onFocus"), ki("focusout", "onBlur"), ki(Zw, "onTransitionRun"), ki(Ew, "onTransitionStart"), ki(Xw, "onTransitionCancel"), ki(tg, "onTransitionEnd"), is("onMouseEnter", ["mouseout", "mouseover"]), is("onMouseLeave", ["mouseout", "mouseover"]), is("onPointerEnter", ["pointerout", "pointerover"]), is("onPointerLeave", ["pointerout", "pointerover"]), gl(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  ), gl(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  ), gl("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]), gl(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  ), gl(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  ), gl(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var Kr = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), yT = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Kr)
  );
  function Sy(l, r) {
    r = (r & 4) !== 0;
    for (var c = 0; c < l.length; c++) {
      var f = l[c], O = f.event;
      f = f.listeners;
      t: {
        var m = void 0;
        if (r)
          for (var S = f.length - 1; 0 <= S; S--) {
            var v = f[S], k = v.instance, C = v.currentTarget;
            if (v = v.listener, k !== m && O.isPropagationStopped())
              break t;
            m = v, O.currentTarget = C;
            try {
              m(O);
            } catch (D) {
              Bo(D);
            }
            O.currentTarget = null, m = k;
          }
        else
          for (S = 0; S < f.length; S++) {
            if (v = f[S], k = v.instance, C = v.currentTarget, v = v.listener, k !== m && O.isPropagationStopped())
              break t;
            m = v, O.currentTarget = C;
            try {
              m(O);
            } catch (D) {
              Bo(D);
            }
            O.currentTarget = null, m = k;
          }
      }
    }
  }
  function Tt(l, r) {
    var c = r[lf];
    c === void 0 && (c = r[lf] = /* @__PURE__ */ new Set());
    var f = l + "__bubble";
    c.has(f) || (Qy(r, l, 2, !1), c.add(f));
  }
  function Gh(l, r, c) {
    var f = 0;
    r && (f |= 4), Qy(
      c,
      l,
      f,
      r
    );
  }
  var sc = "_reactListening" + Math.random().toString(36).slice(2);
  function Nh(l) {
    if (!l[sc]) {
      l[sc] = !0, Om.forEach(function(c) {
        c !== "selectionchange" && (yT.has(c) || Gh(c, !1, l), Gh(c, !0, l));
      });
      var r = l.nodeType === 9 ? l : l.ownerDocument;
      r === null || r[sc] || (r[sc] = !0, Gh("selectionchange", !1, r));
    }
  }
  function Qy(l, r, c, f) {
    switch (Ly(r)) {
      case 2:
        var O = BT;
        break;
      case 8:
        O = GT;
        break;
      default:
        O = aO;
    }
    c = O.bind(
      null,
      r,
      c,
      l
    ), O = void 0, !pf || r !== "touchstart" && r !== "touchmove" && r !== "wheel" || (O = !0), f ? O !== void 0 ? l.addEventListener(r, c, {
      capture: !0,
      passive: O
    }) : l.addEventListener(r, c, !0) : O !== void 0 ? l.addEventListener(r, c, {
      passive: O
    }) : l.addEventListener(r, c, !1);
  }
  function Wh(l, r, c, f, O) {
    var m = f;
    if ((r & 1) === 0 && (r & 2) === 0 && f !== null)
      t: for (; ; ) {
        if (f === null) return;
        var S = f.tag;
        if (S === 3 || S === 4) {
          var v = f.stateNode.containerInfo;
          if (v === O) break;
          if (S === 4)
            for (S = f.return; S !== null; ) {
              var k = S.tag;
              if ((k === 3 || k === 4) && S.stateNode.containerInfo === O)
                return;
              S = S.return;
            }
          for (; v !== null; ) {
            if (S = Fl(v), S === null) return;
            if (k = S.tag, k === 5 || k === 6 || k === 26 || k === 27) {
              f = m = S;
              continue t;
            }
            v = v.parentNode;
          }
        }
        f = f.return;
      }
    $m(function() {
      var C = m, D = Of(c), B = [];
      t: {
        var Z = eg.get(l);
        if (Z !== void 0) {
          var X = So, gt = l;
          switch (l) {
            case "keypress":
              if (go(c) === 0) break t;
            case "keydown":
            case "keyup":
              X = hw;
              break;
            case "focusin":
              gt = "focus", X = Sf;
              break;
            case "focusout":
              gt = "blur", X = Sf;
              break;
            case "beforeblur":
            case "afterblur":
              X = Sf;
              break;
            case "click":
              if (c.button === 2) break t;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              X = Am;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              X = tw;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              X = pw;
              break;
            case Jm:
            case Im:
            case Fm:
              X = nw;
              break;
            case tg:
              X = gw;
              break;
            case "scroll":
            case "scrollend":
              X = Ik;
              break;
            case "wheel":
              X = Sw;
              break;
            case "copy":
            case "cut":
            case "paste":
              X = sw;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              X = qm;
              break;
            case "toggle":
            case "beforetoggle":
              X = vw;
          }
          var dt = (r & 4) !== 0, zt = !dt && (l === "scroll" || l === "scrollend"), R = dt ? Z !== null ? Z + "Capture" : null : Z;
          dt = [];
          for (var $ = C, M; $ !== null; ) {
            var U = $;
            if (M = U.stateNode, U = U.tag, U !== 5 && U !== 26 && U !== 27 || M === null || R === null || (U = pr($, R), U != null && dt.push(
              Jr($, U, M)
            )), zt) break;
            $ = $.return;
          }
          0 < dt.length && (Z = new X(
            Z,
            gt,
            null,
            c,
            D
          ), B.push({ event: Z, listeners: dt }));
        }
      }
      if ((r & 7) === 0) {
        t: {
          if (Z = l === "mouseover" || l === "pointerover", X = l === "mouseout" || l === "pointerout", Z && c !== hf && (gt = c.relatedTarget || c.fromElement) && (Fl(gt) || gt[Il]))
            break t;
          if ((X || Z) && (Z = D.window === D ? D : (Z = D.ownerDocument) ? Z.defaultView || Z.parentWindow : window, X ? (gt = c.relatedTarget || c.toElement, X = C, gt = gt ? Fl(gt) : null, gt !== null && (zt = a(gt), dt = gt.tag, gt !== zt || dt !== 5 && dt !== 27 && dt !== 6) && (gt = null)) : (X = null, gt = C), X !== gt)) {
            if (dt = Am, U = "onMouseLeave", R = "onMouseEnter", $ = "mouse", (l === "pointerout" || l === "pointerover") && (dt = qm, U = "onPointerLeave", R = "onPointerEnter", $ = "pointer"), zt = X == null ? Z : dr(X), M = gt == null ? Z : dr(gt), Z = new dt(
              U,
              $ + "leave",
              X,
              c,
              D
            ), Z.target = zt, Z.relatedTarget = M, U = null, Fl(D) === C && (dt = new dt(
              R,
              $ + "enter",
              gt,
              c,
              D
            ), dt.target = M, dt.relatedTarget = zt, U = dt), zt = U, X && gt)
              e: {
                for (dt = X, R = gt, $ = 0, M = dt; M; M = Cs(M))
                  $++;
                for (M = 0, U = R; U; U = Cs(U))
                  M++;
                for (; 0 < $ - M; )
                  dt = Cs(dt), $--;
                for (; 0 < M - $; )
                  R = Cs(R), M--;
                for (; $--; ) {
                  if (dt === R || R !== null && dt === R.alternate)
                    break e;
                  dt = Cs(dt), R = Cs(R);
                }
                dt = null;
              }
            else dt = null;
            X !== null && vy(
              B,
              Z,
              X,
              dt,
              !1
            ), gt !== null && zt !== null && vy(
              B,
              zt,
              gt,
              dt,
              !0
            );
          }
        }
        t: {
          if (Z = C ? dr(C) : window, X = Z.nodeName && Z.nodeName.toLowerCase(), X === "select" || X === "input" && Z.type === "file")
            var rt = Vm;
          else if (zm(Z))
            if (Ym)
              rt = Mw;
            else {
              rt = Rw;
              var xt = Pw;
            }
          else
            X = Z.nodeName, !X || X.toLowerCase() !== "input" || Z.type !== "checkbox" && Z.type !== "radio" ? C && ff(C.elementType) && (rt = Vm) : rt = Aw;
          if (rt && (rt = rt(l, C))) {
            Dm(
              B,
              rt,
              c,
              D
            );
            break t;
          }
          xt && xt(l, Z, C), l === "focusout" && C && Z.type === "number" && C.memoizedProps.value != null && uf(Z, "number", Z.value);
        }
        switch (xt = C ? dr(C) : window, l) {
          case "focusin":
            (zm(xt) || xt.contentEditable === "true") && (cs = xt, wf = C, xr = null);
            break;
          case "focusout":
            xr = wf = cs = null;
            break;
          case "mousedown":
            Tf = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Tf = !1, Hm(B, c, D);
            break;
          case "selectionchange":
            if (Cw) break;
          case "keydown":
          case "keyup":
            Hm(B, c, D);
        }
        var ut;
        if (vf)
          t: {
            switch (l) {
              case "compositionstart":
                var pt = "onCompositionStart";
                break t;
              case "compositionend":
                pt = "onCompositionEnd";
                break t;
              case "compositionupdate":
                pt = "onCompositionUpdate";
                break t;
            }
            pt = void 0;
          }
        else
          os ? Xm(l, c) && (pt = "onCompositionEnd") : l === "keydown" && c.keyCode === 229 && (pt = "onCompositionStart");
        pt && (Cm && c.locale !== "ko" && (os || pt !== "onCompositionStart" ? pt === "onCompositionEnd" && os && (ut = Pm()) : (Cn = D, mf = "value" in Cn ? Cn.value : Cn.textContent, os = !0)), xt = rc(C, pt), 0 < xt.length && (pt = new Mm(
          pt,
          l,
          null,
          c,
          D
        ), B.push({ event: pt, listeners: xt }), ut ? pt.data = ut : (ut = _m(c), ut !== null && (pt.data = ut)))), (ut = xw ? kw(l, c) : ww(l, c)) && (pt = rc(C, "onBeforeInput"), 0 < pt.length && (xt = new Mm(
          "onBeforeInput",
          "beforeinput",
          null,
          c,
          D
        ), B.push({
          event: xt,
          listeners: pt
        }), xt.data = ut)), pT(
          B,
          l,
          C,
          c,
          D
        );
      }
      Sy(B, r);
    });
  }
  function Jr(l, r, c) {
    return {
      instance: l,
      listener: r,
      currentTarget: c
    };
  }
  function rc(l, r) {
    for (var c = r + "Capture", f = []; l !== null; ) {
      var O = l, m = O.stateNode;
      if (O = O.tag, O !== 5 && O !== 26 && O !== 27 || m === null || (O = pr(l, c), O != null && f.unshift(
        Jr(l, O, m)
      ), O = pr(l, r), O != null && f.push(
        Jr(l, O, m)
      )), l.tag === 3) return f;
      l = l.return;
    }
    return [];
  }
  function Cs(l) {
    if (l === null) return null;
    do
      l = l.return;
    while (l && l.tag !== 5 && l.tag !== 27);
    return l || null;
  }
  function vy(l, r, c, f, O) {
    for (var m = r._reactName, S = []; c !== null && c !== f; ) {
      var v = c, k = v.alternate, C = v.stateNode;
      if (v = v.tag, k !== null && k === f) break;
      v !== 5 && v !== 26 && v !== 27 || C === null || (k = C, O ? (C = pr(c, m), C != null && S.unshift(
        Jr(c, C, k)
      )) : O || (C = pr(c, m), C != null && S.push(
        Jr(c, C, k)
      ))), c = c.return;
    }
    S.length !== 0 && l.push({ event: r, listeners: S });
  }
  var ST = /\r\n?/g, QT = /\u0000|\uFFFD/g;
  function by(l) {
    return (typeof l == "string" ? l : "" + l).replace(ST, `
`).replace(QT, "");
  }
  function xy(l, r) {
    return r = by(r), by(l) === r;
  }
  function ac() {
  }
  function _t(l, r, c, f, O, m) {
    switch (c) {
      case "children":
        typeof f == "string" ? r === "body" || r === "textarea" && f === "" || ss(l, f) : (typeof f == "number" || typeof f == "bigint") && r !== "body" && ss(l, "" + f);
        break;
      case "className":
        fo(l, "class", f);
        break;
      case "tabIndex":
        fo(l, "tabindex", f);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        fo(l, c, f);
        break;
      case "style":
        wm(l, f, m);
        break;
      case "data":
        if (r !== "object") {
          fo(l, "data", f);
          break;
        }
      case "src":
      case "href":
        if (f === "" && (r !== "a" || c !== "href")) {
          l.removeAttribute(c);
          break;
        }
        if (f == null || typeof f == "function" || typeof f == "symbol" || typeof f == "boolean") {
          l.removeAttribute(c);
          break;
        }
        f = po("" + f), l.setAttribute(c, f);
        break;
      case "action":
      case "formAction":
        if (typeof f == "function") {
          l.setAttribute(
            c,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof m == "function" && (c === "formAction" ? (r !== "input" && _t(l, r, "name", O.name, O, null), _t(
            l,
            r,
            "formEncType",
            O.formEncType,
            O,
            null
          ), _t(
            l,
            r,
            "formMethod",
            O.formMethod,
            O,
            null
          ), _t(
            l,
            r,
            "formTarget",
            O.formTarget,
            O,
            null
          )) : (_t(l, r, "encType", O.encType, O, null), _t(l, r, "method", O.method, O, null), _t(l, r, "target", O.target, O, null)));
        if (f == null || typeof f == "symbol" || typeof f == "boolean") {
          l.removeAttribute(c);
          break;
        }
        f = po("" + f), l.setAttribute(c, f);
        break;
      case "onClick":
        f != null && (l.onclick = ac);
        break;
      case "onScroll":
        f != null && Tt("scroll", l);
        break;
      case "onScrollEnd":
        f != null && Tt("scrollend", l);
        break;
      case "dangerouslySetInnerHTML":
        if (f != null) {
          if (typeof f != "object" || !("__html" in f))
            throw Error(i(61));
          if (c = f.__html, c != null) {
            if (O.children != null) throw Error(i(60));
            l.innerHTML = c;
          }
        }
        break;
      case "multiple":
        l.multiple = f && typeof f != "function" && typeof f != "symbol";
        break;
      case "muted":
        l.muted = f && typeof f != "function" && typeof f != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (f == null || typeof f == "function" || typeof f == "boolean" || typeof f == "symbol") {
          l.removeAttribute("xlink:href");
          break;
        }
        c = po("" + f), l.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          c
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        f != null && typeof f != "function" && typeof f != "symbol" ? l.setAttribute(c, "" + f) : l.removeAttribute(c);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        f && typeof f != "function" && typeof f != "symbol" ? l.setAttribute(c, "") : l.removeAttribute(c);
        break;
      case "capture":
      case "download":
        f === !0 ? l.setAttribute(c, "") : f !== !1 && f != null && typeof f != "function" && typeof f != "symbol" ? l.setAttribute(c, f) : l.removeAttribute(c);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        f != null && typeof f != "function" && typeof f != "symbol" && !isNaN(f) && 1 <= f ? l.setAttribute(c, f) : l.removeAttribute(c);
        break;
      case "rowSpan":
      case "start":
        f == null || typeof f == "function" || typeof f == "symbol" || isNaN(f) ? l.removeAttribute(c) : l.setAttribute(c, f);
        break;
      case "popover":
        Tt("beforetoggle", l), Tt("toggle", l), uo(l, "popover", f);
        break;
      case "xlinkActuate":
        nn(
          l,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          f
        );
        break;
      case "xlinkArcrole":
        nn(
          l,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          f
        );
        break;
      case "xlinkRole":
        nn(
          l,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          f
        );
        break;
      case "xlinkShow":
        nn(
          l,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          f
        );
        break;
      case "xlinkTitle":
        nn(
          l,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          f
        );
        break;
      case "xlinkType":
        nn(
          l,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          f
        );
        break;
      case "xmlBase":
        nn(
          l,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          f
        );
        break;
      case "xmlLang":
        nn(
          l,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          f
        );
        break;
      case "xmlSpace":
        nn(
          l,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          f
        );
        break;
      case "is":
        uo(l, "is", f);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < c.length) || c[0] !== "o" && c[0] !== "O" || c[1] !== "n" && c[1] !== "N") && (c = Kk.get(c) || c, uo(l, c, f));
    }
  }
  function Hh(l, r, c, f, O, m) {
    switch (c) {
      case "style":
        wm(l, f, m);
        break;
      case "dangerouslySetInnerHTML":
        if (f != null) {
          if (typeof f != "object" || !("__html" in f))
            throw Error(i(61));
          if (c = f.__html, c != null) {
            if (O.children != null) throw Error(i(60));
            l.innerHTML = c;
          }
        }
        break;
      case "children":
        typeof f == "string" ? ss(l, f) : (typeof f == "number" || typeof f == "bigint") && ss(l, "" + f);
        break;
      case "onScroll":
        f != null && Tt("scroll", l);
        break;
      case "onScrollEnd":
        f != null && Tt("scrollend", l);
        break;
      case "onClick":
        f != null && (l.onclick = ac);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!dm.hasOwnProperty(c))
          t: {
            if (c[0] === "o" && c[1] === "n" && (O = c.endsWith("Capture"), r = c.slice(2, O ? c.length - 7 : void 0), m = l[_e] || null, m = m != null ? m[c] : null, typeof m == "function" && l.removeEventListener(r, m, O), typeof f == "function")) {
              typeof m != "function" && m !== null && (c in l ? l[c] = null : l.hasAttribute(c) && l.removeAttribute(c)), l.addEventListener(r, f, O);
              break t;
            }
            c in l ? l[c] = f : f === !0 ? l.setAttribute(c, "") : uo(l, c, f);
          }
    }
  }
  function be(l, r, c) {
    switch (r) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        Tt("error", l), Tt("load", l);
        var f = !1, O = !1, m;
        for (m in c)
          if (c.hasOwnProperty(m)) {
            var S = c[m];
            if (S != null)
              switch (m) {
                case "src":
                  f = !0;
                  break;
                case "srcSet":
                  O = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(i(137, r));
                default:
                  _t(l, r, m, S, c, null);
              }
          }
        O && _t(l, r, "srcSet", c.srcSet, c, null), f && _t(l, r, "src", c.src, c, null);
        return;
      case "input":
        Tt("invalid", l);
        var v = m = S = O = null, k = null, C = null;
        for (f in c)
          if (c.hasOwnProperty(f)) {
            var D = c[f];
            if (D != null)
              switch (f) {
                case "name":
                  O = D;
                  break;
                case "type":
                  S = D;
                  break;
                case "checked":
                  k = D;
                  break;
                case "defaultChecked":
                  C = D;
                  break;
                case "value":
                  m = D;
                  break;
                case "defaultValue":
                  v = D;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (D != null)
                    throw Error(i(137, r));
                  break;
                default:
                  _t(l, r, f, D, c, null);
              }
          }
        vm(
          l,
          m,
          v,
          k,
          C,
          S,
          O,
          !1
        ), ho(l);
        return;
      case "select":
        Tt("invalid", l), f = S = m = null;
        for (O in c)
          if (c.hasOwnProperty(O) && (v = c[O], v != null))
            switch (O) {
              case "value":
                m = v;
                break;
              case "defaultValue":
                S = v;
                break;
              case "multiple":
                f = v;
              default:
                _t(l, r, O, v, c, null);
            }
        r = m, c = S, l.multiple = !!f, r != null ? ls(l, !!f, r, !1) : c != null && ls(l, !!f, c, !0);
        return;
      case "textarea":
        Tt("invalid", l), m = O = f = null;
        for (S in c)
          if (c.hasOwnProperty(S) && (v = c[S], v != null))
            switch (S) {
              case "value":
                f = v;
                break;
              case "defaultValue":
                O = v;
                break;
              case "children":
                m = v;
                break;
              case "dangerouslySetInnerHTML":
                if (v != null) throw Error(i(91));
                break;
              default:
                _t(l, r, S, v, c, null);
            }
        xm(l, f, O, m), ho(l);
        return;
      case "option":
        for (k in c)
          if (c.hasOwnProperty(k) && (f = c[k], f != null))
            switch (k) {
              case "selected":
                l.selected = f && typeof f != "function" && typeof f != "symbol";
                break;
              default:
                _t(l, r, k, f, c, null);
            }
        return;
      case "dialog":
        Tt("beforetoggle", l), Tt("toggle", l), Tt("cancel", l), Tt("close", l);
        break;
      case "iframe":
      case "object":
        Tt("load", l);
        break;
      case "video":
      case "audio":
        for (f = 0; f < Kr.length; f++)
          Tt(Kr[f], l);
        break;
      case "image":
        Tt("error", l), Tt("load", l);
        break;
      case "details":
        Tt("toggle", l);
        break;
      case "embed":
      case "source":
      case "link":
        Tt("error", l), Tt("load", l);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (C in c)
          if (c.hasOwnProperty(C) && (f = c[C], f != null))
            switch (C) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(i(137, r));
              default:
                _t(l, r, C, f, c, null);
            }
        return;
      default:
        if (ff(r)) {
          for (D in c)
            c.hasOwnProperty(D) && (f = c[D], f !== void 0 && Hh(
              l,
              r,
              D,
              f,
              c,
              void 0
            ));
          return;
        }
    }
    for (v in c)
      c.hasOwnProperty(v) && (f = c[v], f != null && _t(l, r, v, f, c, null));
  }
  function vT(l, r, c, f) {
    switch (r) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var O = null, m = null, S = null, v = null, k = null, C = null, D = null;
        for (X in c) {
          var B = c[X];
          if (c.hasOwnProperty(X) && B != null)
            switch (X) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                k = B;
              default:
                f.hasOwnProperty(X) || _t(l, r, X, null, f, B);
            }
        }
        for (var Z in f) {
          var X = f[Z];
          if (B = c[Z], f.hasOwnProperty(Z) && (X != null || B != null))
            switch (Z) {
              case "type":
                m = X;
                break;
              case "name":
                O = X;
                break;
              case "checked":
                C = X;
                break;
              case "defaultChecked":
                D = X;
                break;
              case "value":
                S = X;
                break;
              case "defaultValue":
                v = X;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (X != null)
                  throw Error(i(137, r));
                break;
              default:
                X !== B && _t(
                  l,
                  r,
                  Z,
                  X,
                  f,
                  B
                );
            }
        }
        cf(
          l,
          S,
          v,
          k,
          C,
          D,
          m,
          O
        );
        return;
      case "select":
        X = S = v = Z = null;
        for (m in c)
          if (k = c[m], c.hasOwnProperty(m) && k != null)
            switch (m) {
              case "value":
                break;
              case "multiple":
                X = k;
              default:
                f.hasOwnProperty(m) || _t(
                  l,
                  r,
                  m,
                  null,
                  f,
                  k
                );
            }
        for (O in f)
          if (m = f[O], k = c[O], f.hasOwnProperty(O) && (m != null || k != null))
            switch (O) {
              case "value":
                Z = m;
                break;
              case "defaultValue":
                v = m;
                break;
              case "multiple":
                S = m;
              default:
                m !== k && _t(
                  l,
                  r,
                  O,
                  m,
                  f,
                  k
                );
            }
        r = v, c = S, f = X, Z != null ? ls(l, !!c, Z, !1) : !!f != !!c && (r != null ? ls(l, !!c, r, !0) : ls(l, !!c, c ? [] : "", !1));
        return;
      case "textarea":
        X = Z = null;
        for (v in c)
          if (O = c[v], c.hasOwnProperty(v) && O != null && !f.hasOwnProperty(v))
            switch (v) {
              case "value":
                break;
              case "children":
                break;
              default:
                _t(l, r, v, null, f, O);
            }
        for (S in f)
          if (O = f[S], m = c[S], f.hasOwnProperty(S) && (O != null || m != null))
            switch (S) {
              case "value":
                Z = O;
                break;
              case "defaultValue":
                X = O;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (O != null) throw Error(i(91));
                break;
              default:
                O !== m && _t(l, r, S, O, f, m);
            }
        bm(l, Z, X);
        return;
      case "option":
        for (var gt in c)
          if (Z = c[gt], c.hasOwnProperty(gt) && Z != null && !f.hasOwnProperty(gt))
            switch (gt) {
              case "selected":
                l.selected = !1;
                break;
              default:
                _t(
                  l,
                  r,
                  gt,
                  null,
                  f,
                  Z
                );
            }
        for (k in f)
          if (Z = f[k], X = c[k], f.hasOwnProperty(k) && Z !== X && (Z != null || X != null))
            switch (k) {
              case "selected":
                l.selected = Z && typeof Z != "function" && typeof Z != "symbol";
                break;
              default:
                _t(
                  l,
                  r,
                  k,
                  Z,
                  f,
                  X
                );
            }
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var dt in c)
          Z = c[dt], c.hasOwnProperty(dt) && Z != null && !f.hasOwnProperty(dt) && _t(l, r, dt, null, f, Z);
        for (C in f)
          if (Z = f[C], X = c[C], f.hasOwnProperty(C) && Z !== X && (Z != null || X != null))
            switch (C) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (Z != null)
                  throw Error(i(137, r));
                break;
              default:
                _t(
                  l,
                  r,
                  C,
                  Z,
                  f,
                  X
                );
            }
        return;
      default:
        if (ff(r)) {
          for (var zt in c)
            Z = c[zt], c.hasOwnProperty(zt) && Z !== void 0 && !f.hasOwnProperty(zt) && Hh(
              l,
              r,
              zt,
              void 0,
              f,
              Z
            );
          for (D in f)
            Z = f[D], X = c[D], !f.hasOwnProperty(D) || Z === X || Z === void 0 && X === void 0 || Hh(
              l,
              r,
              D,
              Z,
              f,
              X
            );
          return;
        }
    }
    for (var R in c)
      Z = c[R], c.hasOwnProperty(R) && Z != null && !f.hasOwnProperty(R) && _t(l, r, R, null, f, Z);
    for (B in f)
      Z = f[B], X = c[B], !f.hasOwnProperty(B) || Z === X || Z == null && X == null || _t(l, r, B, Z, f, X);
  }
  var Kh = null, Jh = null;
  function oc(l) {
    return l.nodeType === 9 ? l : l.ownerDocument;
  }
  function ky(l) {
    switch (l) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function wy(l, r) {
    if (l === 0)
      switch (r) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return l === 1 && r === "foreignObject" ? 0 : l;
  }
  function Ih(l, r) {
    return l === "textarea" || l === "noscript" || typeof r.children == "string" || typeof r.children == "number" || typeof r.children == "bigint" || typeof r.dangerouslySetInnerHTML == "object" && r.dangerouslySetInnerHTML !== null && r.dangerouslySetInnerHTML.__html != null;
  }
  var Fh = null;
  function bT() {
    var l = window.event;
    return l && l.type === "popstate" ? l === Fh ? !1 : (Fh = l, !0) : (Fh = null, !1);
  }
  var Ty = typeof setTimeout == "function" ? setTimeout : void 0, xT = typeof clearTimeout == "function" ? clearTimeout : void 0, $y = typeof Promise == "function" ? Promise : void 0, kT = typeof queueMicrotask == "function" ? queueMicrotask : typeof $y < "u" ? function(l) {
    return $y.resolve(null).then(l).catch(wT);
  } : Ty;
  function wT(l) {
    setTimeout(function() {
      throw l;
    });
  }
  function Hn(l) {
    return l === "head";
  }
  function Py(l, r) {
    var c = r, f = 0, O = 0;
    do {
      var m = c.nextSibling;
      if (l.removeChild(c), m && m.nodeType === 8)
        if (c = m.data, c === "/$") {
          if (0 < f && 8 > f) {
            c = f;
            var S = l.ownerDocument;
            if (c & 1 && Ir(S.documentElement), c & 2 && Ir(S.body), c & 4)
              for (c = S.head, Ir(c), S = c.firstChild; S; ) {
                var v = S.nextSibling, k = S.nodeName;
                S[Or] || k === "SCRIPT" || k === "STYLE" || k === "LINK" && S.rel.toLowerCase() === "stylesheet" || c.removeChild(S), S = v;
              }
          }
          if (O === 0) {
            l.removeChild(m), ra(r);
            return;
          }
          O--;
        } else
          c === "$" || c === "$?" || c === "$!" ? O++ : f = c.charCodeAt(0) - 48;
      else f = 0;
      c = m;
    } while (c);
    ra(r);
  }
  function tO(l) {
    var r = l.firstChild;
    for (r && r.nodeType === 10 && (r = r.nextSibling); r; ) {
      var c = r;
      switch (r = r.nextSibling, c.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          tO(c), sf(c);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (c.rel.toLowerCase() === "stylesheet") continue;
      }
      l.removeChild(c);
    }
  }
  function TT(l, r, c, f) {
    for (; l.nodeType === 1; ) {
      var O = c;
      if (l.nodeName.toLowerCase() !== r.toLowerCase()) {
        if (!f && (l.nodeName !== "INPUT" || l.type !== "hidden"))
          break;
      } else if (f) {
        if (!l[Or])
          switch (r) {
            case "meta":
              if (!l.hasAttribute("itemprop")) break;
              return l;
            case "link":
              if (m = l.getAttribute("rel"), m === "stylesheet" && l.hasAttribute("data-precedence"))
                break;
              if (m !== O.rel || l.getAttribute("href") !== (O.href == null || O.href === "" ? null : O.href) || l.getAttribute("crossorigin") !== (O.crossOrigin == null ? null : O.crossOrigin) || l.getAttribute("title") !== (O.title == null ? null : O.title))
                break;
              return l;
            case "style":
              if (l.hasAttribute("data-precedence")) break;
              return l;
            case "script":
              if (m = l.getAttribute("src"), (m !== (O.src == null ? null : O.src) || l.getAttribute("type") !== (O.type == null ? null : O.type) || l.getAttribute("crossorigin") !== (O.crossOrigin == null ? null : O.crossOrigin)) && m && l.hasAttribute("async") && !l.hasAttribute("itemprop"))
                break;
              return l;
            default:
              return l;
          }
      } else if (r === "input" && l.type === "hidden") {
        var m = O.name == null ? null : "" + O.name;
        if (O.type === "hidden" && l.getAttribute("name") === m)
          return l;
      } else return l;
      if (l = Ti(l.nextSibling), l === null) break;
    }
    return null;
  }
  function $T(l, r, c) {
    if (r === "") return null;
    for (; l.nodeType !== 3; )
      if ((l.nodeType !== 1 || l.nodeName !== "INPUT" || l.type !== "hidden") && !c || (l = Ti(l.nextSibling), l === null)) return null;
    return l;
  }
  function eO(l) {
    return l.data === "$!" || l.data === "$?" && l.ownerDocument.readyState === "complete";
  }
  function PT(l, r) {
    var c = l.ownerDocument;
    if (l.data !== "$?" || c.readyState === "complete")
      r();
    else {
      var f = function() {
        r(), c.removeEventListener("DOMContentLoaded", f);
      };
      c.addEventListener("DOMContentLoaded", f), l._reactRetry = f;
    }
  }
  function Ti(l) {
    for (; l != null; l = l.nextSibling) {
      var r = l.nodeType;
      if (r === 1 || r === 3) break;
      if (r === 8) {
        if (r = l.data, r === "$" || r === "$!" || r === "$?" || r === "F!" || r === "F")
          break;
        if (r === "/$") return null;
      }
    }
    return l;
  }
  var iO = null;
  function Ry(l) {
    l = l.previousSibling;
    for (var r = 0; l; ) {
      if (l.nodeType === 8) {
        var c = l.data;
        if (c === "$" || c === "$!" || c === "$?") {
          if (r === 0) return l;
          r--;
        } else c === "/$" && r++;
      }
      l = l.previousSibling;
    }
    return null;
  }
  function Ay(l, r, c) {
    switch (r = oc(c), l) {
      case "html":
        if (l = r.documentElement, !l) throw Error(i(452));
        return l;
      case "head":
        if (l = r.head, !l) throw Error(i(453));
        return l;
      case "body":
        if (l = r.body, !l) throw Error(i(454));
        return l;
      default:
        throw Error(i(451));
    }
  }
  function Ir(l) {
    for (var r = l.attributes; r.length; )
      l.removeAttributeNode(r[0]);
    sf(l);
  }
  var gi = /* @__PURE__ */ new Map(), My = /* @__PURE__ */ new Set();
  function cc(l) {
    return typeof l.getRootNode == "function" ? l.getRootNode() : l.nodeType === 9 ? l : l.ownerDocument;
  }
  var gn = z.d;
  z.d = {
    f: RT,
    r: AT,
    D: MT,
    C: qT,
    L: CT,
    m: ZT,
    X: XT,
    S: ET,
    M: _T
  };
  function RT() {
    var l = gn.f(), r = tc();
    return l || r;
  }
  function AT(l) {
    var r = ts(l);
    r !== null && r.tag === 5 && r.type === "form" ? Jg(r) : gn.r(l);
  }
  var Zs = typeof document > "u" ? null : document;
  function qy(l, r, c) {
    var f = Zs;
    if (f && typeof r == "string" && r) {
      var O = ui(r);
      O = 'link[rel="' + l + '"][href="' + O + '"]', typeof c == "string" && (O += '[crossorigin="' + c + '"]'), My.has(O) || (My.add(O), l = { rel: l, crossOrigin: c, href: r }, f.querySelector(O) === null && (r = f.createElement("link"), be(r, "link", l), de(r), f.head.appendChild(r)));
    }
  }
  function MT(l) {
    gn.D(l), qy("dns-prefetch", l, null);
  }
  function qT(l, r) {
    gn.C(l, r), qy("preconnect", l, r);
  }
  function CT(l, r, c) {
    gn.L(l, r, c);
    var f = Zs;
    if (f && l && r) {
      var O = 'link[rel="preload"][as="' + ui(r) + '"]';
      r === "image" && c && c.imageSrcSet ? (O += '[imagesrcset="' + ui(
        c.imageSrcSet
      ) + '"]', typeof c.imageSizes == "string" && (O += '[imagesizes="' + ui(
        c.imageSizes
      ) + '"]')) : O += '[href="' + ui(l) + '"]';
      var m = O;
      switch (r) {
        case "style":
          m = Es(l);
          break;
        case "script":
          m = Xs(l);
      }
      gi.has(m) || (l = p(
        {
          rel: "preload",
          href: r === "image" && c && c.imageSrcSet ? void 0 : l,
          as: r
        },
        c
      ), gi.set(m, l), f.querySelector(O) !== null || r === "style" && f.querySelector(Fr(m)) || r === "script" && f.querySelector(ta(m)) || (r = f.createElement("link"), be(r, "link", l), de(r), f.head.appendChild(r)));
    }
  }
  function ZT(l, r) {
    gn.m(l, r);
    var c = Zs;
    if (c && l) {
      var f = r && typeof r.as == "string" ? r.as : "script", O = 'link[rel="modulepreload"][as="' + ui(f) + '"][href="' + ui(l) + '"]', m = O;
      switch (f) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          m = Xs(l);
      }
      if (!gi.has(m) && (l = p({ rel: "modulepreload", href: l }, r), gi.set(m, l), c.querySelector(O) === null)) {
        switch (f) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (c.querySelector(ta(m)))
              return;
        }
        f = c.createElement("link"), be(f, "link", l), de(f), c.head.appendChild(f);
      }
    }
  }
  function ET(l, r, c) {
    gn.S(l, r, c);
    var f = Zs;
    if (f && l) {
      var O = es(f).hoistableStyles, m = Es(l);
      r = r || "default";
      var S = O.get(m);
      if (!S) {
        var v = { loading: 0, preload: null };
        if (S = f.querySelector(
          Fr(m)
        ))
          v.loading = 5;
        else {
          l = p(
            { rel: "stylesheet", href: l, "data-precedence": r },
            c
          ), (c = gi.get(m)) && nO(l, c);
          var k = S = f.createElement("link");
          de(k), be(k, "link", l), k._p = new Promise(function(C, D) {
            k.onload = C, k.onerror = D;
          }), k.addEventListener("load", function() {
            v.loading |= 1;
          }), k.addEventListener("error", function() {
            v.loading |= 2;
          }), v.loading |= 4, uc(S, r, f);
        }
        S = {
          type: "stylesheet",
          instance: S,
          count: 1,
          state: v
        }, O.set(m, S);
      }
    }
  }
  function XT(l, r) {
    gn.X(l, r);
    var c = Zs;
    if (c && l) {
      var f = es(c).hoistableScripts, O = Xs(l), m = f.get(O);
      m || (m = c.querySelector(ta(O)), m || (l = p({ src: l, async: !0 }, r), (r = gi.get(O)) && lO(l, r), m = c.createElement("script"), de(m), be(m, "link", l), c.head.appendChild(m)), m = {
        type: "script",
        instance: m,
        count: 1,
        state: null
      }, f.set(O, m));
    }
  }
  function _T(l, r) {
    gn.M(l, r);
    var c = Zs;
    if (c && l) {
      var f = es(c).hoistableScripts, O = Xs(l), m = f.get(O);
      m || (m = c.querySelector(ta(O)), m || (l = p({ src: l, async: !0, type: "module" }, r), (r = gi.get(O)) && lO(l, r), m = c.createElement("script"), de(m), be(m, "link", l), c.head.appendChild(m)), m = {
        type: "script",
        instance: m,
        count: 1,
        state: null
      }, f.set(O, m));
    }
  }
  function Cy(l, r, c, f) {
    var O = (O = mt.current) ? cc(O) : null;
    if (!O) throw Error(i(446));
    switch (l) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof c.precedence == "string" && typeof c.href == "string" ? (r = Es(c.href), c = es(
          O
        ).hoistableStyles, f = c.get(r), f || (f = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, c.set(r, f)), f) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (c.rel === "stylesheet" && typeof c.href == "string" && typeof c.precedence == "string") {
          l = Es(c.href);
          var m = es(
            O
          ).hoistableStyles, S = m.get(l);
          if (S || (O = O.ownerDocument || O, S = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, m.set(l, S), (m = O.querySelector(
            Fr(l)
          )) && !m._p && (S.instance = m, S.state.loading = 5), gi.has(l) || (c = {
            rel: "preload",
            as: "style",
            href: c.href,
            crossOrigin: c.crossOrigin,
            integrity: c.integrity,
            media: c.media,
            hrefLang: c.hrefLang,
            referrerPolicy: c.referrerPolicy
          }, gi.set(l, c), m || zT(
            O,
            l,
            c,
            S.state
          ))), r && f === null)
            throw Error(i(528, ""));
          return S;
        }
        if (r && f !== null)
          throw Error(i(529, ""));
        return null;
      case "script":
        return r = c.async, c = c.src, typeof c == "string" && r && typeof r != "function" && typeof r != "symbol" ? (r = Xs(c), c = es(
          O
        ).hoistableScripts, f = c.get(r), f || (f = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, c.set(r, f)), f) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(i(444, l));
    }
  }
  function Es(l) {
    return 'href="' + ui(l) + '"';
  }
  function Fr(l) {
    return 'link[rel="stylesheet"][' + l + "]";
  }
  function Zy(l) {
    return p({}, l, {
      "data-precedence": l.precedence,
      precedence: null
    });
  }
  function zT(l, r, c, f) {
    l.querySelector('link[rel="preload"][as="style"][' + r + "]") ? f.loading = 1 : (r = l.createElement("link"), f.preload = r, r.addEventListener("load", function() {
      return f.loading |= 1;
    }), r.addEventListener("error", function() {
      return f.loading |= 2;
    }), be(r, "link", c), de(r), l.head.appendChild(r));
  }
  function Xs(l) {
    return '[src="' + ui(l) + '"]';
  }
  function ta(l) {
    return "script[async]" + l;
  }
  function Ey(l, r, c) {
    if (r.count++, r.instance === null)
      switch (r.type) {
        case "style":
          var f = l.querySelector(
            'style[data-href~="' + ui(c.href) + '"]'
          );
          if (f)
            return r.instance = f, de(f), f;
          var O = p({}, c, {
            "data-href": c.href,
            "data-precedence": c.precedence,
            href: null,
            precedence: null
          });
          return f = (l.ownerDocument || l).createElement(
            "style"
          ), de(f), be(f, "style", O), uc(f, c.precedence, l), r.instance = f;
        case "stylesheet":
          O = Es(c.href);
          var m = l.querySelector(
            Fr(O)
          );
          if (m)
            return r.state.loading |= 4, r.instance = m, de(m), m;
          f = Zy(c), (O = gi.get(O)) && nO(f, O), m = (l.ownerDocument || l).createElement("link"), de(m);
          var S = m;
          return S._p = new Promise(function(v, k) {
            S.onload = v, S.onerror = k;
          }), be(m, "link", f), r.state.loading |= 4, uc(m, c.precedence, l), r.instance = m;
        case "script":
          return m = Xs(c.src), (O = l.querySelector(
            ta(m)
          )) ? (r.instance = O, de(O), O) : (f = c, (O = gi.get(m)) && (f = p({}, c), lO(f, O)), l = l.ownerDocument || l, O = l.createElement("script"), de(O), be(O, "link", f), l.head.appendChild(O), r.instance = O);
        case "void":
          return null;
        default:
          throw Error(i(443, r.type));
      }
    else
      r.type === "stylesheet" && (r.state.loading & 4) === 0 && (f = r.instance, r.state.loading |= 4, uc(f, c.precedence, l));
    return r.instance;
  }
  function uc(l, r, c) {
    for (var f = c.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), O = f.length ? f[f.length - 1] : null, m = O, S = 0; S < f.length; S++) {
      var v = f[S];
      if (v.dataset.precedence === r) m = v;
      else if (m !== O) break;
    }
    m ? m.parentNode.insertBefore(l, m.nextSibling) : (r = c.nodeType === 9 ? c.head : c, r.insertBefore(l, r.firstChild));
  }
  function nO(l, r) {
    l.crossOrigin == null && (l.crossOrigin = r.crossOrigin), l.referrerPolicy == null && (l.referrerPolicy = r.referrerPolicy), l.title == null && (l.title = r.title);
  }
  function lO(l, r) {
    l.crossOrigin == null && (l.crossOrigin = r.crossOrigin), l.referrerPolicy == null && (l.referrerPolicy = r.referrerPolicy), l.integrity == null && (l.integrity = r.integrity);
  }
  var fc = null;
  function Xy(l, r, c) {
    if (fc === null) {
      var f = /* @__PURE__ */ new Map(), O = fc = /* @__PURE__ */ new Map();
      O.set(c, f);
    } else
      O = fc, f = O.get(c), f || (f = /* @__PURE__ */ new Map(), O.set(c, f));
    if (f.has(l)) return f;
    for (f.set(l, null), c = c.getElementsByTagName(l), O = 0; O < c.length; O++) {
      var m = c[O];
      if (!(m[Or] || m[Pe] || l === "link" && m.getAttribute("rel") === "stylesheet") && m.namespaceURI !== "http://www.w3.org/2000/svg") {
        var S = m.getAttribute(r) || "";
        S = l + S;
        var v = f.get(S);
        v ? v.push(m) : f.set(S, [m]);
      }
    }
    return f;
  }
  function _y(l, r, c) {
    l = l.ownerDocument || l, l.head.insertBefore(
      c,
      r === "title" ? l.querySelector("head > title") : null
    );
  }
  function DT(l, r, c) {
    if (c === 1 || r.itemProp != null) return !1;
    switch (l) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (typeof r.precedence != "string" || typeof r.href != "string" || r.href === "")
          break;
        return !0;
      case "link":
        if (typeof r.rel != "string" || typeof r.href != "string" || r.href === "" || r.onLoad || r.onError)
          break;
        switch (r.rel) {
          case "stylesheet":
            return l = r.disabled, typeof r.precedence == "string" && l == null;
          default:
            return !0;
        }
      case "script":
        if (r.async && typeof r.async != "function" && typeof r.async != "symbol" && !r.onLoad && !r.onError && r.src && typeof r.src == "string")
          return !0;
    }
    return !1;
  }
  function zy(l) {
    return !(l.type === "stylesheet" && (l.state.loading & 3) === 0);
  }
  var ea = null;
  function VT() {
  }
  function YT(l, r, c) {
    if (ea === null) throw Error(i(475));
    var f = ea;
    if (r.type === "stylesheet" && (typeof c.media != "string" || matchMedia(c.media).matches !== !1) && (r.state.loading & 4) === 0) {
      if (r.instance === null) {
        var O = Es(c.href), m = l.querySelector(
          Fr(O)
        );
        if (m) {
          l = m._p, l !== null && typeof l == "object" && typeof l.then == "function" && (f.count++, f = hc.bind(f), l.then(f, f)), r.state.loading |= 4, r.instance = m, de(m);
          return;
        }
        m = l.ownerDocument || l, c = Zy(c), (O = gi.get(O)) && nO(c, O), m = m.createElement("link"), de(m);
        var S = m;
        S._p = new Promise(function(v, k) {
          S.onload = v, S.onerror = k;
        }), be(m, "link", c), r.instance = m;
      }
      f.stylesheets === null && (f.stylesheets = /* @__PURE__ */ new Map()), f.stylesheets.set(r, l), (l = r.state.preload) && (r.state.loading & 3) === 0 && (f.count++, r = hc.bind(f), l.addEventListener("load", r), l.addEventListener("error", r));
    }
  }
  function UT() {
    if (ea === null) throw Error(i(475));
    var l = ea;
    return l.stylesheets && l.count === 0 && sO(l, l.stylesheets), 0 < l.count ? function(r) {
      var c = setTimeout(function() {
        if (l.stylesheets && sO(l, l.stylesheets), l.unsuspend) {
          var f = l.unsuspend;
          l.unsuspend = null, f();
        }
      }, 6e4);
      return l.unsuspend = r, function() {
        l.unsuspend = null, clearTimeout(c);
      };
    } : null;
  }
  function hc() {
    if (this.count--, this.count === 0) {
      if (this.stylesheets) sO(this, this.stylesheets);
      else if (this.unsuspend) {
        var l = this.unsuspend;
        this.unsuspend = null, l();
      }
    }
  }
  var Oc = null;
  function sO(l, r) {
    l.stylesheets = null, l.unsuspend !== null && (l.count++, Oc = /* @__PURE__ */ new Map(), r.forEach(jT, l), Oc = null, hc.call(l));
  }
  function jT(l, r) {
    if (!(r.state.loading & 4)) {
      var c = Oc.get(l);
      if (c) var f = c.get(null);
      else {
        c = /* @__PURE__ */ new Map(), Oc.set(l, c);
        for (var O = l.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), m = 0; m < O.length; m++) {
          var S = O[m];
          (S.nodeName === "LINK" || S.getAttribute("media") !== "not all") && (c.set(S.dataset.precedence, S), f = S);
        }
        f && c.set(null, f);
      }
      O = r.instance, S = O.getAttribute("data-precedence"), m = c.get(S) || f, m === f && c.set(null, O), c.set(S, O), this.count++, f = hc.bind(this), O.addEventListener("load", f), O.addEventListener("error", f), m ? m.parentNode.insertBefore(O, m.nextSibling) : (l = l.nodeType === 9 ? l.head : l, l.insertBefore(O, l.firstChild)), r.state.loading |= 4;
    }
  }
  var ia = {
    $$typeof: G,
    Provider: null,
    Consumer: null,
    _currentValue: nt,
    _currentValue2: nt,
    _threadCount: 0
  };
  function LT(l, r, c, f, O, m, S, v) {
    this.tag = 1, this.containerInfo = l, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = tf(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = tf(0), this.hiddenUpdates = tf(null), this.identifierPrefix = f, this.onUncaughtError = O, this.onCaughtError = m, this.onRecoverableError = S, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = v, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function Dy(l, r, c, f, O, m, S, v, k, C, D, B) {
    return l = new LT(
      l,
      r,
      c,
      S,
      v,
      k,
      C,
      B
    ), r = 1, m === !0 && (r |= 24), m = Ie(3, null, null, r), l.current = m, m.stateNode = l, r = Vf(), r.refCount++, l.pooledCache = r, r.refCount++, m.memoizedState = {
      element: f,
      isDehydrated: c,
      cache: r
    }, Lf(m), l;
  }
  function Vy(l) {
    return l ? (l = Os, l) : Os;
  }
  function Yy(l, r, c, f, O, m) {
    O = Vy(O), f.context === null ? f.context = O : f.pendingContext = O, f = Xn(r), f.payload = { element: c }, m = m === void 0 ? null : m, m !== null && (f.callback = m), c = _n(l, f, r), c !== null && (ni(c, l, r), qr(c, l, r));
  }
  function Uy(l, r) {
    if (l = l.memoizedState, l !== null && l.dehydrated !== null) {
      var c = l.retryLane;
      l.retryLane = c !== 0 && c < r ? c : r;
    }
  }
  function rO(l, r) {
    Uy(l, r), (l = l.alternate) && Uy(l, r);
  }
  function jy(l) {
    if (l.tag === 13) {
      var r = hs(l, 67108864);
      r !== null && ni(r, l, 67108864), rO(l, 67108864);
    }
  }
  var dc = !0;
  function BT(l, r, c, f) {
    var O = E.T;
    E.T = null;
    var m = z.p;
    try {
      z.p = 2, aO(l, r, c, f);
    } finally {
      z.p = m, E.T = O;
    }
  }
  function GT(l, r, c, f) {
    var O = E.T;
    E.T = null;
    var m = z.p;
    try {
      z.p = 8, aO(l, r, c, f);
    } finally {
      z.p = m, E.T = O;
    }
  }
  function aO(l, r, c, f) {
    if (dc) {
      var O = oO(f);
      if (O === null)
        Wh(
          l,
          r,
          f,
          pc,
          c
        ), By(l, f);
      else if (WT(
        O,
        l,
        r,
        c,
        f
      ))
        f.stopPropagation();
      else if (By(l, f), r & 4 && -1 < NT.indexOf(l)) {
        for (; O !== null; ) {
          var m = ts(O);
          if (m !== null)
            switch (m.tag) {
              case 3:
                if (m = m.stateNode, m.current.memoizedState.isDehydrated) {
                  var S = ml(m.pendingLanes);
                  if (S !== 0) {
                    var v = m;
                    for (v.pendingLanes |= 2, v.entangledLanes |= 2; S; ) {
                      var k = 1 << 31 - Ke(S);
                      v.entanglements[1] |= k, S &= ~k;
                    }
                    Xi(m), (Zt & 6) === 0 && (Io = Mi() + 500, Hr(0));
                  }
                }
                break;
              case 13:
                v = hs(m, 2), v !== null && ni(v, m, 2), tc(), rO(m, 2);
            }
          if (m = oO(f), m === null && Wh(
            l,
            r,
            f,
            pc,
            c
          ), m === O) break;
          O = m;
        }
        O !== null && f.stopPropagation();
      } else
        Wh(
          l,
          r,
          f,
          null,
          c
        );
    }
  }
  function oO(l) {
    return l = Of(l), cO(l);
  }
  var pc = null;
  function cO(l) {
    if (pc = null, l = Fl(l), l !== null) {
      var r = a(l);
      if (r === null) l = null;
      else {
        var c = r.tag;
        if (c === 13) {
          if (l = o(r), l !== null) return l;
          l = null;
        } else if (c === 3) {
          if (r.stateNode.current.memoizedState.isDehydrated)
            return r.tag === 3 ? r.stateNode.containerInfo : null;
          l = null;
        } else r !== l && (l = null);
      }
    }
    return pc = l, null;
  }
  function Ly(l) {
    switch (l) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (qk()) {
          case lm:
            return 2;
          case sm:
            return 8;
          case ro:
          case Ck:
            return 32;
          case rm:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var uO = !1, Kn = null, Jn = null, In = null, na = /* @__PURE__ */ new Map(), la = /* @__PURE__ */ new Map(), Fn = [], NT = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function By(l, r) {
    switch (l) {
      case "focusin":
      case "focusout":
        Kn = null;
        break;
      case "dragenter":
      case "dragleave":
        Jn = null;
        break;
      case "mouseover":
      case "mouseout":
        In = null;
        break;
      case "pointerover":
      case "pointerout":
        na.delete(r.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        la.delete(r.pointerId);
    }
  }
  function sa(l, r, c, f, O, m) {
    return l === null || l.nativeEvent !== m ? (l = {
      blockedOn: r,
      domEventName: c,
      eventSystemFlags: f,
      nativeEvent: m,
      targetContainers: [O]
    }, r !== null && (r = ts(r), r !== null && jy(r)), l) : (l.eventSystemFlags |= f, r = l.targetContainers, O !== null && r.indexOf(O) === -1 && r.push(O), l);
  }
  function WT(l, r, c, f, O) {
    switch (r) {
      case "focusin":
        return Kn = sa(
          Kn,
          l,
          r,
          c,
          f,
          O
        ), !0;
      case "dragenter":
        return Jn = sa(
          Jn,
          l,
          r,
          c,
          f,
          O
        ), !0;
      case "mouseover":
        return In = sa(
          In,
          l,
          r,
          c,
          f,
          O
        ), !0;
      case "pointerover":
        var m = O.pointerId;
        return na.set(
          m,
          sa(
            na.get(m) || null,
            l,
            r,
            c,
            f,
            O
          )
        ), !0;
      case "gotpointercapture":
        return m = O.pointerId, la.set(
          m,
          sa(
            la.get(m) || null,
            l,
            r,
            c,
            f,
            O
          )
        ), !0;
    }
    return !1;
  }
  function Gy(l) {
    var r = Fl(l.target);
    if (r !== null) {
      var c = a(r);
      if (c !== null) {
        if (r = c.tag, r === 13) {
          if (r = o(c), r !== null) {
            l.blockedOn = r, Yk(l.priority, function() {
              if (c.tag === 13) {
                var f = ii();
                f = ef(f);
                var O = hs(c, f);
                O !== null && ni(O, c, f), rO(c, f);
              }
            });
            return;
          }
        } else if (r === 3 && c.stateNode.current.memoizedState.isDehydrated) {
          l.blockedOn = c.tag === 3 ? c.stateNode.containerInfo : null;
          return;
        }
      }
    }
    l.blockedOn = null;
  }
  function mc(l) {
    if (l.blockedOn !== null) return !1;
    for (var r = l.targetContainers; 0 < r.length; ) {
      var c = oO(l.nativeEvent);
      if (c === null) {
        c = l.nativeEvent;
        var f = new c.constructor(
          c.type,
          c
        );
        hf = f, c.target.dispatchEvent(f), hf = null;
      } else
        return r = ts(c), r !== null && jy(r), l.blockedOn = c, !1;
      r.shift();
    }
    return !0;
  }
  function Ny(l, r, c) {
    mc(l) && c.delete(r);
  }
  function HT() {
    uO = !1, Kn !== null && mc(Kn) && (Kn = null), Jn !== null && mc(Jn) && (Jn = null), In !== null && mc(In) && (In = null), na.forEach(Ny), la.forEach(Ny);
  }
  function gc(l, r) {
    l.blockedOn === r && (l.blockedOn = null, uO || (uO = !0, n.unstable_scheduleCallback(
      n.unstable_NormalPriority,
      HT
    )));
  }
  var yc = null;
  function Wy(l) {
    yc !== l && (yc = l, n.unstable_scheduleCallback(
      n.unstable_NormalPriority,
      function() {
        yc === l && (yc = null);
        for (var r = 0; r < l.length; r += 3) {
          var c = l[r], f = l[r + 1], O = l[r + 2];
          if (typeof f != "function") {
            if (cO(f || c) === null)
              continue;
            break;
          }
          var m = ts(c);
          m !== null && (l.splice(r, 3), r -= 3, ch(
            m,
            {
              pending: !0,
              data: O,
              method: c.method,
              action: f
            },
            f,
            O
          ));
        }
      }
    ));
  }
  function ra(l) {
    function r(k) {
      return gc(k, l);
    }
    Kn !== null && gc(Kn, l), Jn !== null && gc(Jn, l), In !== null && gc(In, l), na.forEach(r), la.forEach(r);
    for (var c = 0; c < Fn.length; c++) {
      var f = Fn[c];
      f.blockedOn === l && (f.blockedOn = null);
    }
    for (; 0 < Fn.length && (c = Fn[0], c.blockedOn === null); )
      Gy(c), c.blockedOn === null && Fn.shift();
    if (c = (l.ownerDocument || l).$$reactFormReplay, c != null)
      for (f = 0; f < c.length; f += 3) {
        var O = c[f], m = c[f + 1], S = O[_e] || null;
        if (typeof m == "function")
          S || Wy(c);
        else if (S) {
          var v = null;
          if (m && m.hasAttribute("formAction")) {
            if (O = m, S = m[_e] || null)
              v = S.formAction;
            else if (cO(O) !== null) continue;
          } else v = S.action;
          typeof v == "function" ? c[f + 1] = v : (c.splice(f, 3), f -= 3), Wy(c);
        }
      }
  }
  function fO(l) {
    this._internalRoot = l;
  }
  Sc.prototype.render = fO.prototype.render = function(l) {
    var r = this._internalRoot;
    if (r === null) throw Error(i(409));
    var c = r.current, f = ii();
    Yy(c, f, l, r, null, null);
  }, Sc.prototype.unmount = fO.prototype.unmount = function() {
    var l = this._internalRoot;
    if (l !== null) {
      this._internalRoot = null;
      var r = l.containerInfo;
      Yy(l.current, 2, null, l, null, null), tc(), r[Il] = null;
    }
  };
  function Sc(l) {
    this._internalRoot = l;
  }
  Sc.prototype.unstable_scheduleHydration = function(l) {
    if (l) {
      var r = fm();
      l = { blockedOn: null, target: l, priority: r };
      for (var c = 0; c < Fn.length && r !== 0 && r < Fn[c].priority; c++) ;
      Fn.splice(c, 0, l), c === 0 && Gy(l);
    }
  };
  var Hy = t.version;
  if (Hy !== "19.1.0")
    throw Error(
      i(
        527,
        Hy,
        "19.1.0"
      )
    );
  z.findDOMNode = function(l) {
    var r = l._reactInternals;
    if (r === void 0)
      throw typeof l.render == "function" ? Error(i(188)) : (l = Object.keys(l).join(","), Error(i(268, l)));
    return l = h(r), l = l !== null ? d(l) : null, l = l === null ? null : l.stateNode, l;
  };
  var KT = {
    bundleType: 0,
    version: "19.1.0",
    rendererPackageName: "react-dom",
    currentDispatcherRef: E,
    reconcilerVersion: "19.1.0"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Qc = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Qc.isDisabled && Qc.supportsFiber)
      try {
        ur = Qc.inject(
          KT
        ), He = Qc;
      } catch {
      }
  }
  return aa.createRoot = function(l, r) {
    if (!s(l)) throw Error(i(299));
    var c = !1, f = "", O = f0, m = h0, S = O0, v = null;
    return r != null && (r.unstable_strictMode === !0 && (c = !0), r.identifierPrefix !== void 0 && (f = r.identifierPrefix), r.onUncaughtError !== void 0 && (O = r.onUncaughtError), r.onCaughtError !== void 0 && (m = r.onCaughtError), r.onRecoverableError !== void 0 && (S = r.onRecoverableError), r.unstable_transitionCallbacks !== void 0 && (v = r.unstable_transitionCallbacks)), r = Dy(
      l,
      1,
      !1,
      null,
      null,
      c,
      f,
      O,
      m,
      S,
      v,
      null
    ), l[Il] = r.current, Nh(l), new fO(r);
  }, aa.hydrateRoot = function(l, r, c) {
    if (!s(l)) throw Error(i(299));
    var f = !1, O = "", m = f0, S = h0, v = O0, k = null, C = null;
    return c != null && (c.unstable_strictMode === !0 && (f = !0), c.identifierPrefix !== void 0 && (O = c.identifierPrefix), c.onUncaughtError !== void 0 && (m = c.onUncaughtError), c.onCaughtError !== void 0 && (S = c.onCaughtError), c.onRecoverableError !== void 0 && (v = c.onRecoverableError), c.unstable_transitionCallbacks !== void 0 && (k = c.unstable_transitionCallbacks), c.formState !== void 0 && (C = c.formState)), r = Dy(
      l,
      1,
      !0,
      r,
      c ?? null,
      f,
      O,
      m,
      S,
      v,
      k,
      C
    ), r.context = Vy(null), c = r.current, f = ii(), f = ef(f), O = Xn(f), O.callback = null, _n(c, O, f), c = f, r.current.lanes = c, hr(r, c), Xi(r), l[Il] = r.current, Nh(l), new Sc(r);
  }, aa.version = "19.1.0", aa;
}
var nS;
function s$() {
  if (nS) return OO.exports;
  nS = 1;
  function n() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n);
      } catch (t) {
        console.error(t);
      }
  }
  return n(), OO.exports = l$(), OO.exports;
}
var r$ = s$();
const ga = {}, lS = (n, t) => n.unstable_is ? n.unstable_is(t) : t === n, sS = (n) => "init" in n, gO = (n) => !!n.write, rS = (n) => "v" in n || "e" in n, vc = (n) => {
  if ("e" in n)
    throw n.e;
  if ((ga ? "production" : void 0) !== "production" && !("v" in n))
    throw new Error("[Bug] atom state is not initialized");
  return n.v;
}, cu = /* @__PURE__ */ new WeakMap(), aS = (n) => {
  var t;
  return uu(n) && !!((t = cu.get(n)) != null && t[0]);
}, a$ = (n) => {
  const t = cu.get(n);
  t != null && t[0] && (t[0] = !1, t[1].forEach((e) => e()));
}, TQ = (n, t) => {
  let e = cu.get(n);
  if (!e) {
    e = [!0, /* @__PURE__ */ new Set()], cu.set(n, e);
    const i = () => {
      e[0] = !1;
    };
    n.then(i, i);
  }
  e[1].add(t);
}, uu = (n) => typeof (n == null ? void 0 : n.then) == "function", $Q = (n, t, e) => {
  e.p.has(n) || (e.p.add(n), t.then(
    () => {
      e.p.delete(n);
    },
    () => {
      e.p.delete(n);
    }
  ));
}, yO = (n, t, e) => {
  const i = e(n), s = "v" in i, a = i.v;
  if (uu(t))
    for (const o of i.d.keys())
      $Q(n, t, e(o));
  i.v = t, delete i.e, (!s || !Object.is(a, i.v)) && (++i.n, uu(a) && a$(a));
}, oS = (n, t, e) => {
  var i;
  const s = /* @__PURE__ */ new Set();
  for (const a of ((i = e.get(n)) == null ? void 0 : i.t) || [])
    e.has(a) && s.add(a);
  for (const a of t.p)
    s.add(a);
  return s;
}, o$ = () => {
  const n = /* @__PURE__ */ new Set(), t = () => {
    n.forEach((e) => e());
  };
  return t.add = (e) => (n.add(e), () => {
    n.delete(e);
  }), t;
}, SO = () => {
  const n = {}, t = /* @__PURE__ */ new WeakMap(), e = (i) => {
    var s, a;
    (s = t.get(n)) == null || s.forEach((o) => o(i)), (a = t.get(i)) == null || a.forEach((o) => o());
  };
  return e.add = (i, s) => {
    const a = i || n, o = (t.has(a) ? t : t.set(a, /* @__PURE__ */ new Set())).get(a);
    return o.add(s), () => {
      o == null || o.delete(s), o.size || t.delete(a);
    };
  }, e;
}, c$ = (n) => (n.c || (n.c = SO()), n.m || (n.m = SO()), n.u || (n.u = SO()), n.f || (n.f = o$()), n), u$ = Symbol(), f$ = (n = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap(), e = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new Set(), s = /* @__PURE__ */ new Set(), a = /* @__PURE__ */ new Set(), o = {}, u = (y, ...Q) => y.read(...Q), h = (y, ...Q) => y.write(...Q), d = (y, Q) => {
  var b;
  return (b = y.unstable_onInit) == null ? void 0 : b.call(y, Q);
}, p = (y, Q) => {
  var b;
  return (b = y.onMount) == null ? void 0 : b.call(y, Q);
}, ...g) => {
  const y = g[0] || ((q) => {
    if ((ga ? "production" : void 0) !== "production" && !q)
      throw new Error("Atom is undefined or null");
    let J = n.get(q);
    return J || (J = { d: /* @__PURE__ */ new Map(), p: /* @__PURE__ */ new Set(), n: 0 }, n.set(q, J), d == null || d(q, W)), J;
  }), Q = g[1] || (() => {
    const q = [], J = (N) => {
      try {
        N();
      } catch (I) {
        q.push(I);
      }
    };
    do {
      o.f && J(o.f);
      const N = /* @__PURE__ */ new Set(), I = N.add.bind(N);
      i.forEach((K) => {
        var Y;
        return (Y = t.get(K)) == null ? void 0 : Y.l.forEach(I);
      }), i.clear(), a.forEach(I), a.clear(), s.forEach(I), s.clear(), N.forEach(J), i.size && b();
    } while (i.size || a.size || s.size);
    if (q.length)
      throw new AggregateError(q);
  }), b = g[2] || (() => {
    const q = [], J = /* @__PURE__ */ new WeakSet(), N = /* @__PURE__ */ new WeakSet(), I = Array.from(i);
    for (; I.length; ) {
      const K = I[I.length - 1], Y = y(K);
      if (N.has(K)) {
        I.pop();
        continue;
      }
      if (J.has(K)) {
        if (e.get(K) === Y.n)
          q.push([K, Y]);
        else if ((ga ? "production" : void 0) !== "production" && e.has(K))
          throw new Error("[Bug] invalidated atom exists");
        N.add(K), I.pop();
        continue;
      }
      J.add(K);
      for (const ot of oS(K, Y, t))
        J.has(ot) || I.push(ot);
    }
    for (let K = q.length - 1; K >= 0; --K) {
      const [Y, ot] = q[K];
      let at = !1;
      for (const ht of ot.d.keys())
        if (ht !== Y && i.has(ht)) {
          at = !0;
          break;
        }
      at && (x(Y), V(Y)), e.delete(Y);
    }
  }), x = g[3] || ((q) => {
    var J;
    const N = y(q);
    if (rS(N) && (t.has(q) && e.get(q) !== N.n || Array.from(N.d).every(
      ([z, nt]) => (
        // Recursively, read the atom state of the dependency, and
        // check if the atom epoch number is unchanged
        x(z).n === nt
      )
    )))
      return N;
    N.d.clear();
    let I = !0;
    const K = () => {
      t.has(q) && (V(q), b(), Q());
    }, Y = (z) => {
      var nt;
      if (lS(q, z)) {
        const T = y(z);
        if (!rS(T))
          if (sS(z))
            yO(z, z.init, y);
          else
            throw new Error("no atom init");
        return vc(T);
      }
      const Ot = x(z);
      try {
        return vc(Ot);
      } finally {
        N.d.set(z, Ot.n), aS(N.v) && $Q(q, N.v, Ot), (nt = t.get(z)) == null || nt.t.add(q), I || K();
      }
    };
    let ot, at;
    const ht = {
      get signal() {
        return ot || (ot = new AbortController()), ot.signal;
      },
      get setSelf() {
        return (ga ? "production" : void 0) !== "production" && !gO(q) && console.warn("setSelf function cannot be used with read-only atom"), !at && gO(q) && (at = (...z) => {
          if ((ga ? "production" : void 0) !== "production" && I && console.warn("setSelf function cannot be called in sync"), !I)
            try {
              return A(q, ...z);
            } finally {
              b(), Q();
            }
        }), at;
      }
    }, E = N.n;
    try {
      const z = u(q, Y, ht);
      return yO(q, z, y), uu(z) && (TQ(z, () => ot == null ? void 0 : ot.abort()), z.then(
        K,
        K
      )), N;
    } catch (z) {
      return delete N.v, N.e = z, ++N.n, N;
    } finally {
      I = !1, E !== N.n && e.get(q) === E && (e.set(q, N.n), i.add(q), (J = o.c) == null || J.call(o, q));
    }
  }), P = g[4] || ((q) => {
    const J = [q];
    for (; J.length; ) {
      const N = J.pop(), I = y(N);
      for (const K of oS(N, I, t)) {
        const Y = y(K);
        e.set(K, Y.n), J.push(K);
      }
    }
  }), A = g[5] || ((q, ...J) => {
    let N = !0;
    const I = (Y) => vc(x(Y)), K = (Y, ...ot) => {
      var at;
      const ht = y(Y);
      try {
        if (lS(q, Y)) {
          if (!sS(Y))
            throw new Error("atom not writable");
          const E = ht.n, z = ot[0];
          yO(Y, z, y), V(Y), E !== ht.n && (i.add(Y), (at = o.c) == null || at.call(o, Y), P(Y));
          return;
        } else
          return A(Y, ...ot);
      } finally {
        N || (b(), Q());
      }
    };
    try {
      return h(q, I, K, ...J);
    } finally {
      N = !1;
    }
  }), V = g[6] || ((q) => {
    var J;
    const N = y(q), I = t.get(q);
    if (I && !aS(N.v)) {
      for (const [K, Y] of N.d)
        if (!I.d.has(K)) {
          const ot = y(K);
          G(K).t.add(q), I.d.add(K), Y !== ot.n && (i.add(K), (J = o.c) == null || J.call(o, K), P(K));
        }
      for (const K of I.d || [])
        if (!N.d.has(K)) {
          I.d.delete(K);
          const Y = H(K);
          Y == null || Y.t.delete(q);
        }
    }
  }), G = g[7] || ((q) => {
    var J;
    const N = y(q);
    let I = t.get(q);
    if (!I) {
      x(q);
      for (const K of N.d.keys())
        G(K).t.add(q);
      if (I = {
        l: /* @__PURE__ */ new Set(),
        d: new Set(N.d.keys()),
        t: /* @__PURE__ */ new Set()
      }, t.set(q, I), (J = o.m) == null || J.call(o, q), gO(q)) {
        const K = () => {
          let Y = !0;
          const ot = (...at) => {
            try {
              return A(q, ...at);
            } finally {
              Y || (b(), Q());
            }
          };
          try {
            const at = p(q, ot);
            at && (I.u = () => {
              Y = !0;
              try {
                at();
              } finally {
                Y = !1;
              }
            });
          } finally {
            Y = !1;
          }
        };
        s.add(K);
      }
    }
    return I;
  }), H = g[8] || ((q) => {
    var J;
    const N = y(q);
    let I = t.get(q);
    if (I && !I.l.size && !Array.from(I.t).some((K) => {
      var Y;
      return (Y = t.get(K)) == null ? void 0 : Y.d.has(q);
    })) {
      I.u && a.add(I.u), I = void 0, t.delete(q), (J = o.u) == null || J.call(o, q);
      for (const K of N.d.keys()) {
        const Y = H(K);
        Y == null || Y.t.delete(q);
      }
      return;
    }
    return I;
  }), _ = [
    // store state
    n,
    t,
    e,
    i,
    s,
    a,
    o,
    // atom interceptors
    u,
    h,
    d,
    p,
    // building-block functions
    y,
    Q,
    b,
    x,
    P,
    A,
    V,
    G,
    H
  ], W = {
    get: (q) => vc(x(q)),
    set: (q, ...J) => {
      try {
        return A(q, ...J);
      } finally {
        b(), Q();
      }
    },
    sub: (q, J) => {
      const I = G(q).l;
      return I.add(J), Q(), () => {
        I.delete(J), H(q), Q();
      };
    }
  };
  return Object.defineProperty(W, u$, { value: _ }), W;
}, PQ = f$, h$ = c$, cS = TQ, cp = {};
let O$ = 0;
function Ui(n, t) {
  const e = `atom${++O$}`, i = {
    toString() {
      return (cp ? "production" : void 0) !== "production" && this.debugLabel ? e + ":" + this.debugLabel : e;
    }
  };
  return typeof n == "function" ? i.read = n : (i.init = n, i.read = d$, i.write = p$), t && (i.write = t), i;
}
function d$(n) {
  return n(this);
}
function p$(n, t, e) {
  return t(
    this,
    typeof e == "function" ? e(n(this)) : e
  );
}
const m$ = () => {
  let n = 0;
  const t = h$({}), e = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap(), s = PQ(
    e,
    i,
    void 0,
    void 0,
    void 0,
    void 0,
    t,
    void 0,
    (u, h, d, ...p) => n ? d(u, ...p) : u.write(h, d, ...p)
  ), a = /* @__PURE__ */ new Set();
  return t.m.add(void 0, (u) => {
    a.add(u);
    const h = e.get(u);
    h.m = i.get(u);
  }), t.u.add(void 0, (u) => {
    a.delete(u);
    const h = e.get(u);
    delete h.m;
  }), Object.assign(s, {
    // store dev methods (these are tentative and subject to change without notice)
    dev4_get_internal_weak_map: () => (console.log("Deprecated: Use devstore from the devtools library"), e),
    dev4_get_mounted_atoms: () => a,
    dev4_restore_atoms: (u) => {
      const h = {
        read: () => null,
        write: (d, p) => {
          ++n;
          try {
            for (const [g, y] of u)
              "init" in g && p(g, y);
          } finally {
            --n;
          }
        }
      };
      s.set(h);
    }
  });
};
function RQ() {
  return (cp ? "production" : void 0) !== "production" ? m$() : PQ();
}
let oa;
function g$() {
  return oa || (oa = RQ(), (cp ? "production" : void 0) !== "production" && (globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = oa), globalThis.__JOTAI_DEFAULT_STORE__ !== oa && console.warn(
    "Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044"
  ))), oa;
}
const y$ = {}, AQ = St.createContext(
  void 0
);
function MQ(n) {
  return St.useContext(AQ) || g$();
}
function qQ({
  children: n,
  store: t
}) {
  const e = St.useRef(void 0);
  return !t && !e.current && (e.current = RQ()), St.createElement(
    AQ.Provider,
    {
      value: t || e.current
    },
    n
  );
}
const ld = (n) => typeof (n == null ? void 0 : n.then) == "function", sd = (n) => {
  n.status || (n.status = "pending", n.then(
    (t) => {
      n.status = "fulfilled", n.value = t;
    },
    (t) => {
      n.status = "rejected", n.reason = t;
    }
  ));
}, S$ = ie.use || // A shim for older React versions
((n) => {
  if (n.status === "pending")
    throw n;
  if (n.status === "fulfilled")
    return n.value;
  throw n.status === "rejected" ? n.reason : (sd(n), n);
}), QO = /* @__PURE__ */ new WeakMap(), uS = (n, t) => {
  let e = QO.get(n);
  return e || (e = new Promise((i, s) => {
    let a = n;
    const o = (d) => (p) => {
      a === d && i(p);
    }, u = (d) => (p) => {
      a === d && s(p);
    }, h = () => {
      try {
        const d = t();
        ld(d) ? (QO.set(d, e), a = d, d.then(o(d), u(d)), cS(d, h)) : i(d);
      } catch (d) {
        s(d);
      }
    };
    n.then(o(n), u(n)), cS(n, h);
  }), QO.set(n, e)), e;
};
function Q$(n, t) {
  const { delay: e, unstable_promiseStatus: i = !ie.use } = {}, s = MQ(), [[a, o, u], h] = St.useReducer(
    (p) => {
      const g = s.get(n);
      return Object.is(p[0], g) && p[1] === s && p[2] === n ? p : [g, s, n];
    },
    void 0,
    () => [s.get(n), s, n]
  );
  let d = a;
  if ((o !== s || u !== n) && (h(), d = s.get(n)), St.useEffect(() => {
    const p = s.sub(n, () => {
      if (i)
        try {
          const g = s.get(n);
          ld(g) && sd(
            uS(g, () => s.get(n))
          );
        } catch {
        }
      if (typeof e == "number") {
        setTimeout(h, e);
        return;
      }
      h();
    });
    return h(), p;
  }, [s, n, e, i]), St.useDebugValue(d), ld(d)) {
    const p = uS(d, () => s.get(n));
    return i && sd(p), S$(p);
  }
  return d;
}
function v$(n, t) {
  const e = MQ();
  return St.useCallback(
    (...s) => {
      if ((y$ ? "production" : void 0) !== "production" && !("write" in n))
        throw new Error("not writable atom");
      return e.set(n, ...s);
    },
    [e, n]
  );
}
function kn(n, t) {
  return [
    Q$(n),
    // We do wrong type assertion here, which results in throwing an error.
    v$(n)
  ];
}
var b$ = Object.defineProperty, At = (n, t) => b$(n, "name", { value: t, configurable: !0 }), CQ = ((n) => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(n, { get: (t, e) => (typeof require < "u" ? require : t)[e] }) : n)(function(n) {
  if (typeof require < "u") return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + n + '" is not supported');
});
function ZQ(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
At(ZQ, "_isNumber");
function ol(n) {
  return n.charAt(0).toUpperCase() + n.substring(1);
}
At(ol, "_capitalize");
function _u(n) {
  return function() {
    return this[n];
  };
}
At(_u, "_getter");
var zs = ["isConstructor", "isEval", "isNative", "isToplevel"], Ds = ["columnNumber", "lineNumber"], Vs = ["fileName", "functionName", "source"], x$ = ["args"], k$ = ["evalOrigin"], bc = zs.concat(Ds, Vs, x$, k$);
function oi(n) {
  if (n) for (var t = 0; t < bc.length; t++) n[bc[t]] !== void 0 && this["set" + ol(bc[t])](n[bc[t]]);
}
At(oi, "StackFrame");
oi.prototype = { getArgs: function() {
  return this.args;
}, setArgs: function(n) {
  if (Object.prototype.toString.call(n) !== "[object Array]") throw new TypeError("Args must be an Array");
  this.args = n;
}, getEvalOrigin: function() {
  return this.evalOrigin;
}, setEvalOrigin: function(n) {
  if (n instanceof oi) this.evalOrigin = n;
  else if (n instanceof Object) this.evalOrigin = new oi(n);
  else throw new TypeError("Eval Origin must be an Object or StackFrame");
}, toString: function() {
  var n = this.getFileName() || "", t = this.getLineNumber() || "", e = this.getColumnNumber() || "", i = this.getFunctionName() || "";
  return this.getIsEval() ? n ? "[eval] (" + n + ":" + t + ":" + e + ")" : "[eval]:" + t + ":" + e : i ? i + " (" + n + ":" + t + ":" + e + ")" : n + ":" + t + ":" + e;
} };
oi.fromString = At(function(n) {
  var t = n.indexOf("("), e = n.lastIndexOf(")"), i = n.substring(0, t), s = n.substring(t + 1, e).split(","), a = n.substring(e + 1);
  if (a.indexOf("@") === 0) var o = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(a, ""), u = o[1], h = o[2], d = o[3];
  return new oi({ functionName: i, args: s || void 0, fileName: u, lineNumber: h || void 0, columnNumber: d || void 0 });
}, "StackFrame$$fromString");
for (Zl = 0; Zl < zs.length; Zl++) oi.prototype["get" + ol(zs[Zl])] = _u(zs[Zl]), oi.prototype["set" + ol(zs[Zl])] = /* @__PURE__ */ function(n) {
  return function(t) {
    this[n] = !!t;
  };
}(zs[Zl]);
var Zl;
for (El = 0; El < Ds.length; El++) oi.prototype["get" + ol(Ds[El])] = _u(Ds[El]), oi.prototype["set" + ol(Ds[El])] = /* @__PURE__ */ function(n) {
  return function(t) {
    if (!ZQ(t)) throw new TypeError(n + " must be a Number");
    this[n] = Number(t);
  };
}(Ds[El]);
var El;
for (Xl = 0; Xl < Vs.length; Xl++) oi.prototype["get" + ol(Vs[Xl])] = _u(Vs[Xl]), oi.prototype["set" + ol(Vs[Xl])] = /* @__PURE__ */ function(n) {
  return function(t) {
    this[n] = String(t);
  };
}(Vs[Xl]);
var Xl, vO = oi;
function EQ() {
  var n = /^\s*at .*(\S+:\d+|\(native\))/m, t = /^(eval@)?(\[native code])?$/;
  return { parse: At(function(e) {
    if (e.stack && e.stack.match(n)) return this.parseV8OrIE(e);
    if (e.stack) return this.parseFFOrSafari(e);
    throw new Error("Cannot parse given Error object");
  }, "ErrorStackParser$$parse"), extractLocation: At(function(e) {
    if (e.indexOf(":") === -1) return [e];
    var i = /(.+?)(?::(\d+))?(?::(\d+))?$/, s = i.exec(e.replace(/[()]/g, ""));
    return [s[1], s[2] || void 0, s[3] || void 0];
  }, "ErrorStackParser$$extractLocation"), parseV8OrIE: At(function(e) {
    var i = e.stack.split(`
`).filter(function(s) {
      return !!s.match(n);
    }, this);
    return i.map(function(s) {
      s.indexOf("(eval ") > -1 && (s = s.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(,.*$)/g, ""));
      var a = s.replace(/^\s+/, "").replace(/\(eval code/g, "(").replace(/^.*?\s+/, ""), o = a.match(/ (\(.+\)$)/);
      a = o ? a.replace(o[0], "") : a;
      var u = this.extractLocation(o ? o[1] : a), h = o && a || void 0, d = ["eval", "<anonymous>"].indexOf(u[0]) > -1 ? void 0 : u[0];
      return new vO({ functionName: h, fileName: d, lineNumber: u[1], columnNumber: u[2], source: s });
    }, this);
  }, "ErrorStackParser$$parseV8OrIE"), parseFFOrSafari: At(function(e) {
    var i = e.stack.split(`
`).filter(function(s) {
      return !s.match(t);
    }, this);
    return i.map(function(s) {
      if (s.indexOf(" > eval") > -1 && (s = s.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ":$1")), s.indexOf("@") === -1 && s.indexOf(":") === -1) return new vO({ functionName: s });
      var a = /((.*".+"[^@]*)?[^@]*)(?:@)/, o = s.match(a), u = o && o[1] ? o[1] : void 0, h = this.extractLocation(s.replace(a, ""));
      return new vO({ functionName: u, fileName: h[0], lineNumber: h[1], columnNumber: h[2], source: s });
    }, this);
  }, "ErrorStackParser$$parseFFOrSafari") };
}
At(EQ, "ErrorStackParser");
var w$ = new EQ(), T$ = w$, Ji = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string" && !process.browser, XQ = Ji && typeof module < "u" && typeof module.exports < "u" && typeof CQ < "u" && typeof __dirname < "u", $$ = Ji && !XQ, P$ = typeof Deno < "u", _Q = !Ji && !P$, R$ = _Q && typeof window == "object" && typeof document == "object" && typeof document.createElement == "function" && "sessionStorage" in window && typeof importScripts != "function", A$ = _Q && typeof importScripts == "function" && typeof self == "object";
typeof navigator == "object" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Chrome") == -1 && navigator.userAgent.indexOf("Safari") > -1;
var zQ, rd, DQ, fS, up;
async function fp() {
  if (!Ji || (zQ = (await Promise.resolve().then(() => Yi)).default, fS = await Promise.resolve().then(() => Yi), up = await Promise.resolve().then(() => Yi), DQ = (await Promise.resolve().then(() => Yi)).default, rd = await Promise.resolve().then(() => Yi), hp = rd.sep, typeof CQ < "u")) return;
  let n = fS, t = await Promise.resolve().then(() => Yi), e = await Promise.resolve().then(() => Yi), i = await Promise.resolve().then(() => Yi), s = { fs: n, crypto: t, ws: e, child_process: i };
  globalThis.require = function(a) {
    return s[a];
  };
}
At(fp, "initNodeModules");
function VQ(n, t) {
  return rd.resolve(t || ".", n);
}
At(VQ, "node_resolvePath");
function YQ(n, t) {
  return t === void 0 && (t = location), new URL(n, t).toString();
}
At(YQ, "browser_resolvePath");
var ad;
Ji ? ad = VQ : ad = YQ;
var hp;
Ji || (hp = "/");
function UQ(n, t) {
  return n.startsWith("file://") && (n = n.slice(7)), n.includes("://") ? { response: fetch(n) } : { binary: up.readFile(n).then((e) => new Uint8Array(e.buffer, e.byteOffset, e.byteLength)) };
}
At(UQ, "node_getBinaryResponse");
function jQ(n, t) {
  let e = new URL(n, location);
  return { response: fetch(e, t ? { integrity: t } : {}) };
}
At(jQ, "browser_getBinaryResponse");
var fu;
Ji ? fu = UQ : fu = jQ;
async function LQ(n, t) {
  let { response: e, binary: i } = fu(n, t);
  if (i) return i;
  let s = await e;
  if (!s.ok) throw new Error(`Failed to load '${n}': request failed.`);
  return new Uint8Array(await s.arrayBuffer());
}
At(LQ, "loadBinaryFile");
var Nc;
if (R$) Nc = At(async (n) => await import(n), "loadScript");
else if (A$) Nc = At(async (n) => {
  try {
    globalThis.importScripts(n);
  } catch (t) {
    if (t instanceof TypeError) await import(n);
    else throw t;
  }
}, "loadScript");
else if (Ji) Nc = BQ;
else throw new Error("Cannot determine runtime environment");
async function BQ(n) {
  n.startsWith("file://") && (n = n.slice(7)), n.includes("://") ? DQ.runInThisContext(await (await fetch(n)).text()) : await import(zQ.pathToFileURL(n).href);
}
At(BQ, "nodeLoadScript");
async function GQ(n) {
  if (Ji) {
    await fp();
    let t = await up.readFile(n, { encoding: "utf8" });
    return JSON.parse(t);
  } else return await (await fetch(n)).json();
}
At(GQ, "loadLockFile");
async function NQ() {
  if (XQ) return __dirname;
  let n;
  try {
    throw new Error();
  } catch (i) {
    n = i;
  }
  let t = T$.parse(n)[0].fileName;
  if (Ji && !t.startsWith("file://") && (t = `file://${t}`), $$) {
    let i = await Promise.resolve().then(() => Yi);
    return (await Promise.resolve().then(() => Yi)).fileURLToPath(i.dirname(t));
  }
  let e = t.lastIndexOf(hp);
  if (e === -1) throw new Error("Could not extract indexURL path from pyodide module location");
  return t.slice(0, e);
}
At(NQ, "calculateDirname");
function WQ(n) {
  let t = n.FS, e = n.FS.filesystems.MEMFS, i = n.PATH, s = { DIR_MODE: 16895, FILE_MODE: 33279, mount: function(a) {
    if (!a.opts.fileSystemHandle) throw new Error("opts.fileSystemHandle is required");
    return e.mount.apply(null, arguments);
  }, syncfs: async (a, o, u) => {
    try {
      let h = s.getLocalSet(a), d = await s.getRemoteSet(a), p = o ? d : h, g = o ? h : d;
      await s.reconcile(a, p, g), u(null);
    } catch (h) {
      u(h);
    }
  }, getLocalSet: (a) => {
    let o = /* @__PURE__ */ Object.create(null);
    function u(p) {
      return p !== "." && p !== "..";
    }
    At(u, "isRealDir");
    function h(p) {
      return (g) => i.join2(p, g);
    }
    At(h, "toAbsolute");
    let d = t.readdir(a.mountpoint).filter(u).map(h(a.mountpoint));
    for (; d.length; ) {
      let p = d.pop(), g = t.stat(p);
      t.isDir(g.mode) && d.push.apply(d, t.readdir(p).filter(u).map(h(p))), o[p] = { timestamp: g.mtime, mode: g.mode };
    }
    return { type: "local", entries: o };
  }, getRemoteSet: async (a) => {
    let o = /* @__PURE__ */ Object.create(null), u = await M$(a.opts.fileSystemHandle);
    for (let [h, d] of u) h !== "." && (o[i.join2(a.mountpoint, h)] = { timestamp: d.kind === "file" ? new Date((await d.getFile()).lastModified) : /* @__PURE__ */ new Date(), mode: d.kind === "file" ? s.FILE_MODE : s.DIR_MODE });
    return { type: "remote", entries: o, handles: u };
  }, loadLocalEntry: (a) => {
    let o = t.lookupPath(a).node, u = t.stat(a);
    if (t.isDir(u.mode)) return { timestamp: u.mtime, mode: u.mode };
    if (t.isFile(u.mode)) return o.contents = e.getFileDataAsTypedArray(o), { timestamp: u.mtime, mode: u.mode, contents: o.contents };
    throw new Error("node type not supported");
  }, storeLocalEntry: (a, o) => {
    if (t.isDir(o.mode)) t.mkdirTree(a, o.mode);
    else if (t.isFile(o.mode)) t.writeFile(a, o.contents, { canOwn: !0 });
    else throw new Error("node type not supported");
    t.chmod(a, o.mode), t.utime(a, o.timestamp, o.timestamp);
  }, removeLocalEntry: (a) => {
    var o = t.stat(a);
    t.isDir(o.mode) ? t.rmdir(a) : t.isFile(o.mode) && t.unlink(a);
  }, loadRemoteEntry: async (a) => {
    if (a.kind === "file") {
      let o = await a.getFile();
      return { contents: new Uint8Array(await o.arrayBuffer()), mode: s.FILE_MODE, timestamp: new Date(o.lastModified) };
    } else {
      if (a.kind === "directory") return { mode: s.DIR_MODE, timestamp: /* @__PURE__ */ new Date() };
      throw new Error("unknown kind: " + a.kind);
    }
  }, storeRemoteEntry: async (a, o, u) => {
    let h = a.get(i.dirname(o)), d = t.isFile(u.mode) ? await h.getFileHandle(i.basename(o), { create: !0 }) : await h.getDirectoryHandle(i.basename(o), { create: !0 });
    if (d.kind === "file") {
      let p = await d.createWritable();
      await p.write(u.contents), await p.close();
    }
    a.set(o, d);
  }, removeRemoteEntry: async (a, o) => {
    await a.get(i.dirname(o)).removeEntry(i.basename(o)), a.delete(o);
  }, reconcile: async (a, o, u) => {
    let h = 0, d = [];
    Object.keys(o.entries).forEach(function(y) {
      let Q = o.entries[y], b = u.entries[y];
      (!b || t.isFile(Q.mode) && Q.timestamp.getTime() > b.timestamp.getTime()) && (d.push(y), h++);
    }), d.sort();
    let p = [];
    if (Object.keys(u.entries).forEach(function(y) {
      o.entries[y] || (p.push(y), h++);
    }), p.sort().reverse(), !h) return;
    let g = o.type === "remote" ? o.handles : u.handles;
    for (let y of d) {
      let Q = i.normalize(y.replace(a.mountpoint, "/")).substring(1);
      if (u.type === "local") {
        let b = g.get(Q), x = await s.loadRemoteEntry(b);
        s.storeLocalEntry(y, x);
      } else {
        let b = s.loadLocalEntry(y);
        await s.storeRemoteEntry(g, Q, b);
      }
    }
    for (let y of p) if (u.type === "local") s.removeLocalEntry(y);
    else {
      let Q = i.normalize(y.replace(a.mountpoint, "/")).substring(1);
      await s.removeRemoteEntry(g, Q);
    }
  } };
  n.FS.filesystems.NATIVEFS_ASYNC = s;
}
At(WQ, "initializeNativeFS");
var M$ = At(async (n) => {
  let t = [];
  async function e(s) {
    for await (let a of s.values()) t.push(a), a.kind === "directory" && await e(a);
  }
  At(e, "collect"), await e(n);
  let i = /* @__PURE__ */ new Map();
  i.set(".", n);
  for (let s of t) {
    let a = (await n.resolve(s)).join("/");
    i.set(a, s);
  }
  return i;
}, "getFsHandles");
function HQ(n) {
  let t = { noImageDecoding: !0, noAudioDecoding: !0, noWasmDecoding: !1, preRun: tv(n), quit(e, i) {
    throw t.exited = { status: e, toThrow: i }, i;
  }, print: n.stdout, printErr: n.stderr, thisProgram: n._sysExecutable, arguments: n.args, API: { config: n }, locateFile: (e) => n.indexURL + e, instantiateWasm: ev(n.indexURL) };
  return t;
}
At(HQ, "createSettings");
function KQ(n) {
  return function(t) {
    let e = "/";
    try {
      t.FS.mkdirTree(n);
    } catch (i) {
      console.error(`Error occurred while making a home directory '${n}':`), console.error(i), console.error(`Using '${e}' for a home directory instead`), n = e;
    }
    t.FS.chdir(n);
  };
}
At(KQ, "createHomeDirectory");
function JQ(n) {
  return function(t) {
    Object.assign(t.ENV, n);
  };
}
At(JQ, "setEnvironment");
function IQ(n) {
  return n ? [async (t) => {
    t.addRunDependency("fsInitHook");
    try {
      await n(t.FS, { sitePackages: t.API.sitePackages });
    } finally {
      t.removeRunDependency("fsInitHook");
    }
  }] : [];
}
At(IQ, "callFsInitHook");
function FQ(n) {
  let t = LQ(n);
  return async (e) => {
    let i = e._py_version_major(), s = e._py_version_minor();
    e.FS.mkdirTree("/lib"), e.API.sitePackages = `/lib/python${i}.${s}/site-packages`, e.FS.mkdirTree(e.API.sitePackages), e.addRunDependency("install-stdlib");
    try {
      let a = await t;
      e.FS.writeFile(`/lib/python${i}${s}.zip`, a);
    } catch (a) {
      console.error("Error occurred while installing the standard library:"), console.error(a);
    } finally {
      e.removeRunDependency("install-stdlib");
    }
  };
}
At(FQ, "installStdlib");
function tv(n) {
  let t;
  return n.stdLibURL != null ? t = n.stdLibURL : t = n.indexURL + "python_stdlib.zip", [...IQ(n.fsInit), FQ(t), KQ(n.env.HOME), JQ(n.env), WQ];
}
At(tv, "getFileSystemInitializationFuncs");
function ev(n) {
  if (typeof WasmOffsetConverter < "u") return;
  let { binary: t, response: e } = fu(n + "pyodide.asm.wasm");
  return function(i, s) {
    return async function() {
      try {
        let a;
        e ? a = await WebAssembly.instantiateStreaming(e, i) : a = await WebAssembly.instantiate(await t, i);
        let { instance: o, module: u } = a;
        s(o, u);
      } catch (a) {
        console.warn("wasm instantiation failed!"), console.warn(a);
      }
    }(), {};
  };
}
At(ev, "getInstantiateWasmFunc");
var hS = "0.27.6";
async function iv(n = {}) {
  var t, e;
  await fp();
  let i = n.indexURL || await NQ();
  i = ad(i), i.endsWith("/") || (i += "/"), n.indexURL = i;
  let s = { fullStdLib: !1, jsglobals: globalThis, stdin: globalThis.prompt ? globalThis.prompt : void 0, lockFileURL: i + "pyodide-lock.json", args: [], env: {}, packageCacheDir: i, packages: [], enableRunUntilComplete: !1, checkAPIVersion: !0, BUILD_ID: "58ff83c394cd9a3d28be50b7475d122087896295981974b756ce5fc170e523cf" }, a = Object.assign(s, n);
  (t = a.env).HOME ?? (t.HOME = "/home/pyodide"), (e = a.env).PYTHONINSPECT ?? (e.PYTHONINSPECT = "1");
  let o = HQ(a), u = o.API;
  if (u.lockFilePromise = GQ(a.lockFileURL), typeof _createPyodideModule != "function") {
    let y = `${a.indexURL}pyodide.asm.js`;
    await Nc(y);
  }
  let h;
  if (n._loadSnapshot) {
    let y = await n._loadSnapshot;
    ArrayBuffer.isView(y) ? h = y : h = new Uint8Array(y), o.noInitialRun = !0, o.INITIAL_MEMORY = h.length;
  }
  let d = await _createPyodideModule(o);
  if (o.exited) throw o.exited.toThrow;
  if (n.pyproxyToStringRepr && u.setPyProxyToStringMethod(!0), u.version !== hS && a.checkAPIVersion) throw new Error(`Pyodide version does not match: '${hS}' <==> '${u.version}'. If you updated the Pyodide version, make sure you also updated the 'indexURL' parameter passed to loadPyodide.`);
  d.locateFile = (y) => {
    throw new Error("Didn't expect to load any more file_packager files!");
  };
  let p;
  h && (p = u.restoreSnapshot(h));
  let g = u.finalizeBootstrap(p, n._snapshotDeserializer);
  return u.sys.path.insert(0, u.config.env.HOME), g.version.includes("dev") || u.setCdnUrl(`https://cdn.jsdelivr.net/pyodide/v${g.version}/full/`), u._pyodide.set_excepthook(), await u.packageIndexReady, u.initializeStreams(a.stdin, a.stdout, a.stderr), g;
}
At(iv, "loadPyodide");
const nv = St.createContext(null);
function lv() {
  const n = St.useContext(nv);
  if (!n)
    throw new Error("usePythonAtomScope must be used within a PythonAtomScopeProvider");
  return n;
}
function q$() {
  const n = Ui(""), t = Ui(null), e = Ui(!1), i = Ui(null, async (a, o) => {
    try {
      if (console.log("Loading Pyodide..."), !window.pyodide) {
        window.pyodide = await iv();
        const u = [
          "./packages/micropip-0.9.0-py3-none-any.whl",
          "./packages/annotated_types-0.6.0-py3-none-any.whl",
          "./packages/typing_extensions-4.11.0-py3-none-any.whl",
          "./packages/pydantic_core-2.27.2-cp312-cp312-pyodide_2024_0_wasm32.whl",
          "./packages/pydantic-2.10.5-py3-none-any.whl",
          "./packages/molviewspec-1.6.0-py3-none-any.whl"
        ];
        await Promise.all(
          u.map((h) => window.pyodide.loadPackage(h))
        ), console.log("Pyodide loaded successfully!");
      }
      return o(e, !0), !0;
    } catch (u) {
      return console.error("Error initializing Pyodide:", u), !1;
    }
  }), s = Ui(
    (a) => a(n),
    async (a, o) => {
      if (a(e))
        try {
          const u = a(n), h = await window.pyodide.runPythonAsync(u);
          o(t, JSON.parse(h));
        } catch (u) {
          console.error("Error executing Python code:", u);
        }
    }
  );
  return {
    codeAtom: n,
    molViewSpecJsonAtom: t,
    pyodideReadyAtom: e,
    initializePyodideAtom: i,
    executePyCodeAtom: s
  };
}
function C$({ initialCode: n = "", children: t }) {
  const e = St.useMemo(() => q$(), []);
  return /* @__PURE__ */ ie.createElement(qQ, null, /* @__PURE__ */ ie.createElement(nv.Provider, { value: e }, t));
}
const sv = St.createContext(null);
function rv() {
  const n = St.useContext(sv);
  if (!n)
    throw new Error("useJSAtomScope must be used within a JSAtomScopeProvider");
  return n;
}
function Z$() {
  const n = Ui(""), t = Ui(null), e = Ui(!1), i = Ui(null, async (a, o) => {
    try {
      return window.molstar ? window.molstar.PluginExtensions && window.molstar.PluginExtensions.mvs ? (o(e, !0), console.log("Molstar MVS extension loaded successfully!"), !0) : (console.error("Molstar loaded but MVS extension is not available"), !1) : (console.log("Waiting for molstar to load..."), new Promise((u) => {
        const h = setInterval(() => {
          window.molstar && window.molstar.PluginExtensions && window.molstar.PluginExtensions.mvs && (clearInterval(h), o(e, !0), console.log("Molstar MVS extension loaded successfully!"), u(!0));
        }, 100);
        setTimeout(() => {
          clearInterval(h), (!window.molstar || !window.molstar.PluginExtensions || !window.molstar.PluginExtensions.mvs) && (console.error("Timed out waiting for Molstar MVS extension"), u(!1));
        }, 1e4);
      }));
    } catch (u) {
      return console.error("Error checking Molstar availability:", u), !1;
    }
  }), s = Ui(
    (a) => a(n),
    async (a, o) => {
      if (!a(e) && (console.log("Molstar not ready yet, initializing..."), !await i(a, o))) {
        console.error("Could not initialize Molstar");
        return;
      }
      try {
        const u = a(n);
        console.log("Executing JS code:", u);
        const h = new Function(`
          try {
            // Ensure molstar and its MVS extension are available
            if (!window.molstar || !window.molstar.PluginExtensions || !window.molstar.PluginExtensions.mvs) {
              throw new Error("Molstar MVS extension is not available");
            }



            // Execute the user code
            ${u}

            // Return the MVS data directly
            return mvsData;
          } catch (error) {
            console.error("Error executing JS code:", error);
            throw error;
          }
        `);
        try {
          console.log("Calling evalFunction");
          const d = h();
          console.log("Execution result:", d), d ? (console.log("Using result directly"), o(t, d)) : console.error("No valid MVS data was generated");
        } catch (d) {
          console.error("Error during JS execution:", d);
        }
      } catch (u) {
        console.error("Error setting up JS execution:", u);
      }
    }
  );
  return {
    codeAtom: n,
    molViewSpecJsonAtom: t,
    molstarReadyAtom: e,
    initializeMolstarAtom: i,
    executeJsCodeAtom: s
  };
}
function E$({ initialCode: n = "", children: t }) {
  const e = St.useMemo(() => Z$(), []);
  return /* @__PURE__ */ ie.createElement(qQ, null, /* @__PURE__ */ ie.createElement(sv.Provider, { value: e }, t));
}
function od() {
  return od = Object.assign ? Object.assign.bind() : function(n) {
    for (var t = 1; t < arguments.length; t++) {
      var e = arguments[t];
      for (var i in e) ({}).hasOwnProperty.call(e, i) && (n[i] = e[i]);
    }
    return n;
  }, od.apply(null, arguments);
}
function X$(n, t) {
  if (n == null) return {};
  var e = {};
  for (var i in n) if ({}.hasOwnProperty.call(n, i)) {
    if (t.indexOf(i) !== -1) continue;
    e[i] = n[i];
  }
  return e;
}
let cd = [], av = [];
(() => {
  let n = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((t) => t ? parseInt(t, 36) : 1);
  for (let t = 0, e = 0; t < n.length; t++)
    (t % 2 ? av : cd).push(e = e + n[t]);
})();
function _$(n) {
  if (n < 768) return !1;
  for (let t = 0, e = cd.length; ; ) {
    let i = t + e >> 1;
    if (n < cd[i]) e = i;
    else if (n >= av[i]) t = i + 1;
    else return !0;
    if (t == e) return !1;
  }
}
function OS(n) {
  return n >= 127462 && n <= 127487;
}
const dS = 8205;
function z$(n, t, e = !0, i = !0) {
  return (e ? ov : D$)(n, t, i);
}
function ov(n, t, e) {
  if (t == n.length) return t;
  t && cv(n.charCodeAt(t)) && uv(n.charCodeAt(t - 1)) && t--;
  let i = bO(n, t);
  for (t += pS(i); t < n.length; ) {
    let s = bO(n, t);
    if (i == dS || s == dS || e && _$(s))
      t += pS(s), i = s;
    else if (OS(s)) {
      let a = 0, o = t - 2;
      for (; o >= 0 && OS(bO(n, o)); )
        a++, o -= 2;
      if (a % 2 == 0) break;
      t += 2;
    } else
      break;
  }
  return t;
}
function D$(n, t, e) {
  for (; t > 0; ) {
    let i = ov(n, t - 2, e);
    if (i < t) return i;
    t--;
  }
  return 0;
}
function bO(n, t) {
  let e = n.charCodeAt(t);
  if (!uv(e) || t + 1 == n.length) return e;
  let i = n.charCodeAt(t + 1);
  return cv(i) ? (e - 55296 << 10) + (i - 56320) + 65536 : e;
}
function cv(n) {
  return n >= 56320 && n < 57344;
}
function uv(n) {
  return n >= 55296 && n < 56320;
}
function pS(n) {
  return n < 65536 ? 1 : 2;
}
class Rt {
  /**
  Get the line description around the given position.
  */
  lineAt(t) {
    if (t < 0 || t > this.length)
      throw new RangeError(`Invalid position ${t} in document of length ${this.length}`);
    return this.lineInner(t, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(t) {
    if (t < 1 || t > this.lines)
      throw new RangeError(`Invalid line number ${t} in ${this.lines}-line document`);
    return this.lineInner(t, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(t, e, i) {
    [t, e] = Is(this, t, e);
    let s = [];
    return this.decompose(
      0,
      t,
      s,
      2
      /* Open.To */
    ), i.length && i.decompose(
      0,
      i.length,
      s,
      3
      /* Open.To */
    ), this.decompose(
      e,
      this.length,
      s,
      1
      /* Open.From */
    ), ji.from(s, this.length - (e - t) + i.length);
  }
  /**
  Append another document to this one.
  */
  append(t) {
    return this.replace(this.length, this.length, t);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(t, e = this.length) {
    [t, e] = Is(this, t, e);
    let i = [];
    return this.decompose(t, e, i, 0), ji.from(i, e - t);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(t) {
    if (t == this)
      return !0;
    if (t.length != this.length || t.lines != this.lines)
      return !1;
    let e = this.scanIdentical(t, 1), i = this.length - this.scanIdentical(t, -1), s = new ka(this), a = new ka(t);
    for (let o = e, u = e; ; ) {
      if (s.next(o), a.next(o), o = 0, s.lineBreak != a.lineBreak || s.done != a.done || s.value != a.value)
        return !1;
      if (u += s.value.length, s.done || u >= i)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(t = 1) {
    return new ka(this, t);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(t, e = this.length) {
    return new fv(this, t, e);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(t, e) {
    let i;
    if (t == null)
      i = this.iter();
    else {
      e == null && (e = this.lines + 1);
      let s = this.line(t).from;
      i = this.iterRange(s, Math.max(s, e == this.lines + 1 ? this.length : e <= 1 ? 0 : this.line(e - 1).to));
    }
    return new hv(i);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let t = [];
    return this.flatten(t), t;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(t) {
    if (t.length == 0)
      throw new RangeError("A document must have at least one line");
    return t.length == 1 && !t[0] ? Rt.empty : t.length <= 32 ? new ee(t) : ji.from(ee.split(t, []));
  }
}
class ee extends Rt {
  constructor(t, e = V$(t)) {
    super(), this.text = t, this.length = e;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(t, e, i, s) {
    for (let a = 0; ; a++) {
      let o = this.text[a], u = s + o.length;
      if ((e ? i : u) >= t)
        return new Y$(s, u, i, o);
      s = u + 1, i++;
    }
  }
  decompose(t, e, i, s) {
    let a = t <= 0 && e >= this.length ? this : new ee(mS(this.text, t, e), Math.min(e, this.length) - Math.max(0, t));
    if (s & 1) {
      let o = i.pop(), u = Wc(a.text, o.text.slice(), 0, a.length);
      if (u.length <= 32)
        i.push(new ee(u, o.length + a.length));
      else {
        let h = u.length >> 1;
        i.push(new ee(u.slice(0, h)), new ee(u.slice(h)));
      }
    } else
      i.push(a);
  }
  replace(t, e, i) {
    if (!(i instanceof ee))
      return super.replace(t, e, i);
    [t, e] = Is(this, t, e);
    let s = Wc(this.text, Wc(i.text, mS(this.text, 0, t)), e), a = this.length + i.length - (e - t);
    return s.length <= 32 ? new ee(s, a) : ji.from(ee.split(s, []), a);
  }
  sliceString(t, e = this.length, i = `
`) {
    [t, e] = Is(this, t, e);
    let s = "";
    for (let a = 0, o = 0; a <= e && o < this.text.length; o++) {
      let u = this.text[o], h = a + u.length;
      a > t && o && (s += i), t < h && e > a && (s += u.slice(Math.max(0, t - a), e - a)), a = h + 1;
    }
    return s;
  }
  flatten(t) {
    for (let e of this.text)
      t.push(e);
  }
  scanIdentical() {
    return 0;
  }
  static split(t, e) {
    let i = [], s = -1;
    for (let a of t)
      i.push(a), s += a.length + 1, i.length == 32 && (e.push(new ee(i, s)), i = [], s = -1);
    return s > -1 && e.push(new ee(i, s)), e;
  }
}
class ji extends Rt {
  constructor(t, e) {
    super(), this.children = t, this.length = e, this.lines = 0;
    for (let i of t)
      this.lines += i.lines;
  }
  lineInner(t, e, i, s) {
    for (let a = 0; ; a++) {
      let o = this.children[a], u = s + o.length, h = i + o.lines - 1;
      if ((e ? h : u) >= t)
        return o.lineInner(t, e, i, s);
      s = u + 1, i = h + 1;
    }
  }
  decompose(t, e, i, s) {
    for (let a = 0, o = 0; o <= e && a < this.children.length; a++) {
      let u = this.children[a], h = o + u.length;
      if (t <= h && e >= o) {
        let d = s & ((o <= t ? 1 : 0) | (h >= e ? 2 : 0));
        o >= t && h <= e && !d ? i.push(u) : u.decompose(t - o, e - o, i, d);
      }
      o = h + 1;
    }
  }
  replace(t, e, i) {
    if ([t, e] = Is(this, t, e), i.lines < this.lines)
      for (let s = 0, a = 0; s < this.children.length; s++) {
        let o = this.children[s], u = a + o.length;
        if (t >= a && e <= u) {
          let h = o.replace(t - a, e - a, i), d = this.lines - o.lines + h.lines;
          if (h.lines < d >> 4 && h.lines > d >> 6) {
            let p = this.children.slice();
            return p[s] = h, new ji(p, this.length - (e - t) + i.length);
          }
          return super.replace(a, u, h);
        }
        a = u + 1;
      }
    return super.replace(t, e, i);
  }
  sliceString(t, e = this.length, i = `
`) {
    [t, e] = Is(this, t, e);
    let s = "";
    for (let a = 0, o = 0; a < this.children.length && o <= e; a++) {
      let u = this.children[a], h = o + u.length;
      o > t && a && (s += i), t < h && e > o && (s += u.sliceString(t - o, e - o, i)), o = h + 1;
    }
    return s;
  }
  flatten(t) {
    for (let e of this.children)
      e.flatten(t);
  }
  scanIdentical(t, e) {
    if (!(t instanceof ji))
      return 0;
    let i = 0, [s, a, o, u] = e > 0 ? [0, 0, this.children.length, t.children.length] : [this.children.length - 1, t.children.length - 1, -1, -1];
    for (; ; s += e, a += e) {
      if (s == o || a == u)
        return i;
      let h = this.children[s], d = t.children[a];
      if (h != d)
        return i + h.scanIdentical(d, e);
      i += h.length + 1;
    }
  }
  static from(t, e = t.reduce((i, s) => i + s.length + 1, -1)) {
    let i = 0;
    for (let Q of t)
      i += Q.lines;
    if (i < 32) {
      let Q = [];
      for (let b of t)
        b.flatten(Q);
      return new ee(Q, e);
    }
    let s = Math.max(
      32,
      i >> 5
      /* Tree.BranchShift */
    ), a = s << 1, o = s >> 1, u = [], h = 0, d = -1, p = [];
    function g(Q) {
      let b;
      if (Q.lines > a && Q instanceof ji)
        for (let x of Q.children)
          g(x);
      else Q.lines > o && (h > o || !h) ? (y(), u.push(Q)) : Q instanceof ee && h && (b = p[p.length - 1]) instanceof ee && Q.lines + b.lines <= 32 ? (h += Q.lines, d += Q.length + 1, p[p.length - 1] = new ee(b.text.concat(Q.text), b.length + 1 + Q.length)) : (h + Q.lines > s && y(), h += Q.lines, d += Q.length + 1, p.push(Q));
    }
    function y() {
      h != 0 && (u.push(p.length == 1 ? p[0] : ji.from(p, d)), d = -1, h = p.length = 0);
    }
    for (let Q of t)
      g(Q);
    return y(), u.length == 1 ? u[0] : new ji(u, e);
  }
}
Rt.empty = /* @__PURE__ */ new ee([""], 0);
function V$(n) {
  let t = -1;
  for (let e of n)
    t += e.length + 1;
  return t;
}
function Wc(n, t, e = 0, i = 1e9) {
  for (let s = 0, a = 0, o = !0; a < n.length && s <= i; a++) {
    let u = n[a], h = s + u.length;
    h >= e && (h > i && (u = u.slice(0, i - s)), s < e && (u = u.slice(e - s)), o ? (t[t.length - 1] += u, o = !1) : t.push(u)), s = h + 1;
  }
  return t;
}
function mS(n, t, e) {
  return Wc(n, [""], t, e);
}
class ka {
  constructor(t, e = 1) {
    this.dir = e, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [t], this.offsets = [e > 0 ? 1 : (t instanceof ee ? t.text.length : t.children.length) << 1];
  }
  nextInner(t, e) {
    for (this.done = this.lineBreak = !1; ; ) {
      let i = this.nodes.length - 1, s = this.nodes[i], a = this.offsets[i], o = a >> 1, u = s instanceof ee ? s.text.length : s.children.length;
      if (o == (e > 0 ? u : 0)) {
        if (i == 0)
          return this.done = !0, this.value = "", this;
        e > 0 && this.offsets[i - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((a & 1) == (e > 0 ? 0 : 1)) {
        if (this.offsets[i] += e, t == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        t--;
      } else if (s instanceof ee) {
        let h = s.text[o + (e < 0 ? -1 : 0)];
        if (this.offsets[i] += e, h.length > Math.max(0, t))
          return this.value = t == 0 ? h : e > 0 ? h.slice(t) : h.slice(0, h.length - t), this;
        t -= h.length;
      } else {
        let h = s.children[o + (e < 0 ? -1 : 0)];
        t > h.length ? (t -= h.length, this.offsets[i] += e) : (e < 0 && this.offsets[i]--, this.nodes.push(h), this.offsets.push(e > 0 ? 1 : (h instanceof ee ? h.text.length : h.children.length) << 1));
      }
    }
  }
  next(t = 0) {
    return t < 0 && (this.nextInner(-t, -this.dir), t = this.value.length), this.nextInner(t, this.dir);
  }
}
class fv {
  constructor(t, e, i) {
    this.value = "", this.done = !1, this.cursor = new ka(t, e > i ? -1 : 1), this.pos = e > i ? t.length : 0, this.from = Math.min(e, i), this.to = Math.max(e, i);
  }
  nextInner(t, e) {
    if (e < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    t += Math.max(0, e < 0 ? this.pos - this.to : this.from - this.pos);
    let i = e < 0 ? this.pos - this.from : this.to - this.pos;
    t > i && (t = i), i -= t;
    let { value: s } = this.cursor.next(t);
    return this.pos += (s.length + t) * e, this.value = s.length <= i ? s : e < 0 ? s.slice(s.length - i) : s.slice(0, i), this.done = !this.value, this;
  }
  next(t = 0) {
    return t < 0 ? t = Math.max(t, this.from - this.pos) : t > 0 && (t = Math.min(t, this.to - this.pos)), this.nextInner(t, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class hv {
  constructor(t) {
    this.inner = t, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(t = 0) {
    let { done: e, lineBreak: i, value: s } = this.inner.next(t);
    return e && this.afterBreak ? (this.value = "", this.afterBreak = !1) : e ? (this.done = !0, this.value = "") : i ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = s, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (Rt.prototype[Symbol.iterator] = function() {
  return this.iter();
}, ka.prototype[Symbol.iterator] = fv.prototype[Symbol.iterator] = hv.prototype[Symbol.iterator] = function() {
  return this;
});
class Y$ {
  /**
  @internal
  */
  constructor(t, e, i, s) {
    this.from = t, this.to = e, this.number = i, this.text = s;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function Is(n, t, e) {
  return t = Math.max(0, Math.min(n.length, t)), [t, Math.max(t, Math.min(n.length, e))];
}
function Te(n, t, e = !0, i = !0) {
  return z$(n, t, e, i);
}
function U$(n) {
  return n >= 56320 && n < 57344;
}
function j$(n) {
  return n >= 55296 && n < 56320;
}
function Ue(n, t) {
  let e = n.charCodeAt(t);
  if (!j$(e) || t + 1 == n.length)
    return e;
  let i = n.charCodeAt(t + 1);
  return U$(i) ? (e - 55296 << 10) + (i - 56320) + 65536 : e;
}
function Op(n) {
  return n <= 65535 ? String.fromCharCode(n) : (n -= 65536, String.fromCharCode((n >> 10) + 55296, (n & 1023) + 56320));
}
function Li(n) {
  return n < 65536 ? 1 : 2;
}
const ud = /\r\n?|\n/;
var we = /* @__PURE__ */ function(n) {
  return n[n.Simple = 0] = "Simple", n[n.TrackDel = 1] = "TrackDel", n[n.TrackBefore = 2] = "TrackBefore", n[n.TrackAfter = 3] = "TrackAfter", n;
}(we || (we = {}));
class Hi {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(t) {
    this.sections = t;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let t = 0;
    for (let e = 0; e < this.sections.length; e += 2)
      t += this.sections[e];
    return t;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let t = 0;
    for (let e = 0; e < this.sections.length; e += 2) {
      let i = this.sections[e + 1];
      t += i < 0 ? this.sections[e] : i;
    }
    return t;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(t) {
    for (let e = 0, i = 0, s = 0; e < this.sections.length; ) {
      let a = this.sections[e++], o = this.sections[e++];
      o < 0 ? (t(i, s, a), s += a) : s += o, i += a;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(t, e = !1) {
    fd(this, t, e);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let t = [];
    for (let e = 0; e < this.sections.length; ) {
      let i = this.sections[e++], s = this.sections[e++];
      s < 0 ? t.push(i, s) : t.push(s, i);
    }
    return new Hi(t);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(t) {
    return this.empty ? t : t.empty ? this : Ov(this, t);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(t, e = !1) {
    return t.empty ? this : hd(this, t, e);
  }
  mapPos(t, e = -1, i = we.Simple) {
    let s = 0, a = 0;
    for (let o = 0; o < this.sections.length; ) {
      let u = this.sections[o++], h = this.sections[o++], d = s + u;
      if (h < 0) {
        if (d > t)
          return a + (t - s);
        a += u;
      } else {
        if (i != we.Simple && d >= t && (i == we.TrackDel && s < t && d > t || i == we.TrackBefore && s < t || i == we.TrackAfter && d > t))
          return null;
        if (d > t || d == t && e < 0 && !u)
          return t == s || e < 0 ? a : a + h;
        a += h;
      }
      s = d;
    }
    if (t > s)
      throw new RangeError(`Position ${t} is out of range for changeset of length ${s}`);
    return a;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(t, e = t) {
    for (let i = 0, s = 0; i < this.sections.length && s <= e; ) {
      let a = this.sections[i++], o = this.sections[i++], u = s + a;
      if (o >= 0 && s <= e && u >= t)
        return s < t && u > e ? "cover" : !0;
      s = u;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let t = "";
    for (let e = 0; e < this.sections.length; ) {
      let i = this.sections[e++], s = this.sections[e++];
      t += (t ? " " : "") + i + (s >= 0 ? ":" + s : "");
    }
    return t;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(t) {
    if (!Array.isArray(t) || t.length % 2 || t.some((e) => typeof e != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new Hi(t);
  }
  /**
  @internal
  */
  static create(t) {
    return new Hi(t);
  }
}
class Oe extends Hi {
  constructor(t, e) {
    super(t), this.inserted = e;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(t) {
    if (this.length != t.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return fd(this, (e, i, s, a, o) => t = t.replace(s, s + (i - e), o), !1), t;
  }
  mapDesc(t, e = !1) {
    return hd(this, t, e, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(t) {
    let e = this.sections.slice(), i = [];
    for (let s = 0, a = 0; s < e.length; s += 2) {
      let o = e[s], u = e[s + 1];
      if (u >= 0) {
        e[s] = u, e[s + 1] = o;
        let h = s >> 1;
        for (; i.length < h; )
          i.push(Rt.empty);
        i.push(o ? t.slice(a, a + o) : Rt.empty);
      }
      a += o;
    }
    return new Oe(e, i);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(t) {
    return this.empty ? t : t.empty ? this : Ov(this, t, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(t, e = !1) {
    return t.empty ? this : hd(this, t, e, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(t, e = !1) {
    fd(this, t, e);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return Hi.create(this.sections);
  }
  /**
  @internal
  */
  filter(t) {
    let e = [], i = [], s = [], a = new Aa(this);
    t: for (let o = 0, u = 0; ; ) {
      let h = o == t.length ? 1e9 : t[o++];
      for (; u < h || u == h && a.len == 0; ) {
        if (a.done)
          break t;
        let p = Math.min(a.len, h - u);
        Me(s, p, -1);
        let g = a.ins == -1 ? -1 : a.off == 0 ? a.ins : 0;
        Me(e, p, g), g > 0 && ll(i, e, a.text), a.forward(p), u += p;
      }
      let d = t[o++];
      for (; u < d; ) {
        if (a.done)
          break t;
        let p = Math.min(a.len, d - u);
        Me(e, p, -1), Me(s, p, a.ins == -1 ? -1 : a.off == 0 ? a.ins : 0), a.forward(p), u += p;
      }
    }
    return {
      changes: new Oe(e, i),
      filtered: Hi.create(s)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let t = [];
    for (let e = 0; e < this.sections.length; e += 2) {
      let i = this.sections[e], s = this.sections[e + 1];
      s < 0 ? t.push(i) : s == 0 ? t.push([i]) : t.push([i].concat(this.inserted[e >> 1].toJSON()));
    }
    return t;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(t, e, i) {
    let s = [], a = [], o = 0, u = null;
    function h(p = !1) {
      if (!p && !s.length)
        return;
      o < e && Me(s, e - o, -1);
      let g = new Oe(s, a);
      u = u ? u.compose(g.map(u)) : g, s = [], a = [], o = 0;
    }
    function d(p) {
      if (Array.isArray(p))
        for (let g of p)
          d(g);
      else if (p instanceof Oe) {
        if (p.length != e)
          throw new RangeError(`Mismatched change set length (got ${p.length}, expected ${e})`);
        h(), u = u ? u.compose(p.map(u)) : p;
      } else {
        let { from: g, to: y = g, insert: Q } = p;
        if (g > y || g < 0 || y > e)
          throw new RangeError(`Invalid change range ${g} to ${y} (in doc of length ${e})`);
        let b = Q ? typeof Q == "string" ? Rt.of(Q.split(i || ud)) : Q : Rt.empty, x = b.length;
        if (g == y && x == 0)
          return;
        g < o && h(), g > o && Me(s, g - o, -1), Me(s, y - g, x), ll(a, s, b), o = y;
      }
    }
    return d(t), h(!u), u;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(t) {
    return new Oe(t ? [t, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(t) {
    if (!Array.isArray(t))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let e = [], i = [];
    for (let s = 0; s < t.length; s++) {
      let a = t[s];
      if (typeof a == "number")
        e.push(a, -1);
      else {
        if (!Array.isArray(a) || typeof a[0] != "number" || a.some((o, u) => u && typeof o != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (a.length == 1)
          e.push(a[0], 0);
        else {
          for (; i.length < s; )
            i.push(Rt.empty);
          i[s] = Rt.of(a.slice(1)), e.push(a[0], i[s].length);
        }
      }
    }
    return new Oe(e, i);
  }
  /**
  @internal
  */
  static createSet(t, e) {
    return new Oe(t, e);
  }
}
function Me(n, t, e, i = !1) {
  if (t == 0 && e <= 0)
    return;
  let s = n.length - 2;
  s >= 0 && e <= 0 && e == n[s + 1] ? n[s] += t : s >= 0 && t == 0 && n[s] == 0 ? n[s + 1] += e : i ? (n[s] += t, n[s + 1] += e) : n.push(t, e);
}
function ll(n, t, e) {
  if (e.length == 0)
    return;
  let i = t.length - 2 >> 1;
  if (i < n.length)
    n[n.length - 1] = n[n.length - 1].append(e);
  else {
    for (; n.length < i; )
      n.push(Rt.empty);
    n.push(e);
  }
}
function fd(n, t, e) {
  let i = n.inserted;
  for (let s = 0, a = 0, o = 0; o < n.sections.length; ) {
    let u = n.sections[o++], h = n.sections[o++];
    if (h < 0)
      s += u, a += u;
    else {
      let d = s, p = a, g = Rt.empty;
      for (; d += u, p += h, h && i && (g = g.append(i[o - 2 >> 1])), !(e || o == n.sections.length || n.sections[o + 1] < 0); )
        u = n.sections[o++], h = n.sections[o++];
      t(s, d, a, p, g), s = d, a = p;
    }
  }
}
function hd(n, t, e, i = !1) {
  let s = [], a = i ? [] : null, o = new Aa(n), u = new Aa(t);
  for (let h = -1; ; ) {
    if (o.done && u.len || u.done && o.len)
      throw new Error("Mismatched change set lengths");
    if (o.ins == -1 && u.ins == -1) {
      let d = Math.min(o.len, u.len);
      Me(s, d, -1), o.forward(d), u.forward(d);
    } else if (u.ins >= 0 && (o.ins < 0 || h == o.i || o.off == 0 && (u.len < o.len || u.len == o.len && !e))) {
      let d = u.len;
      for (Me(s, u.ins, -1); d; ) {
        let p = Math.min(o.len, d);
        o.ins >= 0 && h < o.i && o.len <= p && (Me(s, 0, o.ins), a && ll(a, s, o.text), h = o.i), o.forward(p), d -= p;
      }
      u.next();
    } else if (o.ins >= 0) {
      let d = 0, p = o.len;
      for (; p; )
        if (u.ins == -1) {
          let g = Math.min(p, u.len);
          d += g, p -= g, u.forward(g);
        } else if (u.ins == 0 && u.len < p)
          p -= u.len, u.next();
        else
          break;
      Me(s, d, h < o.i ? o.ins : 0), a && h < o.i && ll(a, s, o.text), h = o.i, o.forward(o.len - p);
    } else {
      if (o.done && u.done)
        return a ? Oe.createSet(s, a) : Hi.create(s);
      throw new Error("Mismatched change set lengths");
    }
  }
}
function Ov(n, t, e = !1) {
  let i = [], s = e ? [] : null, a = new Aa(n), o = new Aa(t);
  for (let u = !1; ; ) {
    if (a.done && o.done)
      return s ? Oe.createSet(i, s) : Hi.create(i);
    if (a.ins == 0)
      Me(i, a.len, 0, u), a.next();
    else if (o.len == 0 && !o.done)
      Me(i, 0, o.ins, u), s && ll(s, i, o.text), o.next();
    else {
      if (a.done || o.done)
        throw new Error("Mismatched change set lengths");
      {
        let h = Math.min(a.len2, o.len), d = i.length;
        if (a.ins == -1) {
          let p = o.ins == -1 ? -1 : o.off ? 0 : o.ins;
          Me(i, h, p, u), s && p && ll(s, i, o.text);
        } else o.ins == -1 ? (Me(i, a.off ? 0 : a.len, h, u), s && ll(s, i, a.textBit(h))) : (Me(i, a.off ? 0 : a.len, o.off ? 0 : o.ins, u), s && !o.off && ll(s, i, o.text));
        u = (a.ins > h || o.ins >= 0 && o.len > h) && (u || i.length > d), a.forward2(h), o.forward(h);
      }
    }
  }
}
class Aa {
  constructor(t) {
    this.set = t, this.i = 0, this.next();
  }
  next() {
    let { sections: t } = this.set;
    this.i < t.length ? (this.len = t[this.i++], this.ins = t[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: t } = this.set, e = this.i - 2 >> 1;
    return e >= t.length ? Rt.empty : t[e];
  }
  textBit(t) {
    let { inserted: e } = this.set, i = this.i - 2 >> 1;
    return i >= e.length && !t ? Rt.empty : e[i].slice(this.off, t == null ? void 0 : this.off + t);
  }
  forward(t) {
    t == this.len ? this.next() : (this.len -= t, this.off += t);
  }
  forward2(t) {
    this.ins == -1 ? this.forward(t) : t == this.ins ? this.next() : (this.ins -= t, this.off += t);
  }
}
class Vl {
  constructor(t, e, i) {
    this.from = t, this.to = e, this.flags = i;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let t = this.flags & 7;
    return t == 7 ? null : t;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let t = this.flags >> 6;
    return t == 16777215 ? void 0 : t;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(t, e = -1) {
    let i, s;
    return this.empty ? i = s = t.mapPos(this.from, e) : (i = t.mapPos(this.from, 1), s = t.mapPos(this.to, -1)), i == this.from && s == this.to ? this : new Vl(i, s, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(t, e = t) {
    if (t <= this.anchor && e >= this.anchor)
      return j.range(t, e);
    let i = Math.abs(t - this.anchor) > Math.abs(e - this.anchor) ? t : e;
    return j.range(this.anchor, i);
  }
  /**
  Compare this range to another range.
  */
  eq(t, e = !1) {
    return this.anchor == t.anchor && this.head == t.head && (!e || !this.empty || this.assoc == t.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(t) {
    if (!t || typeof t.anchor != "number" || typeof t.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return j.range(t.anchor, t.head);
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new Vl(t, e, i);
  }
}
class j {
  constructor(t, e) {
    this.ranges = t, this.mainIndex = e;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(t, e = -1) {
    return t.empty ? this : j.create(this.ranges.map((i) => i.map(t, e)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(t, e = !1) {
    if (this.ranges.length != t.ranges.length || this.mainIndex != t.mainIndex)
      return !1;
    for (let i = 0; i < this.ranges.length; i++)
      if (!this.ranges[i].eq(t.ranges[i], e))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new j([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(t, e = !0) {
    return j.create([t].concat(this.ranges), e ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(t, e = this.mainIndex) {
    let i = this.ranges.slice();
    return i[e] = t, j.create(i, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((t) => t.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(t) {
    if (!t || !Array.isArray(t.ranges) || typeof t.main != "number" || t.main >= t.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new j(t.ranges.map((e) => Vl.fromJSON(e)), t.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(t, e = t) {
    return new j([j.range(t, e)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(t, e = 0) {
    if (t.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let i = 0, s = 0; s < t.length; s++) {
      let a = t[s];
      if (a.empty ? a.from <= i : a.from < i)
        return j.normalized(t.slice(), e);
      i = a.to;
    }
    return new j(t, e);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(t, e = 0, i, s) {
    return Vl.create(t, t, (e == 0 ? 0 : e < 0 ? 8 : 16) | (i == null ? 7 : Math.min(6, i)) | (s ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(t, e, i, s) {
    let a = (i ?? 16777215) << 6 | (s == null ? 7 : Math.min(6, s));
    return e < t ? Vl.create(e, t, 48 | a) : Vl.create(t, e, (e > t ? 8 : 0) | a);
  }
  /**
  @internal
  */
  static normalized(t, e = 0) {
    let i = t[e];
    t.sort((s, a) => s.from - a.from), e = t.indexOf(i);
    for (let s = 1; s < t.length; s++) {
      let a = t[s], o = t[s - 1];
      if (a.empty ? a.from <= o.to : a.from < o.to) {
        let u = o.from, h = Math.max(a.to, o.to);
        s <= e && e--, t.splice(--s, 2, a.anchor > a.head ? j.range(h, u) : j.range(u, h));
      }
    }
    return new j(t, e);
  }
}
function dv(n, t) {
  for (let e of n.ranges)
    if (e.to > t)
      throw new RangeError("Selection points outside of document");
}
let dp = 0;
class lt {
  constructor(t, e, i, s, a) {
    this.combine = t, this.compareInput = e, this.compare = i, this.isStatic = s, this.id = dp++, this.default = t([]), this.extensions = typeof a == "function" ? a(this) : a;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(t = {}) {
    return new lt(t.combine || ((e) => e), t.compareInput || ((e, i) => e === i), t.compare || (t.combine ? (e, i) => e === i : pp), !!t.static, t.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(t) {
    return new Hc([], this, 0, t);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(t, e) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Hc(t, this, 1, e);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(t, e) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Hc(t, this, 2, e);
  }
  from(t, e) {
    return e || (e = (i) => i), this.compute([t], (i) => e(i.field(t)));
  }
}
function pp(n, t) {
  return n == t || n.length == t.length && n.every((e, i) => e === t[i]);
}
class Hc {
  constructor(t, e, i, s) {
    this.dependencies = t, this.facet = e, this.type = i, this.value = s, this.id = dp++;
  }
  dynamicSlot(t) {
    var e;
    let i = this.value, s = this.facet.compareInput, a = this.id, o = t[a] >> 1, u = this.type == 2, h = !1, d = !1, p = [];
    for (let g of this.dependencies)
      g == "doc" ? h = !0 : g == "selection" ? d = !0 : (((e = t[g.id]) !== null && e !== void 0 ? e : 1) & 1) == 0 && p.push(t[g.id]);
    return {
      create(g) {
        return g.values[o] = i(g), 1;
      },
      update(g, y) {
        if (h && y.docChanged || d && (y.docChanged || y.selection) || Od(g, p)) {
          let Q = i(g);
          if (u ? !gS(Q, g.values[o], s) : !s(Q, g.values[o]))
            return g.values[o] = Q, 1;
        }
        return 0;
      },
      reconfigure: (g, y) => {
        let Q, b = y.config.address[a];
        if (b != null) {
          let x = Ou(y, b);
          if (this.dependencies.every((P) => P instanceof lt ? y.facet(P) === g.facet(P) : P instanceof Se ? y.field(P, !1) == g.field(P, !1) : !0) || (u ? gS(Q = i(g), x, s) : s(Q = i(g), x)))
            return g.values[o] = x, 0;
        } else
          Q = i(g);
        return g.values[o] = Q, 1;
      }
    };
  }
}
function gS(n, t, e) {
  if (n.length != t.length)
    return !1;
  for (let i = 0; i < n.length; i++)
    if (!e(n[i], t[i]))
      return !1;
  return !0;
}
function Od(n, t) {
  let e = !1;
  for (let i of t)
    wa(n, i) & 1 && (e = !0);
  return e;
}
function L$(n, t, e) {
  let i = e.map((h) => n[h.id]), s = e.map((h) => h.type), a = i.filter((h) => !(h & 1)), o = n[t.id] >> 1;
  function u(h) {
    let d = [];
    for (let p = 0; p < i.length; p++) {
      let g = Ou(h, i[p]);
      if (s[p] == 2)
        for (let y of g)
          d.push(y);
      else
        d.push(g);
    }
    return t.combine(d);
  }
  return {
    create(h) {
      for (let d of i)
        wa(h, d);
      return h.values[o] = u(h), 1;
    },
    update(h, d) {
      if (!Od(h, a))
        return 0;
      let p = u(h);
      return t.compare(p, h.values[o]) ? 0 : (h.values[o] = p, 1);
    },
    reconfigure(h, d) {
      let p = Od(h, i), g = d.config.facets[t.id], y = d.facet(t);
      if (g && !p && pp(e, g))
        return h.values[o] = y, 0;
      let Q = u(h);
      return t.compare(Q, y) ? (h.values[o] = y, 0) : (h.values[o] = Q, 1);
    }
  };
}
const xc = /* @__PURE__ */ lt.define({ static: !0 });
class Se {
  constructor(t, e, i, s, a) {
    this.id = t, this.createF = e, this.updateF = i, this.compareF = s, this.spec = a, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(t) {
    let e = new Se(dp++, t.create, t.update, t.compare || ((i, s) => i === s), t);
    return t.provide && (e.provides = t.provide(e)), e;
  }
  create(t) {
    let e = t.facet(xc).find((i) => i.field == this);
    return ((e == null ? void 0 : e.create) || this.createF)(t);
  }
  /**
  @internal
  */
  slot(t) {
    let e = t[this.id] >> 1;
    return {
      create: (i) => (i.values[e] = this.create(i), 1),
      update: (i, s) => {
        let a = i.values[e], o = this.updateF(a, s);
        return this.compareF(a, o) ? 0 : (i.values[e] = o, 1);
      },
      reconfigure: (i, s) => {
        let a = i.facet(xc), o = s.facet(xc), u;
        return (u = a.find((h) => h.field == this)) && u != o.find((h) => h.field == this) ? (i.values[e] = u.create(i), 1) : s.config.address[this.id] != null ? (i.values[e] = s.field(this), 0) : (i.values[e] = this.create(i), 1);
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(t) {
    return [this, xc.of({ field: this, create: t })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const zl = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function ca(n) {
  return (t) => new pv(t, n);
}
const dl = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ ca(zl.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ ca(zl.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ ca(zl.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ ca(zl.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ ca(zl.lowest)
};
class pv {
  constructor(t, e) {
    this.inner = t, this.prec = e;
  }
}
class zu {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(t) {
    return new dd(this, t);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(t) {
    return zu.reconfigure.of({ compartment: this, extension: t });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(t) {
    return t.config.compartments.get(this);
  }
}
class dd {
  constructor(t, e) {
    this.compartment = t, this.inner = e;
  }
}
class hu {
  constructor(t, e, i, s, a, o) {
    for (this.base = t, this.compartments = e, this.dynamicSlots = i, this.address = s, this.staticValues = a, this.facets = o, this.statusTemplate = []; this.statusTemplate.length < i.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(t) {
    let e = this.address[t.id];
    return e == null ? t.default : this.staticValues[e >> 1];
  }
  static resolve(t, e, i) {
    let s = [], a = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Map();
    for (let y of B$(t, e, o))
      y instanceof Se ? s.push(y) : (a[y.facet.id] || (a[y.facet.id] = [])).push(y);
    let u = /* @__PURE__ */ Object.create(null), h = [], d = [];
    for (let y of s)
      u[y.id] = d.length << 1, d.push((Q) => y.slot(Q));
    let p = i == null ? void 0 : i.config.facets;
    for (let y in a) {
      let Q = a[y], b = Q[0].facet, x = p && p[y] || [];
      if (Q.every(
        (P) => P.type == 0
        /* Provider.Static */
      ))
        if (u[b.id] = h.length << 1 | 1, pp(x, Q))
          h.push(i.facet(b));
        else {
          let P = b.combine(Q.map((A) => A.value));
          h.push(i && b.compare(P, i.facet(b)) ? i.facet(b) : P);
        }
      else {
        for (let P of Q)
          P.type == 0 ? (u[P.id] = h.length << 1 | 1, h.push(P.value)) : (u[P.id] = d.length << 1, d.push((A) => P.dynamicSlot(A)));
        u[b.id] = d.length << 1, d.push((P) => L$(P, b, Q));
      }
    }
    let g = d.map((y) => y(u));
    return new hu(t, o, g, u, h, a);
  }
}
function B$(n, t, e) {
  let i = [[], [], [], [], []], s = /* @__PURE__ */ new Map();
  function a(o, u) {
    let h = s.get(o);
    if (h != null) {
      if (h <= u)
        return;
      let d = i[h].indexOf(o);
      d > -1 && i[h].splice(d, 1), o instanceof dd && e.delete(o.compartment);
    }
    if (s.set(o, u), Array.isArray(o))
      for (let d of o)
        a(d, u);
    else if (o instanceof dd) {
      if (e.has(o.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let d = t.get(o.compartment) || o.inner;
      e.set(o.compartment, d), a(d, u);
    } else if (o instanceof pv)
      a(o.inner, o.prec);
    else if (o instanceof Se)
      i[u].push(o), o.provides && a(o.provides, u);
    else if (o instanceof Hc)
      i[u].push(o), o.facet.extensions && a(o.facet.extensions, zl.default);
    else {
      let d = o.extension;
      if (!d)
        throw new Error(`Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      a(d, u);
    }
  }
  return a(n, zl.default), i.reduce((o, u) => o.concat(u));
}
function wa(n, t) {
  if (t & 1)
    return 2;
  let e = t >> 1, i = n.status[e];
  if (i == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (i & 2)
    return i;
  n.status[e] = 4;
  let s = n.computeSlot(n, n.config.dynamicSlots[e]);
  return n.status[e] = 2 | s;
}
function Ou(n, t) {
  return t & 1 ? n.config.staticValues[t >> 1] : n.values[t >> 1];
}
const mv = /* @__PURE__ */ lt.define(), pd = /* @__PURE__ */ lt.define({
  combine: (n) => n.some((t) => t),
  static: !0
}), gv = /* @__PURE__ */ lt.define({
  combine: (n) => n.length ? n[0] : void 0,
  static: !0
}), yv = /* @__PURE__ */ lt.define(), Sv = /* @__PURE__ */ lt.define(), Qv = /* @__PURE__ */ lt.define(), vv = /* @__PURE__ */ lt.define({
  combine: (n) => n.length ? n[0] : !1
});
class Ii {
  /**
  @internal
  */
  constructor(t, e) {
    this.type = t, this.value = e;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new G$();
  }
}
class G$ {
  /**
  Create an instance of this annotation.
  */
  of(t) {
    return new Ii(this, t);
  }
}
class N$ {
  /**
  @internal
  */
  constructor(t) {
    this.map = t;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(t) {
    return new yt(this, t);
  }
}
class yt {
  /**
  @internal
  */
  constructor(t, e) {
    this.type = t, this.value = e;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(t) {
    let e = this.type.map(this.value, t);
    return e === void 0 ? void 0 : e == this.value ? this : new yt(this.type, e);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(t) {
    return this.type == t;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(t = {}) {
    return new N$(t.map || ((e) => e));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(t, e) {
    if (!t.length)
      return t;
    let i = [];
    for (let s of t) {
      let a = s.map(e);
      a && i.push(a);
    }
    return i;
  }
}
yt.reconfigure = /* @__PURE__ */ yt.define();
yt.appendConfig = /* @__PURE__ */ yt.define();
class oe {
  constructor(t, e, i, s, a, o) {
    this.startState = t, this.changes = e, this.selection = i, this.effects = s, this.annotations = a, this.scrollIntoView = o, this._doc = null, this._state = null, i && dv(i, e.newLength), a.some((u) => u.type == oe.time) || (this.annotations = a.concat(oe.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(t, e, i, s, a, o) {
    return new oe(t, e, i, s, a, o);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(t) {
    for (let e of this.annotations)
      if (e.type == t)
        return e.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(t) {
    let e = this.annotation(oe.userEvent);
    return !!(e && (e == t || e.length > t.length && e.slice(0, t.length) == t && e[t.length] == "."));
  }
}
oe.time = /* @__PURE__ */ Ii.define();
oe.userEvent = /* @__PURE__ */ Ii.define();
oe.addToHistory = /* @__PURE__ */ Ii.define();
oe.remote = /* @__PURE__ */ Ii.define();
function W$(n, t) {
  let e = [];
  for (let i = 0, s = 0; ; ) {
    let a, o;
    if (i < n.length && (s == t.length || t[s] >= n[i]))
      a = n[i++], o = n[i++];
    else if (s < t.length)
      a = t[s++], o = t[s++];
    else
      return e;
    !e.length || e[e.length - 1] < a ? e.push(a, o) : e[e.length - 1] < o && (e[e.length - 1] = o);
  }
}
function bv(n, t, e) {
  var i;
  let s, a, o;
  return e ? (s = t.changes, a = Oe.empty(t.changes.length), o = n.changes.compose(t.changes)) : (s = t.changes.map(n.changes), a = n.changes.mapDesc(t.changes, !0), o = n.changes.compose(s)), {
    changes: o,
    selection: t.selection ? t.selection.map(a) : (i = n.selection) === null || i === void 0 ? void 0 : i.map(s),
    effects: yt.mapEffects(n.effects, s).concat(yt.mapEffects(t.effects, a)),
    annotations: n.annotations.length ? n.annotations.concat(t.annotations) : t.annotations,
    scrollIntoView: n.scrollIntoView || t.scrollIntoView
  };
}
function md(n, t, e) {
  let i = t.selection, s = Gs(t.annotations);
  return t.userEvent && (s = s.concat(oe.userEvent.of(t.userEvent))), {
    changes: t.changes instanceof Oe ? t.changes : Oe.of(t.changes || [], e, n.facet(gv)),
    selection: i && (i instanceof j ? i : j.single(i.anchor, i.head)),
    effects: Gs(t.effects),
    annotations: s,
    scrollIntoView: !!t.scrollIntoView
  };
}
function xv(n, t, e) {
  let i = md(n, t.length ? t[0] : {}, n.doc.length);
  t.length && t[0].filter === !1 && (e = !1);
  for (let a = 1; a < t.length; a++) {
    t[a].filter === !1 && (e = !1);
    let o = !!t[a].sequential;
    i = bv(i, md(n, t[a], o ? i.changes.newLength : n.doc.length), o);
  }
  let s = oe.create(n, i.changes, i.selection, i.effects, i.annotations, i.scrollIntoView);
  return K$(e ? H$(s) : s);
}
function H$(n) {
  let t = n.startState, e = !0;
  for (let s of t.facet(yv)) {
    let a = s(n);
    if (a === !1) {
      e = !1;
      break;
    }
    Array.isArray(a) && (e = e === !0 ? a : W$(e, a));
  }
  if (e !== !0) {
    let s, a;
    if (e === !1)
      a = n.changes.invertedDesc, s = Oe.empty(t.doc.length);
    else {
      let o = n.changes.filter(e);
      s = o.changes, a = o.filtered.mapDesc(o.changes).invertedDesc;
    }
    n = oe.create(t, s, n.selection && n.selection.map(a), yt.mapEffects(n.effects, a), n.annotations, n.scrollIntoView);
  }
  let i = t.facet(Sv);
  for (let s = i.length - 1; s >= 0; s--) {
    let a = i[s](n);
    a instanceof oe ? n = a : Array.isArray(a) && a.length == 1 && a[0] instanceof oe ? n = a[0] : n = xv(t, Gs(a), !1);
  }
  return n;
}
function K$(n) {
  let t = n.startState, e = t.facet(Qv), i = n;
  for (let s = e.length - 1; s >= 0; s--) {
    let a = e[s](n);
    a && Object.keys(a).length && (i = bv(i, md(t, a, n.changes.newLength), !0));
  }
  return i == n ? n : oe.create(t, n.changes, n.selection, i.effects, i.annotations, i.scrollIntoView);
}
const J$ = [];
function Gs(n) {
  return n == null ? J$ : Array.isArray(n) ? n : [n];
}
var Wt = /* @__PURE__ */ function(n) {
  return n[n.Word = 0] = "Word", n[n.Space = 1] = "Space", n[n.Other = 2] = "Other", n;
}(Wt || (Wt = {}));
const I$ = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let gd;
try {
  gd = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function F$(n) {
  if (gd)
    return gd.test(n);
  for (let t = 0; t < n.length; t++) {
    let e = n[t];
    if (/\w/.test(e) || e > "" && (e.toUpperCase() != e.toLowerCase() || I$.test(e)))
      return !0;
  }
  return !1;
}
function t2(n) {
  return (t) => {
    if (!/\S/.test(t))
      return Wt.Space;
    if (F$(t))
      return Wt.Word;
    for (let e = 0; e < n.length; e++)
      if (t.indexOf(n[e]) > -1)
        return Wt.Word;
    return Wt.Other;
  };
}
class $t {
  constructor(t, e, i, s, a, o) {
    this.config = t, this.doc = e, this.selection = i, this.values = s, this.status = t.statusTemplate.slice(), this.computeSlot = a, o && (o._state = this);
    for (let u = 0; u < this.config.dynamicSlots.length; u++)
      wa(this, u << 1);
    this.computeSlot = null;
  }
  field(t, e = !0) {
    let i = this.config.address[t.id];
    if (i == null) {
      if (e)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return wa(this, i), Ou(this, i);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...t) {
    return xv(this, t, !0);
  }
  /**
  @internal
  */
  applyTransaction(t) {
    let e = this.config, { base: i, compartments: s } = e;
    for (let u of t.effects)
      u.is(zu.reconfigure) ? (e && (s = /* @__PURE__ */ new Map(), e.compartments.forEach((h, d) => s.set(d, h)), e = null), s.set(u.value.compartment, u.value.extension)) : u.is(yt.reconfigure) ? (e = null, i = u.value) : u.is(yt.appendConfig) && (e = null, i = Gs(i).concat(u.value));
    let a;
    e ? a = t.startState.values.slice() : (e = hu.resolve(i, s, this), a = new $t(e, this.doc, this.selection, e.dynamicSlots.map(() => null), (h, d) => d.reconfigure(h, this), null).values);
    let o = t.startState.facet(pd) ? t.newSelection : t.newSelection.asSingle();
    new $t(e, t.newDoc, o, a, (u, h) => h.update(u, t), t);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(t) {
    return typeof t == "string" && (t = this.toText(t)), this.changeByRange((e) => ({
      changes: { from: e.from, to: e.to, insert: t },
      range: j.cursor(e.from + t.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(t) {
    let e = this.selection, i = t(e.ranges[0]), s = this.changes(i.changes), a = [i.range], o = Gs(i.effects);
    for (let u = 1; u < e.ranges.length; u++) {
      let h = t(e.ranges[u]), d = this.changes(h.changes), p = d.map(s);
      for (let y = 0; y < u; y++)
        a[y] = a[y].map(p);
      let g = s.mapDesc(d, !0);
      a.push(h.range.map(g)), s = s.compose(p), o = yt.mapEffects(o, p).concat(yt.mapEffects(Gs(h.effects), g));
    }
    return {
      changes: s,
      selection: j.create(a, e.mainIndex),
      effects: o
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(t = []) {
    return t instanceof Oe ? t : Oe.of(t, this.doc.length, this.facet($t.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(t) {
    return Rt.of(t.split(this.facet($t.lineSeparator) || ud));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(t = 0, e = this.doc.length) {
    return this.doc.sliceString(t, e, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(t) {
    let e = this.config.address[t.id];
    return e == null ? t.default : (wa(this, e), Ou(this, e));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(t) {
    let e = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (t)
      for (let i in t) {
        let s = t[i];
        s instanceof Se && this.config.address[s.id] != null && (e[i] = s.spec.toJSON(this.field(t[i]), this));
      }
    return e;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(t, e = {}, i) {
    if (!t || typeof t.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let s = [];
    if (i) {
      for (let a in i)
        if (Object.prototype.hasOwnProperty.call(t, a)) {
          let o = i[a], u = t[a];
          s.push(o.init((h) => o.spec.fromJSON(u, h)));
        }
    }
    return $t.create({
      doc: t.doc,
      selection: j.fromJSON(t.selection),
      extensions: e.extensions ? s.concat([e.extensions]) : s
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(t = {}) {
    let e = hu.resolve(t.extensions || [], /* @__PURE__ */ new Map()), i = t.doc instanceof Rt ? t.doc : Rt.of((t.doc || "").split(e.staticFacet($t.lineSeparator) || ud)), s = t.selection ? t.selection instanceof j ? t.selection : j.single(t.selection.anchor, t.selection.head) : j.single(0);
    return dv(s, i.length), e.staticFacet(pd) || (s = s.asSingle()), new $t(e, i, s, e.dynamicSlots.map(() => null), (a, o) => o.create(a), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet($t.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet($t.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(vv);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(t, ...e) {
    for (let i of this.facet($t.phrases))
      if (Object.prototype.hasOwnProperty.call(i, t)) {
        t = i[t];
        break;
      }
    return e.length && (t = t.replace(/\$(\$|\d*)/g, (i, s) => {
      if (s == "$")
        return "$";
      let a = +(s || 1);
      return !a || a > e.length ? i : e[a - 1];
    })), t;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(t, e, i = -1) {
    let s = [];
    for (let a of this.facet(mv))
      for (let o of a(this, e, i))
        Object.prototype.hasOwnProperty.call(o, t) && s.push(o[t]);
    return s;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(t) {
    return t2(this.languageDataAt("wordChars", t).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(t) {
    let { text: e, from: i, length: s } = this.doc.lineAt(t), a = this.charCategorizer(t), o = t - i, u = t - i;
    for (; o > 0; ) {
      let h = Te(e, o, !1);
      if (a(e.slice(h, o)) != Wt.Word)
        break;
      o = h;
    }
    for (; u < s; ) {
      let h = Te(e, u);
      if (a(e.slice(u, h)) != Wt.Word)
        break;
      u = h;
    }
    return o == u ? null : j.range(o + i, u + i);
  }
}
$t.allowMultipleSelections = pd;
$t.tabSize = /* @__PURE__ */ lt.define({
  combine: (n) => n.length ? n[0] : 4
});
$t.lineSeparator = gv;
$t.readOnly = vv;
$t.phrases = /* @__PURE__ */ lt.define({
  compare(n, t) {
    let e = Object.keys(n), i = Object.keys(t);
    return e.length == i.length && e.every((s) => n[s] == t[s]);
  }
});
$t.languageData = mv;
$t.changeFilter = yv;
$t.transactionFilter = Sv;
$t.transactionExtender = Qv;
zu.reconfigure = /* @__PURE__ */ yt.define();
function Fi(n, t, e = {}) {
  let i = {};
  for (let s of n)
    for (let a of Object.keys(s)) {
      let o = s[a], u = i[a];
      if (u === void 0)
        i[a] = o;
      else if (!(u === o || o === void 0)) if (Object.hasOwnProperty.call(e, a))
        i[a] = e[a](u, o);
      else
        throw new Error("Config merge conflict for field " + a);
    }
  for (let s in t)
    i[s] === void 0 && (i[s] = t[s]);
  return i;
}
class Bl {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(t) {
    return this == t;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(t, e = t) {
    return yd.create(t, e, this);
  }
}
Bl.prototype.startSide = Bl.prototype.endSide = 0;
Bl.prototype.point = !1;
Bl.prototype.mapMode = we.TrackDel;
let yd = class kv {
  constructor(t, e, i) {
    this.from = t, this.to = e, this.value = i;
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new kv(t, e, i);
  }
};
function Sd(n, t) {
  return n.from - t.from || n.value.startSide - t.value.startSide;
}
class mp {
  constructor(t, e, i, s) {
    this.from = t, this.to = e, this.value = i, this.maxPoint = s;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(t, e, i, s = 0) {
    let a = i ? this.to : this.from;
    for (let o = s, u = a.length; ; ) {
      if (o == u)
        return o;
      let h = o + u >> 1, d = a[h] - t || (i ? this.value[h].endSide : this.value[h].startSide) - e;
      if (h == o)
        return d >= 0 ? o : u;
      d >= 0 ? u = h : o = h + 1;
    }
  }
  between(t, e, i, s) {
    for (let a = this.findIndex(e, -1e9, !0), o = this.findIndex(i, 1e9, !1, a); a < o; a++)
      if (s(this.from[a] + t, this.to[a] + t, this.value[a]) === !1)
        return !1;
  }
  map(t, e) {
    let i = [], s = [], a = [], o = -1, u = -1;
    for (let h = 0; h < this.value.length; h++) {
      let d = this.value[h], p = this.from[h] + t, g = this.to[h] + t, y, Q;
      if (p == g) {
        let b = e.mapPos(p, d.startSide, d.mapMode);
        if (b == null || (y = Q = b, d.startSide != d.endSide && (Q = e.mapPos(p, d.endSide), Q < y)))
          continue;
      } else if (y = e.mapPos(p, d.startSide), Q = e.mapPos(g, d.endSide), y > Q || y == Q && d.startSide > 0 && d.endSide <= 0)
        continue;
      (Q - y || d.endSide - d.startSide) < 0 || (o < 0 && (o = y), d.point && (u = Math.max(u, Q - y)), i.push(d), s.push(y - o), a.push(Q - o));
    }
    return { mapped: i.length ? new mp(s, a, i, u) : null, pos: o };
  }
}
class Mt {
  constructor(t, e, i, s) {
    this.chunkPos = t, this.chunk = e, this.nextLayer = i, this.maxPoint = s;
  }
  /**
  @internal
  */
  static create(t, e, i, s) {
    return new Mt(t, e, i, s);
  }
  /**
  @internal
  */
  get length() {
    let t = this.chunk.length - 1;
    return t < 0 ? 0 : Math.max(this.chunkEnd(t), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let t = this.nextLayer.size;
    for (let e of this.chunk)
      t += e.value.length;
    return t;
  }
  /**
  @internal
  */
  chunkEnd(t) {
    return this.chunkPos[t] + this.chunk[t].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(t) {
    let { add: e = [], sort: i = !1, filterFrom: s = 0, filterTo: a = this.length } = t, o = t.filter;
    if (e.length == 0 && !o)
      return this;
    if (i && (e = e.slice().sort(Sd)), this.isEmpty)
      return e.length ? Mt.of(e) : this;
    let u = new wv(this, null, -1).goto(0), h = 0, d = [], p = new Tn();
    for (; u.value || h < e.length; )
      if (h < e.length && (u.from - e[h].from || u.startSide - e[h].value.startSide) >= 0) {
        let g = e[h++];
        p.addInner(g.from, g.to, g.value) || d.push(g);
      } else u.rangeIndex == 1 && u.chunkIndex < this.chunk.length && (h == e.length || this.chunkEnd(u.chunkIndex) < e[h].from) && (!o || s > this.chunkEnd(u.chunkIndex) || a < this.chunkPos[u.chunkIndex]) && p.addChunk(this.chunkPos[u.chunkIndex], this.chunk[u.chunkIndex]) ? u.nextChunk() : ((!o || s > u.to || a < u.from || o(u.from, u.to, u.value)) && (p.addInner(u.from, u.to, u.value) || d.push(yd.create(u.from, u.to, u.value))), u.next());
    return p.finishInner(this.nextLayer.isEmpty && !d.length ? Mt.empty : this.nextLayer.update({ add: d, filter: o, filterFrom: s, filterTo: a }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(t) {
    if (t.empty || this.isEmpty)
      return this;
    let e = [], i = [], s = -1;
    for (let o = 0; o < this.chunk.length; o++) {
      let u = this.chunkPos[o], h = this.chunk[o], d = t.touchesRange(u, u + h.length);
      if (d === !1)
        s = Math.max(s, h.maxPoint), e.push(h), i.push(t.mapPos(u));
      else if (d === !0) {
        let { mapped: p, pos: g } = h.map(u, t);
        p && (s = Math.max(s, p.maxPoint), e.push(p), i.push(g));
      }
    }
    let a = this.nextLayer.map(t);
    return e.length == 0 ? a : new Mt(i, e, a || Mt.empty, s);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(t, e, i) {
    if (!this.isEmpty) {
      for (let s = 0; s < this.chunk.length; s++) {
        let a = this.chunkPos[s], o = this.chunk[s];
        if (e >= a && t <= a + o.length && o.between(a, t - a, e - a, i) === !1)
          return;
      }
      this.nextLayer.between(t, e, i);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(t = 0) {
    return Ma.from([this]).goto(t);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(t, e = 0) {
    return Ma.from(t).goto(e);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(t, e, i, s, a = -1) {
    let o = t.filter((g) => g.maxPoint > 0 || !g.isEmpty && g.maxPoint >= a), u = e.filter((g) => g.maxPoint > 0 || !g.isEmpty && g.maxPoint >= a), h = yS(o, u, i), d = new ua(o, h, a), p = new ua(u, h, a);
    i.iterGaps((g, y, Q) => SS(d, g, p, y, Q, s)), i.empty && i.length == 0 && SS(d, 0, p, 0, 0, s);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(t, e, i = 0, s) {
    s == null && (s = 999999999);
    let a = t.filter((p) => !p.isEmpty && e.indexOf(p) < 0), o = e.filter((p) => !p.isEmpty && t.indexOf(p) < 0);
    if (a.length != o.length)
      return !1;
    if (!a.length)
      return !0;
    let u = yS(a, o), h = new ua(a, u, 0).goto(i), d = new ua(o, u, 0).goto(i);
    for (; ; ) {
      if (h.to != d.to || !Qd(h.active, d.active) || h.point && (!d.point || !h.point.eq(d.point)))
        return !1;
      if (h.to > s)
        return !0;
      h.next(), d.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(t, e, i, s, a = -1) {
    let o = new ua(t, null, a).goto(e), u = e, h = o.openStart;
    for (; ; ) {
      let d = Math.min(o.to, i);
      if (o.point) {
        let p = o.activeForPoint(o.to), g = o.pointFrom < e ? p.length + 1 : o.point.startSide < 0 ? p.length : Math.min(p.length, h);
        s.point(u, d, o.point, p, g, o.pointRank), h = Math.min(o.openEnd(d), p.length);
      } else d > u && (s.span(u, d, o.active, h), h = o.openEnd(d));
      if (o.to > i)
        return h + (o.point && o.to > i ? 1 : 0);
      u = o.to, o.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(t, e = !1) {
    let i = new Tn();
    for (let s of t instanceof yd ? [t] : e ? e2(t) : t)
      i.add(s.from, s.to, s.value);
    return i.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(t) {
    if (!t.length)
      return Mt.empty;
    let e = t[t.length - 1];
    for (let i = t.length - 2; i >= 0; i--)
      for (let s = t[i]; s != Mt.empty; s = s.nextLayer)
        e = new Mt(s.chunkPos, s.chunk, e, Math.max(s.maxPoint, e.maxPoint));
    return e;
  }
}
Mt.empty = /* @__PURE__ */ new Mt([], [], null, -1);
function e2(n) {
  if (n.length > 1)
    for (let t = n[0], e = 1; e < n.length; e++) {
      let i = n[e];
      if (Sd(t, i) > 0)
        return n.slice().sort(Sd);
      t = i;
    }
  return n;
}
Mt.empty.nextLayer = Mt.empty;
class Tn {
  finishChunk(t) {
    this.chunks.push(new mp(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, t && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(t, e, i) {
    this.addInner(t, e, i) || (this.nextLayer || (this.nextLayer = new Tn())).add(t, e, i);
  }
  /**
  @internal
  */
  addInner(t, e, i) {
    let s = t - this.lastTo || i.startSide - this.last.endSide;
    if (s <= 0 && (t - this.lastFrom || i.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return s < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = t), this.from.push(t - this.chunkStart), this.to.push(e - this.chunkStart), this.last = i, this.lastFrom = t, this.lastTo = e, this.value.push(i), i.point && (this.maxPoint = Math.max(this.maxPoint, e - t)), !0);
  }
  /**
  @internal
  */
  addChunk(t, e) {
    if ((t - this.lastTo || e.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, e.maxPoint), this.chunks.push(e), this.chunkPos.push(t);
    let i = e.value.length - 1;
    return this.last = e.value[i], this.lastFrom = e.from[i] + t, this.lastTo = e.to[i] + t, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(Mt.empty);
  }
  /**
  @internal
  */
  finishInner(t) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return t;
    let e = Mt.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(t) : t, this.setMaxPoint);
    return this.from = null, e;
  }
}
function yS(n, t, e) {
  let i = /* @__PURE__ */ new Map();
  for (let a of n)
    for (let o = 0; o < a.chunk.length; o++)
      a.chunk[o].maxPoint <= 0 && i.set(a.chunk[o], a.chunkPos[o]);
  let s = /* @__PURE__ */ new Set();
  for (let a of t)
    for (let o = 0; o < a.chunk.length; o++) {
      let u = i.get(a.chunk[o]);
      u != null && (e ? e.mapPos(u) : u) == a.chunkPos[o] && !(e != null && e.touchesRange(u, u + a.chunk[o].length)) && s.add(a.chunk[o]);
    }
  return s;
}
class wv {
  constructor(t, e, i, s = 0) {
    this.layer = t, this.skip = e, this.minPoint = i, this.rank = s;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(t, e = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(t, e, !1), this;
  }
  gotoInner(t, e, i) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let s = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(s) || this.layer.chunkEnd(this.chunkIndex) < t || s.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, i = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let s = this.layer.chunk[this.chunkIndex].findIndex(t - this.layer.chunkPos[this.chunkIndex], e, !0);
      (!i || this.rangeIndex < s) && this.setRangeIndex(s);
    }
    this.next();
  }
  forward(t, e) {
    (this.to - t || this.endSide - e) < 0 && this.gotoInner(t, e, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let t = this.layer.chunkPos[this.chunkIndex], e = this.layer.chunk[this.chunkIndex], i = t + e.from[this.rangeIndex];
        if (this.from = i, this.to = t + e.to[this.rangeIndex], this.value = e.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(t) {
    if (t == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = t;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(t) {
    return this.from - t.from || this.startSide - t.startSide || this.rank - t.rank || this.to - t.to || this.endSide - t.endSide;
  }
}
class Ma {
  constructor(t) {
    this.heap = t;
  }
  static from(t, e = null, i = -1) {
    let s = [];
    for (let a = 0; a < t.length; a++)
      for (let o = t[a]; !o.isEmpty; o = o.nextLayer)
        o.maxPoint >= i && s.push(new wv(o, e, i, a));
    return s.length == 1 ? s[0] : new Ma(s);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(t, e = -1e9) {
    for (let i of this.heap)
      i.goto(t, e);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      xO(this.heap, i);
    return this.next(), this;
  }
  forward(t, e) {
    for (let i of this.heap)
      i.forward(t, e);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      xO(this.heap, i);
    (this.to - t || this.value.endSide - e) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let t = this.heap[0];
      this.from = t.from, this.to = t.to, this.value = t.value, this.rank = t.rank, t.value && t.next(), xO(this.heap, 0);
    }
  }
}
function xO(n, t) {
  for (let e = n[t]; ; ) {
    let i = (t << 1) + 1;
    if (i >= n.length)
      break;
    let s = n[i];
    if (i + 1 < n.length && s.compare(n[i + 1]) >= 0 && (s = n[i + 1], i++), e.compare(s) < 0)
      break;
    n[i] = e, n[t] = s, t = i;
  }
}
class ua {
  constructor(t, e, i) {
    this.minPoint = i, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Ma.from(t, e, i);
  }
  goto(t, e = -1e9) {
    return this.cursor.goto(t, e), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = t, this.endSide = e, this.openStart = -1, this.next(), this;
  }
  forward(t, e) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - t || this.active[this.minActive].endSide - e) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(t, e);
  }
  removeActive(t) {
    kc(this.active, t), kc(this.activeTo, t), kc(this.activeRank, t), this.minActive = QS(this.active, this.activeTo);
  }
  addActive(t) {
    let e = 0, { value: i, to: s, rank: a } = this.cursor;
    for (; e < this.activeRank.length && (a - this.activeRank[e] || s - this.activeTo[e]) > 0; )
      e++;
    wc(this.active, e, i), wc(this.activeTo, e, s), wc(this.activeRank, e, a), t && wc(t, e, this.cursor.from), this.minActive = QS(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let t = this.to, e = this.point;
    this.point = null;
    let i = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let s = this.minActive;
      if (s > -1 && (this.activeTo[s] - this.cursor.from || this.active[s].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[s] > t) {
          this.to = this.activeTo[s], this.endSide = this.active[s].endSide;
          break;
        }
        this.removeActive(s), i && kc(i, s);
      } else if (this.cursor.value)
        if (this.cursor.from > t) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let a = this.cursor.value;
          if (!a.point)
            this.addActive(i), this.cursor.next();
          else if (e && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = a, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = a.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (i) {
      this.openStart = 0;
      for (let s = i.length - 1; s >= 0 && i[s] < t; s--)
        this.openStart++;
    }
  }
  activeForPoint(t) {
    if (!this.active.length)
      return this.active;
    let e = [];
    for (let i = this.active.length - 1; i >= 0 && !(this.activeRank[i] < this.pointRank); i--)
      (this.activeTo[i] > t || this.activeTo[i] == t && this.active[i].endSide >= this.point.endSide) && e.push(this.active[i]);
    return e.reverse();
  }
  openEnd(t) {
    let e = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > t; i--)
      e++;
    return e;
  }
}
function SS(n, t, e, i, s, a) {
  n.goto(t), e.goto(i);
  let o = i + s, u = i, h = i - t;
  for (; ; ) {
    let d = n.to + h - e.to, p = d || n.endSide - e.endSide, g = p < 0 ? n.to + h : e.to, y = Math.min(g, o);
    if (n.point || e.point ? n.point && e.point && (n.point == e.point || n.point.eq(e.point)) && Qd(n.activeForPoint(n.to), e.activeForPoint(e.to)) || a.comparePoint(u, y, n.point, e.point) : y > u && !Qd(n.active, e.active) && a.compareRange(u, y, n.active, e.active), g > o)
      break;
    (d || n.openEnd != e.openEnd) && a.boundChange && a.boundChange(g), u = g, p <= 0 && n.next(), p >= 0 && e.next();
  }
}
function Qd(n, t) {
  if (n.length != t.length)
    return !1;
  for (let e = 0; e < n.length; e++)
    if (n[e] != t[e] && !n[e].eq(t[e]))
      return !1;
  return !0;
}
function kc(n, t) {
  for (let e = t, i = n.length - 1; e < i; e++)
    n[e] = n[e + 1];
  n.pop();
}
function wc(n, t, e) {
  for (let i = n.length - 1; i >= t; i--)
    n[i + 1] = n[i];
  n[t] = e;
}
function QS(n, t) {
  let e = -1, i = 1e9;
  for (let s = 0; s < t.length; s++)
    (t[s] - i || n[s].endSide - n[e].endSide) < 0 && (e = s, i = t[s]);
  return e;
}
function rr(n, t, e = n.length) {
  let i = 0;
  for (let s = 0; s < e && s < n.length; )
    n.charCodeAt(s) == 9 ? (i += t - i % t, s++) : (i++, s = Te(n, s));
  return i;
}
function vd(n, t, e, i) {
  for (let s = 0, a = 0; ; ) {
    if (a >= t)
      return s;
    if (s == n.length)
      break;
    a += n.charCodeAt(s) == 9 ? e - a % e : 1, s = Te(n, s);
  }
  return i === !0 ? -1 : n.length;
}
const bd = "ͼ", vS = typeof Symbol > "u" ? "__" + bd : Symbol.for(bd), xd = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), bS = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class cl {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(t, e) {
    this.rules = [];
    let { finish: i } = e || {};
    function s(o) {
      return /^@/.test(o) ? [o] : o.split(/,\s*/);
    }
    function a(o, u, h, d) {
      let p = [], g = /^@(\w+)\b/.exec(o[0]), y = g && g[1] == "keyframes";
      if (g && u == null) return h.push(o[0] + ";");
      for (let Q in u) {
        let b = u[Q];
        if (/&/.test(Q))
          a(
            Q.split(/,\s*/).map((x) => o.map((P) => x.replace(/&/, P))).reduce((x, P) => x.concat(P)),
            b,
            h
          );
        else if (b && typeof b == "object") {
          if (!g) throw new RangeError("The value of a property (" + Q + ") should be a primitive value.");
          a(s(Q), b, p, y);
        } else b != null && p.push(Q.replace(/_.*/, "").replace(/[A-Z]/g, (x) => "-" + x.toLowerCase()) + ": " + b + ";");
      }
      (p.length || y) && h.push((i && !g && !d ? o.map(i) : o).join(", ") + " {" + p.join(" ") + "}");
    }
    for (let o in t) a(s(o), t[o], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let t = bS[vS] || 1;
    return bS[vS] = t + 1, bd + t.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(t, e, i) {
    let s = t[xd], a = i && i.nonce;
    s ? a && s.setNonce(a) : s = new i2(t, a), s.mount(Array.isArray(e) ? e : [e], t);
  }
}
let xS = /* @__PURE__ */ new Map();
class i2 {
  constructor(t, e) {
    let i = t.ownerDocument || t, s = i.defaultView;
    if (!t.head && t.adoptedStyleSheets && s.CSSStyleSheet) {
      let a = xS.get(i);
      if (a) return t[xd] = a;
      this.sheet = new s.CSSStyleSheet(), xS.set(i, this);
    } else
      this.styleTag = i.createElement("style"), e && this.styleTag.setAttribute("nonce", e);
    this.modules = [], t[xd] = this;
  }
  mount(t, e) {
    let i = this.sheet, s = 0, a = 0;
    for (let o = 0; o < t.length; o++) {
      let u = t[o], h = this.modules.indexOf(u);
      if (h < a && h > -1 && (this.modules.splice(h, 1), a--, h = -1), h == -1) {
        if (this.modules.splice(a++, 0, u), i) for (let d = 0; d < u.rules.length; d++)
          i.insertRule(u.rules[d], s++);
      } else {
        for (; a < h; ) s += this.modules[a++].rules.length;
        s += u.rules.length, a++;
      }
    }
    if (i)
      e.adoptedStyleSheets.indexOf(this.sheet) < 0 && (e.adoptedStyleSheets = [this.sheet, ...e.adoptedStyleSheets]);
    else {
      let o = "";
      for (let h = 0; h < this.modules.length; h++)
        o += this.modules[h].getRules() + `
`;
      this.styleTag.textContent = o;
      let u = e.head || e;
      this.styleTag.parentNode != u && u.insertBefore(this.styleTag, u.firstChild);
    }
  }
  setNonce(t) {
    this.styleTag && this.styleTag.getAttribute("nonce") != t && this.styleTag.setAttribute("nonce", t);
  }
}
var ul = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, qa = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, n2 = typeof navigator < "u" && /Mac/.test(navigator.platform), l2 = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var ke = 0; ke < 10; ke++) ul[48 + ke] = ul[96 + ke] = String(ke);
for (var ke = 1; ke <= 24; ke++) ul[ke + 111] = "F" + ke;
for (var ke = 65; ke <= 90; ke++)
  ul[ke] = String.fromCharCode(ke + 32), qa[ke] = String.fromCharCode(ke);
for (var kO in ul) qa.hasOwnProperty(kO) || (qa[kO] = ul[kO]);
function s2(n) {
  var t = n2 && n.metaKey && n.shiftKey && !n.ctrlKey && !n.altKey || l2 && n.shiftKey && n.key && n.key.length == 1 || n.key == "Unidentified", e = !t && n.key || (n.shiftKey ? qa : ul)[n.keyCode] || n.key || "Unidentified";
  return e == "Esc" && (e = "Escape"), e == "Del" && (e = "Delete"), e == "Left" && (e = "ArrowLeft"), e == "Up" && (e = "ArrowUp"), e == "Right" && (e = "ArrowRight"), e == "Down" && (e = "ArrowDown"), e;
}
function Ca(n) {
  let t;
  return n.nodeType == 11 ? t = n.getSelection ? n : n.ownerDocument : t = n, t.getSelection();
}
function kd(n, t) {
  return t ? n == t || n.contains(t.nodeType != 1 ? t.parentNode : t) : !1;
}
function Kc(n, t) {
  if (!t.anchorNode)
    return !1;
  try {
    return kd(n, t.anchorNode);
  } catch {
    return !1;
  }
}
function Fs(n) {
  return n.nodeType == 3 ? Nl(n, 0, n.nodeValue.length).getClientRects() : n.nodeType == 1 ? n.getClientRects() : [];
}
function Ta(n, t, e, i) {
  return e ? kS(n, t, e, i, -1) || kS(n, t, e, i, 1) : !1;
}
function Gl(n) {
  for (var t = 0; ; t++)
    if (n = n.previousSibling, !n)
      return t;
}
function du(n) {
  return n.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(n.nodeName);
}
function kS(n, t, e, i, s) {
  for (; ; ) {
    if (n == e && t == i)
      return !0;
    if (t == (s < 0 ? 0 : Ki(n))) {
      if (n.nodeName == "DIV")
        return !1;
      let a = n.parentNode;
      if (!a || a.nodeType != 1)
        return !1;
      t = Gl(n) + (s < 0 ? 0 : 1), n = a;
    } else if (n.nodeType == 1) {
      if (n = n.childNodes[t + (s < 0 ? -1 : 0)], n.nodeType == 1 && n.contentEditable == "false")
        return !1;
      t = s < 0 ? Ki(n) : 0;
    } else
      return !1;
  }
}
function Ki(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function Ha(n, t) {
  let e = t ? n.left : n.right;
  return { left: e, right: e, top: n.top, bottom: n.bottom };
}
function r2(n) {
  let t = n.visualViewport;
  return t ? {
    left: 0,
    right: t.width,
    top: 0,
    bottom: t.height
  } : {
    left: 0,
    right: n.innerWidth,
    top: 0,
    bottom: n.innerHeight
  };
}
function Tv(n, t) {
  let e = t.width / n.offsetWidth, i = t.height / n.offsetHeight;
  return (e > 0.995 && e < 1.005 || !isFinite(e) || Math.abs(t.width - n.offsetWidth) < 1) && (e = 1), (i > 0.995 && i < 1.005 || !isFinite(i) || Math.abs(t.height - n.offsetHeight) < 1) && (i = 1), { scaleX: e, scaleY: i };
}
function a2(n, t, e, i, s, a, o, u) {
  let h = n.ownerDocument, d = h.defaultView || window;
  for (let p = n, g = !1; p && !g; )
    if (p.nodeType == 1) {
      let y, Q = p == h.body, b = 1, x = 1;
      if (Q)
        y = r2(d);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(p).position) && (g = !0), p.scrollHeight <= p.clientHeight && p.scrollWidth <= p.clientWidth) {
          p = p.assignedSlot || p.parentNode;
          continue;
        }
        let V = p.getBoundingClientRect();
        ({ scaleX: b, scaleY: x } = Tv(p, V)), y = {
          left: V.left,
          right: V.left + p.clientWidth * b,
          top: V.top,
          bottom: V.top + p.clientHeight * x
        };
      }
      let P = 0, A = 0;
      if (s == "nearest")
        t.top < y.top ? (A = t.top - (y.top + o), e > 0 && t.bottom > y.bottom + A && (A = t.bottom - y.bottom + o)) : t.bottom > y.bottom && (A = t.bottom - y.bottom + o, e < 0 && t.top - A < y.top && (A = t.top - (y.top + o)));
      else {
        let V = t.bottom - t.top, G = y.bottom - y.top;
        A = (s == "center" && V <= G ? t.top + V / 2 - G / 2 : s == "start" || s == "center" && e < 0 ? t.top - o : t.bottom - G + o) - y.top;
      }
      if (i == "nearest" ? t.left < y.left ? (P = t.left - (y.left + a), e > 0 && t.right > y.right + P && (P = t.right - y.right + a)) : t.right > y.right && (P = t.right - y.right + a, e < 0 && t.left < y.left + P && (P = t.left - (y.left + a))) : P = (i == "center" ? t.left + (t.right - t.left) / 2 - (y.right - y.left) / 2 : i == "start" == u ? t.left - a : t.right - (y.right - y.left) + a) - y.left, P || A)
        if (Q)
          d.scrollBy(P, A);
        else {
          let V = 0, G = 0;
          if (A) {
            let H = p.scrollTop;
            p.scrollTop += A / x, G = (p.scrollTop - H) * x;
          }
          if (P) {
            let H = p.scrollLeft;
            p.scrollLeft += P / b, V = (p.scrollLeft - H) * b;
          }
          t = {
            left: t.left - V,
            top: t.top - G,
            right: t.right - V,
            bottom: t.bottom - G
          }, V && Math.abs(V - P) < 1 && (i = "nearest"), G && Math.abs(G - A) < 1 && (s = "nearest");
        }
      if (Q)
        break;
      (t.top < y.top || t.bottom > y.bottom || t.left < y.left || t.right > y.right) && (t = {
        left: Math.max(t.left, y.left),
        right: Math.min(t.right, y.right),
        top: Math.max(t.top, y.top),
        bottom: Math.min(t.bottom, y.bottom)
      }), p = p.assignedSlot || p.parentNode;
    } else if (p.nodeType == 11)
      p = p.host;
    else
      break;
}
function o2(n) {
  let t = n.ownerDocument, e, i;
  for (let s = n.parentNode; s && !(s == t.body || e && i); )
    if (s.nodeType == 1)
      !i && s.scrollHeight > s.clientHeight && (i = s), !e && s.scrollWidth > s.clientWidth && (e = s), s = s.assignedSlot || s.parentNode;
    else if (s.nodeType == 11)
      s = s.host;
    else
      break;
  return { x: e, y: i };
}
class c2 {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(t) {
    return this.anchorNode == t.anchorNode && this.anchorOffset == t.anchorOffset && this.focusNode == t.focusNode && this.focusOffset == t.focusOffset;
  }
  setRange(t) {
    let { anchorNode: e, focusNode: i } = t;
    this.set(e, Math.min(t.anchorOffset, e ? Ki(e) : 0), i, Math.min(t.focusOffset, i ? Ki(i) : 0));
  }
  set(t, e, i, s) {
    this.anchorNode = t, this.anchorOffset = e, this.focusNode = i, this.focusOffset = s;
  }
}
let _s = null;
function $v(n) {
  if (n.setActive)
    return n.setActive();
  if (_s)
    return n.focus(_s);
  let t = [];
  for (let e = n; e && (t.push(e, e.scrollTop, e.scrollLeft), e != e.ownerDocument); e = e.parentNode)
    ;
  if (n.focus(_s == null ? {
    get preventScroll() {
      return _s = { preventScroll: !0 }, !0;
    }
  } : void 0), !_s) {
    _s = !1;
    for (let e = 0; e < t.length; ) {
      let i = t[e++], s = t[e++], a = t[e++];
      i.scrollTop != s && (i.scrollTop = s), i.scrollLeft != a && (i.scrollLeft = a);
    }
  }
}
let wS;
function Nl(n, t, e = t) {
  let i = wS || (wS = document.createRange());
  return i.setEnd(n, e), i.setStart(n, t), i;
}
function Ns(n, t, e, i) {
  let s = { key: t, code: t, keyCode: e, which: e, cancelable: !0 };
  i && ({ altKey: s.altKey, ctrlKey: s.ctrlKey, shiftKey: s.shiftKey, metaKey: s.metaKey } = i);
  let a = new KeyboardEvent("keydown", s);
  a.synthetic = !0, n.dispatchEvent(a);
  let o = new KeyboardEvent("keyup", s);
  return o.synthetic = !0, n.dispatchEvent(o), a.defaultPrevented || o.defaultPrevented;
}
function u2(n) {
  for (; n; ) {
    if (n && (n.nodeType == 9 || n.nodeType == 11 && n.host))
      return n;
    n = n.assignedSlot || n.parentNode;
  }
  return null;
}
function Pv(n) {
  for (; n.attributes.length; )
    n.removeAttributeNode(n.attributes[0]);
}
function f2(n, t) {
  let e = t.focusNode, i = t.focusOffset;
  if (!e || t.anchorNode != e || t.anchorOffset != i)
    return !1;
  for (i = Math.min(i, Ki(e)); ; )
    if (i) {
      if (e.nodeType != 1)
        return !1;
      let s = e.childNodes[i - 1];
      s.contentEditable == "false" ? i-- : (e = s, i = Ki(e));
    } else {
      if (e == n)
        return !0;
      i = Gl(e), e = e.parentNode;
    }
}
function Rv(n) {
  return n.scrollTop > Math.max(1, n.scrollHeight - n.clientHeight - 4);
}
function Av(n, t) {
  for (let e = n, i = t; ; ) {
    if (e.nodeType == 3 && i > 0)
      return { node: e, offset: i };
    if (e.nodeType == 1 && i > 0) {
      if (e.contentEditable == "false")
        return null;
      e = e.childNodes[i - 1], i = Ki(e);
    } else if (e.parentNode && !du(e))
      i = Gl(e), e = e.parentNode;
    else
      return null;
  }
}
function Mv(n, t) {
  for (let e = n, i = t; ; ) {
    if (e.nodeType == 3 && i < e.nodeValue.length)
      return { node: e, offset: i };
    if (e.nodeType == 1 && i < e.childNodes.length) {
      if (e.contentEditable == "false")
        return null;
      e = e.childNodes[i], i = 0;
    } else if (e.parentNode && !du(e))
      i = Gl(e) + 1, e = e.parentNode;
    else
      return null;
  }
}
class qe {
  constructor(t, e, i = !0) {
    this.node = t, this.offset = e, this.precise = i;
  }
  static before(t, e) {
    return new qe(t.parentNode, Gl(t), e);
  }
  static after(t, e) {
    return new qe(t.parentNode, Gl(t) + 1, e);
  }
}
const gp = [];
class Ut {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(t) {
    let e = this.posAtStart;
    for (let i of this.children) {
      if (i == t)
        return e;
      e += i.length + i.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(t) {
    return this.posBefore(t) + t.length;
  }
  sync(t, e) {
    if (this.flags & 2) {
      let i = this.dom, s = null, a;
      for (let o of this.children) {
        if (o.flags & 7) {
          if (!o.dom && (a = s ? s.nextSibling : i.firstChild)) {
            let u = Ut.get(a);
            (!u || !u.parent && u.canReuseDOM(o)) && o.reuseDOM(a);
          }
          o.sync(t, e), o.flags &= -8;
        }
        if (a = s ? s.nextSibling : i.firstChild, e && !e.written && e.node == i && a != o.dom && (e.written = !0), o.dom.parentNode == i)
          for (; a && a != o.dom; )
            a = TS(a);
        else
          i.insertBefore(o.dom, a);
        s = o.dom;
      }
      for (a = s ? s.nextSibling : i.firstChild, a && e && e.node == i && (e.written = !0); a; )
        a = TS(a);
    } else if (this.flags & 1)
      for (let i of this.children)
        i.flags & 7 && (i.sync(t, e), i.flags &= -8);
  }
  reuseDOM(t) {
  }
  localPosFromDOM(t, e) {
    let i;
    if (t == this.dom)
      i = this.dom.childNodes[e];
    else {
      let s = Ki(t) == 0 ? 0 : e == 0 ? -1 : 1;
      for (; ; ) {
        let a = t.parentNode;
        if (a == this.dom)
          break;
        s == 0 && a.firstChild != a.lastChild && (t == a.firstChild ? s = -1 : s = 1), t = a;
      }
      s < 0 ? i = t : i = t.nextSibling;
    }
    if (i == this.dom.firstChild)
      return 0;
    for (; i && !Ut.get(i); )
      i = i.nextSibling;
    if (!i)
      return this.length;
    for (let s = 0, a = 0; ; s++) {
      let o = this.children[s];
      if (o.dom == i)
        return a;
      a += o.length + o.breakAfter;
    }
  }
  domBoundsAround(t, e, i = 0) {
    let s = -1, a = -1, o = -1, u = -1;
    for (let h = 0, d = i, p = i; h < this.children.length; h++) {
      let g = this.children[h], y = d + g.length;
      if (d < t && y > e)
        return g.domBoundsAround(t, e, d);
      if (y >= t && s == -1 && (s = h, a = d), d > e && g.dom.parentNode == this.dom) {
        o = h, u = p;
        break;
      }
      p = y, d = y + g.breakAfter;
    }
    return {
      from: a,
      to: u < 0 ? i + this.length : u,
      startDOM: (s ? this.children[s - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null
    };
  }
  markDirty(t = !1) {
    this.flags |= 2, this.markParentsDirty(t);
  }
  markParentsDirty(t) {
    for (let e = this.parent; e; e = e.parent) {
      if (t && (e.flags |= 2), e.flags & 1)
        return;
      e.flags |= 1, t = !1;
    }
  }
  setParent(t) {
    this.parent != t && (this.parent = t, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(t) {
    this.dom != t && (this.dom && (this.dom.cmView = null), this.dom = t, t.cmView = this);
  }
  get rootView() {
    for (let t = this; ; ) {
      let e = t.parent;
      if (!e)
        return t;
      t = e;
    }
  }
  replaceChildren(t, e, i = gp) {
    this.markDirty();
    for (let s = t; s < e; s++) {
      let a = this.children[s];
      a.parent == this && i.indexOf(a) < 0 && a.destroy();
    }
    i.length < 250 ? this.children.splice(t, e - t, ...i) : this.children = [].concat(this.children.slice(0, t), i, this.children.slice(e));
    for (let s = 0; s < i.length; s++)
      i[s].setParent(this);
  }
  ignoreMutation(t) {
    return !1;
  }
  ignoreEvent(t) {
    return !1;
  }
  childCursor(t = this.length) {
    return new qv(this.children, t, this.children.length);
  }
  childPos(t, e = 1) {
    return this.childCursor().findPos(t, e);
  }
  toString() {
    let t = this.constructor.name.replace("View", "");
    return t + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (t == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(t) {
    return t.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(t, e, i, s, a, o) {
    return !1;
  }
  become(t) {
    return !1;
  }
  canReuseDOM(t) {
    return t.constructor == this.constructor && !((this.flags | t.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let t of this.children)
      t.parent == this && t.destroy();
    this.parent = null;
  }
}
Ut.prototype.breakAfter = 0;
function TS(n) {
  let t = n.nextSibling;
  return n.parentNode.removeChild(n), t;
}
class qv {
  constructor(t, e, i) {
    this.children = t, this.pos = e, this.i = i, this.off = 0;
  }
  findPos(t, e = 1) {
    for (; ; ) {
      if (t > this.pos || t == this.pos && (e > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = t - this.pos, this;
      let i = this.children[--this.i];
      this.pos -= i.length + i.breakAfter;
    }
  }
}
function Cv(n, t, e, i, s, a, o, u, h) {
  let { children: d } = n, p = d.length ? d[t] : null, g = a.length ? a[a.length - 1] : null, y = g ? g.breakAfter : o;
  if (!(t == i && p && !o && !y && a.length < 2 && p.merge(e, s, a.length ? g : null, e == 0, u, h))) {
    if (i < d.length) {
      let Q = d[i];
      Q && (s < Q.length || Q.breakAfter && (g != null && g.breakAfter)) ? (t == i && (Q = Q.split(s), s = 0), !y && g && Q.merge(0, s, g, !0, 0, h) ? a[a.length - 1] = Q : ((s || Q.children.length && !Q.children[0].length) && Q.merge(0, s, null, !1, 0, h), a.push(Q))) : Q != null && Q.breakAfter && (g ? g.breakAfter = 1 : o = 1), i++;
    }
    for (p && (p.breakAfter = o, e > 0 && (!o && a.length && p.merge(e, p.length, a[0], !1, u, 0) ? p.breakAfter = a.shift().breakAfter : (e < p.length || p.children.length && p.children[p.children.length - 1].length == 0) && p.merge(e, p.length, null, !1, u, 0), t++)); t < i && a.length; )
      if (d[i - 1].become(a[a.length - 1]))
        i--, a.pop(), h = a.length ? 0 : u;
      else if (d[t].become(a[0]))
        t++, a.shift(), u = a.length ? 0 : h;
      else
        break;
    !a.length && t && i < d.length && !d[t - 1].breakAfter && d[i].merge(0, 0, d[t - 1], !1, u, h) && t--, (t < i || a.length) && n.replaceChildren(t, i, a);
  }
}
function Zv(n, t, e, i, s, a) {
  let o = n.childCursor(), { i: u, off: h } = o.findPos(e, 1), { i: d, off: p } = o.findPos(t, -1), g = t - e;
  for (let y of i)
    g += y.length;
  n.length += g, Cv(n, d, p, u, h, i, 0, s, a);
}
let je = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, wd = typeof document < "u" ? document : { documentElement: { style: {} } };
const Td = /* @__PURE__ */ /Edge\/(\d+)/.exec(je.userAgent), Ev = /* @__PURE__ */ /MSIE \d/.test(je.userAgent), $d = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(je.userAgent), Du = !!(Ev || $d || Td), $S = !Du && /* @__PURE__ */ /gecko\/(\d+)/i.test(je.userAgent), wO = !Du && /* @__PURE__ */ /Chrome\/(\d+)/.exec(je.userAgent), h2 = "webkitFontSmoothing" in wd.documentElement.style, Xv = !Du && /* @__PURE__ */ /Apple Computer/.test(je.vendor), PS = Xv && (/* @__PURE__ */ /Mobile\/\w+/.test(je.userAgent) || je.maxTouchPoints > 2);
var st = {
  mac: PS || /* @__PURE__ */ /Mac/.test(je.platform),
  windows: /* @__PURE__ */ /Win/.test(je.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(je.platform),
  ie: Du,
  ie_version: Ev ? wd.documentMode || 6 : $d ? +$d[1] : Td ? +Td[1] : 0,
  gecko: $S,
  gecko_version: $S ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(je.userAgent) || [0, 0])[1] : 0,
  chrome: !!wO,
  chrome_version: wO ? +wO[1] : 0,
  ios: PS,
  android: /* @__PURE__ */ /Android\b/.test(je.userAgent),
  safari: Xv,
  webkit_version: h2 ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(je.userAgent) || [0, 0])[1] : 0,
  tabSize: wd.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const O2 = 256;
class Pi extends Ut {
  constructor(t) {
    super(), this.text = t;
  }
  get length() {
    return this.text.length;
  }
  createDOM(t) {
    this.setDOM(t || document.createTextNode(this.text));
  }
  sync(t, e) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (e && e.node == this.dom && (e.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(t) {
    t.nodeType == 3 && this.createDOM(t);
  }
  merge(t, e, i) {
    return this.flags & 8 || i && (!(i instanceof Pi) || this.length - (e - t) + i.length > O2 || i.flags & 8) ? !1 : (this.text = this.text.slice(0, t) + (i ? i.text : "") + this.text.slice(e), this.markDirty(), !0);
  }
  split(t) {
    let e = new Pi(this.text.slice(t));
    return this.text = this.text.slice(0, t), this.markDirty(), e.flags |= this.flags & 8, e;
  }
  localPosFromDOM(t, e) {
    return t == this.dom ? e : e ? this.text.length : 0;
  }
  domAtPos(t) {
    return new qe(this.dom, t);
  }
  domBoundsAround(t, e, i) {
    return { from: i, to: i + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(t, e) {
    return d2(this.dom, t, e);
  }
}
class $n extends Ut {
  constructor(t, e = [], i = 0) {
    super(), this.mark = t, this.children = e, this.length = i;
    for (let s of e)
      s.setParent(this);
  }
  setAttrs(t) {
    if (Pv(t), this.mark.class && (t.className = this.mark.class), this.mark.attrs)
      for (let e in this.mark.attrs)
        t.setAttribute(e, this.mark.attrs[e]);
    return t;
  }
  canReuseDOM(t) {
    return super.canReuseDOM(t) && !((this.flags | t.flags) & 8);
  }
  reuseDOM(t) {
    t.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(t), this.flags |= 6);
  }
  sync(t, e) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(t, e);
  }
  merge(t, e, i, s, a, o) {
    return i && (!(i instanceof $n && i.mark.eq(this.mark)) || t && a <= 0 || e < this.length && o <= 0) ? !1 : (Zv(this, t, e, i ? i.children.slice() : [], a - 1, o - 1), this.markDirty(), !0);
  }
  split(t) {
    let e = [], i = 0, s = -1, a = 0;
    for (let u of this.children) {
      let h = i + u.length;
      h > t && e.push(i < t ? u.split(t - i) : u), s < 0 && i >= t && (s = a), i = h, a++;
    }
    let o = this.length - t;
    return this.length = t, s > -1 && (this.children.length = s, this.markDirty()), new $n(this.mark, e, o);
  }
  domAtPos(t) {
    return _v(this, t);
  }
  coordsAt(t, e) {
    return Dv(this, t, e);
  }
}
function d2(n, t, e) {
  let i = n.nodeValue.length;
  t > i && (t = i);
  let s = t, a = t, o = 0;
  t == 0 && e < 0 || t == i && e >= 0 ? st.chrome || st.gecko || (t ? (s--, o = 1) : a < i && (a++, o = -1)) : e < 0 ? s-- : a < i && a++;
  let u = Nl(n, s, a).getClientRects();
  if (!u.length)
    return null;
  let h = u[(o ? o < 0 : e >= 0) ? 0 : u.length - 1];
  return st.safari && !o && h.width == 0 && (h = Array.prototype.find.call(u, (d) => d.width) || h), o ? Ha(h, o < 0) : h || null;
}
class sl extends Ut {
  static create(t, e, i) {
    return new sl(t, e, i);
  }
  constructor(t, e, i) {
    super(), this.widget = t, this.length = e, this.side = i, this.prevWidget = null;
  }
  split(t) {
    let e = sl.create(this.widget, this.length - t, this.side);
    return this.length -= t, e;
  }
  sync(t) {
    (!this.dom || !this.widget.updateDOM(this.dom, t)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(t, e, i, s, a, o) {
    return i && (!(i instanceof sl) || !this.widget.compare(i.widget) || t > 0 && a <= 0 || e < this.length && o <= 0) ? !1 : (this.length = t + (i ? i.length : 0) + (this.length - e), !0);
  }
  become(t) {
    return t instanceof sl && t.side == this.side && this.widget.constructor == t.widget.constructor ? (this.widget.compare(t.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = t.widget, this.length = t.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(t) {
    return this.widget.ignoreEvent(t);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Rt.empty;
    let t = this;
    for (; t.parent; )
      t = t.parent;
    let { view: e } = t, i = e && e.state.doc, s = this.posAtStart;
    return i ? i.slice(s, s + this.length) : Rt.empty;
  }
  domAtPos(t) {
    return (this.length ? t == 0 : this.side > 0) ? qe.before(this.dom) : qe.after(this.dom, t == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t, e) {
    let i = this.widget.coordsAt(this.dom, t, e);
    if (i)
      return i;
    let s = this.dom.getClientRects(), a = null;
    if (!s.length)
      return null;
    let o = this.side ? this.side < 0 : t > 0;
    for (let u = o ? s.length - 1 : 0; a = s[u], !(t > 0 ? u == 0 : u == s.length - 1 || a.top < a.bottom); u += o ? -1 : 1)
      ;
    return Ha(a, !o);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class tr extends Ut {
  constructor(t) {
    super(), this.side = t;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(t) {
    return t instanceof tr && t.side == this.side;
  }
  split() {
    return new tr(this.side);
  }
  sync() {
    if (!this.dom) {
      let t = document.createElement("img");
      t.className = "cm-widgetBuffer", t.setAttribute("aria-hidden", "true"), this.setDOM(t);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(t) {
    return this.side > 0 ? qe.before(this.dom) : qe.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Rt.empty;
  }
  get isHidden() {
    return !0;
  }
}
Pi.prototype.children = sl.prototype.children = tr.prototype.children = gp;
function _v(n, t) {
  let e = n.dom, { children: i } = n, s = 0;
  for (let a = 0; s < i.length; s++) {
    let o = i[s], u = a + o.length;
    if (!(u == a && o.getSide() <= 0)) {
      if (t > a && t < u && o.dom.parentNode == e)
        return o.domAtPos(t - a);
      if (t <= a)
        break;
      a = u;
    }
  }
  for (let a = s; a > 0; a--) {
    let o = i[a - 1];
    if (o.dom.parentNode == e)
      return o.domAtPos(o.length);
  }
  for (let a = s; a < i.length; a++) {
    let o = i[a];
    if (o.dom.parentNode == e)
      return o.domAtPos(0);
  }
  return new qe(e, 0);
}
function zv(n, t, e) {
  let i, { children: s } = n;
  e > 0 && t instanceof $n && s.length && (i = s[s.length - 1]) instanceof $n && i.mark.eq(t.mark) ? zv(i, t.children[0], e - 1) : (s.push(t), t.setParent(n)), n.length += t.length;
}
function Dv(n, t, e) {
  let i = null, s = -1, a = null, o = -1;
  function u(d, p) {
    for (let g = 0, y = 0; g < d.children.length && y <= p; g++) {
      let Q = d.children[g], b = y + Q.length;
      b >= p && (Q.children.length ? u(Q, p - y) : (!a || a.isHidden && (e > 0 || m2(a, Q))) && (b > p || y == b && Q.getSide() > 0) ? (a = Q, o = p - y) : (y < p || y == b && Q.getSide() < 0 && !Q.isHidden) && (i = Q, s = p - y)), y = b;
    }
  }
  u(n, t);
  let h = (e < 0 ? i : a) || i || a;
  return h ? h.coordsAt(Math.max(0, h == i ? s : o), e) : p2(n);
}
function p2(n) {
  let t = n.dom.lastChild;
  if (!t)
    return n.dom.getBoundingClientRect();
  let e = Fs(t);
  return e[e.length - 1] || null;
}
function m2(n, t) {
  let e = n.coordsAt(0, 1), i = t.coordsAt(0, 1);
  return e && i && i.top < e.bottom;
}
function Pd(n, t) {
  for (let e in n)
    e == "class" && t.class ? t.class += " " + n.class : e == "style" && t.style ? t.style += ";" + n.style : t[e] = n[e];
  return t;
}
const RS = /* @__PURE__ */ Object.create(null);
function pu(n, t, e) {
  if (n == t)
    return !0;
  n || (n = RS), t || (t = RS);
  let i = Object.keys(n), s = Object.keys(t);
  if (i.length - (e && i.indexOf(e) > -1 ? 1 : 0) != s.length - (e && s.indexOf(e) > -1 ? 1 : 0))
    return !1;
  for (let a of i)
    if (a != e && (s.indexOf(a) == -1 || n[a] !== t[a]))
      return !1;
  return !0;
}
function Rd(n, t, e) {
  let i = !1;
  if (t)
    for (let s in t)
      e && s in e || (i = !0, s == "style" ? n.style.cssText = "" : n.removeAttribute(s));
  if (e)
    for (let s in e)
      t && t[s] == e[s] || (i = !0, s == "style" ? n.style.cssText = e[s] : n.setAttribute(s, e[s]));
  return i;
}
function g2(n) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let e = 0; e < n.attributes.length; e++) {
    let i = n.attributes[e];
    t[i.name] = i.value;
  }
  return t;
}
class tn {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(t) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(t, e) {
    return !1;
  }
  /**
  @internal
  */
  compare(t) {
    return this == t || this.constructor == t.constructor && this.eq(t);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(t) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(t, e, i) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(t) {
  }
}
var Ee = /* @__PURE__ */ function(n) {
  return n[n.Text = 0] = "Text", n[n.WidgetBefore = 1] = "WidgetBefore", n[n.WidgetAfter = 2] = "WidgetAfter", n[n.WidgetRange = 3] = "WidgetRange", n;
}(Ee || (Ee = {}));
class ft extends Bl {
  constructor(t, e, i, s) {
    super(), this.startSide = t, this.endSide = e, this.widget = i, this.spec = s;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(t) {
    return new Ka(t);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(t) {
    let e = Math.max(-1e4, Math.min(1e4, t.side || 0)), i = !!t.block;
    return e += i && !t.inlineOrder ? e > 0 ? 3e8 : -4e8 : e > 0 ? 1e8 : -1e8, new fl(t, e, e, i, t.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(t) {
    let e = !!t.block, i, s;
    if (t.isBlockGap)
      i = -5e8, s = 4e8;
    else {
      let { start: a, end: o } = Vv(t, e);
      i = (a ? e ? -3e8 : -1 : 5e8) - 1, s = (o ? e ? 2e8 : 1 : -6e8) + 1;
    }
    return new fl(t, i, s, e, t.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(t) {
    return new Ja(t);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(t, e = !1) {
    return Mt.of(t, e);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
ft.none = Mt.empty;
class Ka extends ft {
  constructor(t) {
    let { start: e, end: i } = Vv(t);
    super(e ? -1 : 5e8, i ? 1 : -6e8, null, t), this.tagName = t.tagName || "span", this.class = t.class || "", this.attrs = t.attributes || null;
  }
  eq(t) {
    var e, i;
    return this == t || t instanceof Ka && this.tagName == t.tagName && (this.class || ((e = this.attrs) === null || e === void 0 ? void 0 : e.class)) == (t.class || ((i = t.attrs) === null || i === void 0 ? void 0 : i.class)) && pu(this.attrs, t.attrs, "class");
  }
  range(t, e = t) {
    if (t >= e)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(t, e);
  }
}
Ka.prototype.point = !1;
class Ja extends ft {
  constructor(t) {
    super(-2e8, -2e8, null, t);
  }
  eq(t) {
    return t instanceof Ja && this.spec.class == t.spec.class && pu(this.spec.attributes, t.spec.attributes);
  }
  range(t, e = t) {
    if (e != t)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(t, e);
  }
}
Ja.prototype.mapMode = we.TrackBefore;
Ja.prototype.point = !0;
class fl extends ft {
  constructor(t, e, i, s, a, o) {
    super(e, i, a, t), this.block = s, this.isReplace = o, this.mapMode = s ? e <= 0 ? we.TrackBefore : we.TrackAfter : we.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? Ee.WidgetRange : this.startSide <= 0 ? Ee.WidgetBefore : Ee.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(t) {
    return t instanceof fl && y2(this.widget, t.widget) && this.block == t.block && this.startSide == t.startSide && this.endSide == t.endSide;
  }
  range(t, e = t) {
    if (this.isReplace && (t > e || t == e && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && e != t)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(t, e);
  }
}
fl.prototype.point = !0;
function Vv(n, t = !1) {
  let { inclusiveStart: e, inclusiveEnd: i } = n;
  return e == null && (e = n.inclusive), i == null && (i = n.inclusive), { start: e ?? t, end: i ?? t };
}
function y2(n, t) {
  return n == t || !!(n && t && n.compare(t));
}
function Jc(n, t, e, i = 0) {
  let s = e.length - 1;
  s >= 0 && e[s] + i >= n ? e[s] = Math.max(e[s], t) : e.push(n, t);
}
class re extends Ut {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(t, e, i, s, a, o) {
    if (i) {
      if (!(i instanceof re))
        return !1;
      this.dom || i.transferDOM(this);
    }
    return s && this.setDeco(i ? i.attrs : null), Zv(this, t, e, i ? i.children.slice() : [], a, o), !0;
  }
  split(t) {
    let e = new re();
    if (e.breakAfter = this.breakAfter, this.length == 0)
      return e;
    let { i, off: s } = this.childPos(t);
    s && (e.append(this.children[i].split(s), 0), this.children[i].merge(s, this.children[i].length, null, !1, 0, 0), i++);
    for (let a = i; a < this.children.length; a++)
      e.append(this.children[a], 0);
    for (; i > 0 && this.children[i - 1].length == 0; )
      this.children[--i].destroy();
    return this.children.length = i, this.markDirty(), this.length = t, e;
  }
  transferDOM(t) {
    this.dom && (this.markDirty(), t.setDOM(this.dom), t.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(t) {
    pu(this.attrs, t) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = t);
  }
  append(t, e) {
    zv(this, t, e);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(t) {
    let e = t.spec.attributes, i = t.spec.class;
    e && (this.attrs = Pd(e, this.attrs || {})), i && (this.attrs = Pd({ class: i }, this.attrs || {}));
  }
  domAtPos(t) {
    return _v(this, t);
  }
  reuseDOM(t) {
    t.nodeName == "DIV" && (this.setDOM(t), this.flags |= 6);
  }
  sync(t, e) {
    var i;
    this.dom ? this.flags & 4 && (Pv(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (Rd(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(t, e);
    let s = this.dom.lastChild;
    for (; s && Ut.get(s) instanceof $n; )
      s = s.lastChild;
    if (!s || !this.length || s.nodeName != "BR" && ((i = Ut.get(s)) === null || i === void 0 ? void 0 : i.isEditable) == !1 && (!st.ios || !this.children.some((a) => a instanceof Pi))) {
      let a = document.createElement("BR");
      a.cmIgnore = !0, this.dom.appendChild(a);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let t = 0, e;
    for (let i of this.children) {
      if (!(i instanceof Pi) || /[^ -~]/.test(i.text))
        return null;
      let s = Fs(i.dom);
      if (s.length != 1)
        return null;
      t += s[0].width, e = s[0].height;
    }
    return t ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: t / this.length,
      textHeight: e
    } : null;
  }
  coordsAt(t, e) {
    let i = Dv(this, t, e);
    if (!this.children.length && i && this.parent) {
      let { heightOracle: s } = this.parent.view.viewState, a = i.bottom - i.top;
      if (Math.abs(a - s.lineHeight) < 2 && s.textHeight < a) {
        let o = (a - s.textHeight) / 2;
        return { top: i.top + o, bottom: i.bottom - o, left: i.left, right: i.left };
      }
    }
    return i;
  }
  become(t) {
    return t instanceof re && this.children.length == 0 && t.children.length == 0 && pu(this.attrs, t.attrs) && this.breakAfter == t.breakAfter;
  }
  covers() {
    return !0;
  }
  static find(t, e) {
    for (let i = 0, s = 0; i < t.children.length; i++) {
      let a = t.children[i], o = s + a.length;
      if (o >= e) {
        if (a instanceof re)
          return a;
        if (o > e)
          break;
      }
      s = o + a.breakAfter;
    }
    return null;
  }
}
class wn extends Ut {
  constructor(t, e, i) {
    super(), this.widget = t, this.length = e, this.deco = i, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(t, e, i, s, a, o) {
    return i && (!(i instanceof wn) || !this.widget.compare(i.widget) || t > 0 && a <= 0 || e < this.length && o <= 0) ? !1 : (this.length = t + (i ? i.length : 0) + (this.length - e), !0);
  }
  domAtPos(t) {
    return t == 0 ? qe.before(this.dom) : qe.after(this.dom, t == this.length);
  }
  split(t) {
    let e = this.length - t;
    this.length = t;
    let i = new wn(this.widget, e, this.deco);
    return i.breakAfter = this.breakAfter, i;
  }
  get children() {
    return gp;
  }
  sync(t) {
    (!this.dom || !this.widget.updateDOM(this.dom, t)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Rt.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(t) {
    return t instanceof wn && t.widget.constructor == this.widget.constructor ? (t.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = t.widget, this.length = t.length, this.deco = t.deco, this.breakAfter = t.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(t) {
    return this.widget.ignoreEvent(t);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(t, e) {
    let i = this.widget.coordsAt(this.dom, t, e);
    return i || (this.widget instanceof Ad ? null : Ha(this.dom.getBoundingClientRect(), this.length ? t == 0 : e <= 0));
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(t) {
    let { startSide: e, endSide: i } = this.deco;
    return e == i ? !1 : t < 0 ? e < 0 : i > 0;
  }
}
class Ad extends tn {
  constructor(t) {
    super(), this.height = t;
  }
  toDOM() {
    let t = document.createElement("div");
    return t.className = "cm-gap", this.updateDOM(t), t;
  }
  eq(t) {
    return t.height == this.height;
  }
  updateDOM(t) {
    return t.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
class $a {
  constructor(t, e, i, s) {
    this.doc = t, this.pos = e, this.end = i, this.disallowBlockEffectsFor = s, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = t.iter(), this.skip = e;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let t = this.content[this.content.length - 1];
    return !(t.breakAfter || t instanceof wn && t.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new re()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(t = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(Tc(new tr(-1), t), t.length), this.pendingBuffer = 0);
  }
  addBlockWidget(t) {
    this.flushBuffer(), this.curLine = null, this.content.push(t);
  }
  finish(t) {
    this.pendingBuffer && t <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(t && this.content.length && this.content[this.content.length - 1] instanceof wn) && this.getLine();
  }
  buildText(t, e, i) {
    for (; t > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: a, lineBreak: o, done: u } = this.cursor.next(this.skip);
        if (this.skip = 0, u)
          throw new Error("Ran out of text content when drawing inline views");
        if (o) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, t--;
          continue;
        } else
          this.text = a, this.textOff = 0;
      }
      let s = Math.min(
        this.text.length - this.textOff,
        t,
        512
        /* T.Chunk */
      );
      this.flushBuffer(e.slice(e.length - i)), this.getLine().append(Tc(new Pi(this.text.slice(this.textOff, this.textOff + s)), e), i), this.atCursorPos = !0, this.textOff += s, t -= s, i = 0;
    }
  }
  span(t, e, i, s) {
    this.buildText(e - t, i, s), this.pos = e, this.openStart < 0 && (this.openStart = s);
  }
  point(t, e, i, s, a, o) {
    if (this.disallowBlockEffectsFor[o] && i instanceof fl) {
      if (i.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (e > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let u = e - t;
    if (i instanceof fl)
      if (i.block)
        i.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new wn(i.widget || er.block, u, i));
      else {
        let h = sl.create(i.widget || er.inline, u, u ? 0 : i.startSide), d = this.atCursorPos && !h.isEditable && a <= s.length && (t < e || i.startSide > 0), p = !h.isEditable && (t < e || a > s.length || i.startSide <= 0), g = this.getLine();
        this.pendingBuffer == 2 && !d && !h.isEditable && (this.pendingBuffer = 0), this.flushBuffer(s), d && (g.append(Tc(new tr(1), s), a), a = s.length + Math.max(0, a - s.length)), g.append(Tc(h, s), a), this.atCursorPos = p, this.pendingBuffer = p ? t < e || a > s.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = s.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i);
    u && (this.textOff + u <= this.text.length ? this.textOff += u : (this.skip += u - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = e), this.openStart < 0 && (this.openStart = a);
  }
  static build(t, e, i, s, a) {
    let o = new $a(t, e, i, a);
    return o.openEnd = Mt.spans(s, e, i, o), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o;
  }
}
function Tc(n, t) {
  for (let e of t)
    n = new $n(e, [n], n.length);
  return n;
}
class er extends tn {
  constructor(t) {
    super(), this.tag = t;
  }
  eq(t) {
    return t.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(t) {
    return t.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
er.inline = /* @__PURE__ */ new er("span");
er.block = /* @__PURE__ */ new er("div");
var Bt = /* @__PURE__ */ function(n) {
  return n[n.LTR = 0] = "LTR", n[n.RTL = 1] = "RTL", n;
}(Bt || (Bt = {}));
const Wl = Bt.LTR, yp = Bt.RTL;
function Yv(n) {
  let t = [];
  for (let e = 0; e < n.length; e++)
    t.push(1 << +n[e]);
  return t;
}
const S2 = /* @__PURE__ */ Yv("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), Q2 = /* @__PURE__ */ Yv("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), Md = /* @__PURE__ */ Object.create(null), _i = [];
for (let n of ["()", "[]", "{}"]) {
  let t = /* @__PURE__ */ n.charCodeAt(0), e = /* @__PURE__ */ n.charCodeAt(1);
  Md[t] = e, Md[e] = -t;
}
function Uv(n) {
  return n <= 247 ? S2[n] : 1424 <= n && n <= 1524 ? 2 : 1536 <= n && n <= 1785 ? Q2[n - 1536] : 1774 <= n && n <= 2220 ? 4 : 8192 <= n && n <= 8204 ? 256 : 64336 <= n && n <= 65023 ? 4 : 1;
}
const v2 = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class rl {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? yp : Wl;
  }
  /**
  @internal
  */
  constructor(t, e, i) {
    this.from = t, this.to = e, this.level = i;
  }
  /**
  @internal
  */
  side(t, e) {
    return this.dir == e == t ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(t, e) {
    return t == (this.dir == e);
  }
  /**
  @internal
  */
  static find(t, e, i, s) {
    let a = -1;
    for (let o = 0; o < t.length; o++) {
      let u = t[o];
      if (u.from <= e && u.to >= e) {
        if (u.level == i)
          return o;
        (a < 0 || (s != 0 ? s < 0 ? u.from < e : u.to > e : t[a].level > u.level)) && (a = o);
      }
    }
    if (a < 0)
      throw new RangeError("Index out of range");
    return a;
  }
}
function jv(n, t) {
  if (n.length != t.length)
    return !1;
  for (let e = 0; e < n.length; e++) {
    let i = n[e], s = t[e];
    if (i.from != s.from || i.to != s.to || i.direction != s.direction || !jv(i.inner, s.inner))
      return !1;
  }
  return !0;
}
const Yt = [];
function b2(n, t, e, i, s) {
  for (let a = 0; a <= i.length; a++) {
    let o = a ? i[a - 1].to : t, u = a < i.length ? i[a].from : e, h = a ? 256 : s;
    for (let d = o, p = h, g = h; d < u; d++) {
      let y = Uv(n.charCodeAt(d));
      y == 512 ? y = p : y == 8 && g == 4 && (y = 16), Yt[d] = y == 4 ? 2 : y, y & 7 && (g = y), p = y;
    }
    for (let d = o, p = h, g = h; d < u; d++) {
      let y = Yt[d];
      if (y == 128)
        d < u - 1 && p == Yt[d + 1] && p & 24 ? y = Yt[d] = p : Yt[d] = 256;
      else if (y == 64) {
        let Q = d + 1;
        for (; Q < u && Yt[Q] == 64; )
          Q++;
        let b = d && p == 8 || Q < e && Yt[Q] == 8 ? g == 1 ? 1 : 8 : 256;
        for (let x = d; x < Q; x++)
          Yt[x] = b;
        d = Q - 1;
      } else y == 8 && g == 1 && (Yt[d] = 1);
      p = y, y & 7 && (g = y);
    }
  }
}
function x2(n, t, e, i, s) {
  let a = s == 1 ? 2 : 1;
  for (let o = 0, u = 0, h = 0; o <= i.length; o++) {
    let d = o ? i[o - 1].to : t, p = o < i.length ? i[o].from : e;
    for (let g = d, y, Q, b; g < p; g++)
      if (Q = Md[y = n.charCodeAt(g)])
        if (Q < 0) {
          for (let x = u - 3; x >= 0; x -= 3)
            if (_i[x + 1] == -Q) {
              let P = _i[x + 2], A = P & 2 ? s : P & 4 ? P & 1 ? a : s : 0;
              A && (Yt[g] = Yt[_i[x]] = A), u = x;
              break;
            }
        } else {
          if (_i.length == 189)
            break;
          _i[u++] = g, _i[u++] = y, _i[u++] = h;
        }
      else if ((b = Yt[g]) == 2 || b == 1) {
        let x = b == s;
        h = x ? 0 : 1;
        for (let P = u - 3; P >= 0; P -= 3) {
          let A = _i[P + 2];
          if (A & 2)
            break;
          if (x)
            _i[P + 2] |= 2;
          else {
            if (A & 4)
              break;
            _i[P + 2] |= 4;
          }
        }
      }
  }
}
function k2(n, t, e, i) {
  for (let s = 0, a = i; s <= e.length; s++) {
    let o = s ? e[s - 1].to : n, u = s < e.length ? e[s].from : t;
    for (let h = o; h < u; ) {
      let d = Yt[h];
      if (d == 256) {
        let p = h + 1;
        for (; ; )
          if (p == u) {
            if (s == e.length)
              break;
            p = e[s++].to, u = s < e.length ? e[s].from : t;
          } else if (Yt[p] == 256)
            p++;
          else
            break;
        let g = a == 1, y = (p < t ? Yt[p] : i) == 1, Q = g == y ? g ? 1 : 2 : i;
        for (let b = p, x = s, P = x ? e[x - 1].to : n; b > h; )
          b == P && (b = e[--x].from, P = x ? e[x - 1].to : n), Yt[--b] = Q;
        h = p;
      } else
        a = d, h++;
    }
  }
}
function qd(n, t, e, i, s, a, o) {
  let u = i % 2 ? 2 : 1;
  if (i % 2 == s % 2)
    for (let h = t, d = 0; h < e; ) {
      let p = !0, g = !1;
      if (d == a.length || h < a[d].from) {
        let x = Yt[h];
        x != u && (p = !1, g = x == 16);
      }
      let y = !p && u == 1 ? [] : null, Q = p ? i : i + 1, b = h;
      t: for (; ; )
        if (d < a.length && b == a[d].from) {
          if (g)
            break t;
          let x = a[d];
          if (!p)
            for (let P = x.to, A = d + 1; ; ) {
              if (P == e)
                break t;
              if (A < a.length && a[A].from == P)
                P = a[A++].to;
              else {
                if (Yt[P] == u)
                  break t;
                break;
              }
            }
          if (d++, y)
            y.push(x);
          else {
            x.from > h && o.push(new rl(h, x.from, Q));
            let P = x.direction == Wl != !(Q % 2);
            Cd(n, P ? i + 1 : i, s, x.inner, x.from, x.to, o), h = x.to;
          }
          b = x.to;
        } else {
          if (b == e || (p ? Yt[b] != u : Yt[b] == u))
            break;
          b++;
        }
      y ? qd(n, h, b, i + 1, s, y, o) : h < b && o.push(new rl(h, b, Q)), h = b;
    }
  else
    for (let h = e, d = a.length; h > t; ) {
      let p = !0, g = !1;
      if (!d || h > a[d - 1].to) {
        let x = Yt[h - 1];
        x != u && (p = !1, g = x == 16);
      }
      let y = !p && u == 1 ? [] : null, Q = p ? i : i + 1, b = h;
      t: for (; ; )
        if (d && b == a[d - 1].to) {
          if (g)
            break t;
          let x = a[--d];
          if (!p)
            for (let P = x.from, A = d; ; ) {
              if (P == t)
                break t;
              if (A && a[A - 1].to == P)
                P = a[--A].from;
              else {
                if (Yt[P - 1] == u)
                  break t;
                break;
              }
            }
          if (y)
            y.push(x);
          else {
            x.to < h && o.push(new rl(x.to, h, Q));
            let P = x.direction == Wl != !(Q % 2);
            Cd(n, P ? i + 1 : i, s, x.inner, x.from, x.to, o), h = x.from;
          }
          b = x.from;
        } else {
          if (b == t || (p ? Yt[b - 1] != u : Yt[b - 1] == u))
            break;
          b--;
        }
      y ? qd(n, b, h, i + 1, s, y, o) : b < h && o.push(new rl(b, h, Q)), h = b;
    }
}
function Cd(n, t, e, i, s, a, o) {
  let u = t % 2 ? 2 : 1;
  b2(n, s, a, i, u), x2(n, s, a, i, u), k2(s, a, i, u), qd(n, s, a, t, e, i, o);
}
function w2(n, t, e) {
  if (!n)
    return [new rl(0, 0, t == yp ? 1 : 0)];
  if (t == Wl && !e.length && !v2.test(n))
    return Lv(n.length);
  if (e.length)
    for (; n.length > Yt.length; )
      Yt[Yt.length] = 256;
  let i = [], s = t == Wl ? 0 : 1;
  return Cd(n, s, s, e, 0, n.length, i), i;
}
function Lv(n) {
  return [new rl(0, n, 0)];
}
let Bv = "";
function T2(n, t, e, i, s) {
  var a;
  let o = i.head - n.from, u = rl.find(t, o, (a = i.bidiLevel) !== null && a !== void 0 ? a : -1, i.assoc), h = t[u], d = h.side(s, e);
  if (o == d) {
    let y = u += s ? 1 : -1;
    if (y < 0 || y >= t.length)
      return null;
    h = t[u = y], o = h.side(!s, e), d = h.side(s, e);
  }
  let p = Te(n.text, o, h.forward(s, e));
  (p < h.from || p > h.to) && (p = d), Bv = n.text.slice(Math.min(o, p), Math.max(o, p));
  let g = u == (s ? t.length - 1 : 0) ? null : t[u + (s ? 1 : -1)];
  return g && p == d && g.level + (s ? 0 : 1) < h.level ? j.cursor(g.side(!s, e) + n.from, g.forward(s, e) ? 1 : -1, g.level) : j.cursor(p + n.from, h.forward(s, e) ? -1 : 1, h.level);
}
function $2(n, t, e) {
  for (let i = t; i < e; i++) {
    let s = Uv(n.charCodeAt(i));
    if (s == 1)
      return Wl;
    if (s == 2 || s == 4)
      return yp;
  }
  return Wl;
}
const Gv = /* @__PURE__ */ lt.define(), Nv = /* @__PURE__ */ lt.define(), Wv = /* @__PURE__ */ lt.define(), Hv = /* @__PURE__ */ lt.define(), Zd = /* @__PURE__ */ lt.define(), Kv = /* @__PURE__ */ lt.define(), Jv = /* @__PURE__ */ lt.define(), Sp = /* @__PURE__ */ lt.define(), Qp = /* @__PURE__ */ lt.define(), Iv = /* @__PURE__ */ lt.define({
  combine: (n) => n.some((t) => t)
}), Fv = /* @__PURE__ */ lt.define({
  combine: (n) => n.some((t) => t)
}), tb = /* @__PURE__ */ lt.define();
class Ws {
  constructor(t, e = "nearest", i = "nearest", s = 5, a = 5, o = !1) {
    this.range = t, this.y = e, this.x = i, this.yMargin = s, this.xMargin = a, this.isSnapshot = o;
  }
  map(t) {
    return t.empty ? this : new Ws(this.range.map(t), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(t) {
    return this.range.to <= t.doc.length ? this : new Ws(j.cursor(t.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const $c = /* @__PURE__ */ yt.define({ map: (n, t) => n.map(t) }), eb = /* @__PURE__ */ yt.define();
function Be(n, t, e) {
  let i = n.facet(Hv);
  i.length ? i[0](t) : window.onerror && window.onerror(String(t), e, void 0, void 0, t) || (e ? console.error(e + ":", t) : console.error(t));
}
const xn = /* @__PURE__ */ lt.define({ combine: (n) => n.length ? n[0] : !0 });
let P2 = 0;
const ya = /* @__PURE__ */ lt.define();
class ne {
  constructor(t, e, i, s, a) {
    this.id = t, this.create = e, this.domEventHandlers = i, this.domEventObservers = s, this.extension = a(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(t, e) {
    const { eventHandlers: i, eventObservers: s, provide: a, decorations: o } = e || {};
    return new ne(P2++, t, i, s, (u) => {
      let h = [ya.of(u)];
      return o && h.push(Za.of((d) => {
        let p = d.plugin(u);
        return p ? o(p) : ft.none;
      })), a && h.push(a(u)), h;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(t, e) {
    return ne.define((i) => new t(i), e);
  }
}
class TO {
  constructor(t) {
    this.spec = t, this.mustUpdate = null, this.value = null;
  }
  update(t) {
    if (this.value) {
      if (this.mustUpdate) {
        let e = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(e);
          } catch (i) {
            if (Be(e.state, i, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(t);
      } catch (e) {
        Be(t.state, e, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(t) {
    var e;
    if (!((e = this.value) === null || e === void 0) && e.destroy)
      try {
        this.value.destroy();
      } catch (i) {
        Be(t.state, i, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const ib = /* @__PURE__ */ lt.define(), vp = /* @__PURE__ */ lt.define(), Za = /* @__PURE__ */ lt.define(), nb = /* @__PURE__ */ lt.define(), bp = /* @__PURE__ */ lt.define(), lb = /* @__PURE__ */ lt.define();
function AS(n, t) {
  let e = n.state.facet(lb);
  if (!e.length)
    return e;
  let i = e.map((a) => a instanceof Function ? a(n) : a), s = [];
  return Mt.spans(i, t.from, t.to, {
    point() {
    },
    span(a, o, u, h) {
      let d = a - t.from, p = o - t.from, g = s;
      for (let y = u.length - 1; y >= 0; y--, h--) {
        let Q = u[y].spec.bidiIsolate, b;
        if (Q == null && (Q = $2(t.text, d, p)), h > 0 && g.length && (b = g[g.length - 1]).to == d && b.direction == Q)
          b.to = p, g = b.inner;
        else {
          let x = { from: d, to: p, direction: Q, inner: [] };
          g.push(x), g = x.inner;
        }
      }
    }
  }), s;
}
const sb = /* @__PURE__ */ lt.define();
function xp(n) {
  let t = 0, e = 0, i = 0, s = 0;
  for (let a of n.state.facet(sb)) {
    let o = a(n);
    o && (o.left != null && (t = Math.max(t, o.left)), o.right != null && (e = Math.max(e, o.right)), o.top != null && (i = Math.max(i, o.top)), o.bottom != null && (s = Math.max(s, o.bottom)));
  }
  return { left: t, right: e, top: i, bottom: s };
}
const Sa = /* @__PURE__ */ lt.define();
class vi {
  constructor(t, e, i, s) {
    this.fromA = t, this.toA = e, this.fromB = i, this.toB = s;
  }
  join(t) {
    return new vi(Math.min(this.fromA, t.fromA), Math.max(this.toA, t.toA), Math.min(this.fromB, t.fromB), Math.max(this.toB, t.toB));
  }
  addToSet(t) {
    let e = t.length, i = this;
    for (; e > 0; e--) {
      let s = t[e - 1];
      if (!(s.fromA > i.toA)) {
        if (s.toA < i.fromA)
          break;
        i = i.join(s), t.splice(e - 1, 1);
      }
    }
    return t.splice(e, 0, i), t;
  }
  static extendWithRanges(t, e) {
    if (e.length == 0)
      return t;
    let i = [];
    for (let s = 0, a = 0, o = 0, u = 0; ; s++) {
      let h = s == t.length ? null : t[s], d = o - u, p = h ? h.fromB : 1e9;
      for (; a < e.length && e[a] < p; ) {
        let g = e[a], y = e[a + 1], Q = Math.max(u, g), b = Math.min(p, y);
        if (Q <= b && new vi(Q + d, b + d, Q, b).addToSet(i), y > p)
          break;
        a += 2;
      }
      if (!h)
        return i;
      new vi(h.fromA, h.toA, h.fromB, h.toB).addToSet(i), o = h.toA, u = h.toB;
    }
  }
}
class mu {
  constructor(t, e, i) {
    this.view = t, this.state = e, this.transactions = i, this.flags = 0, this.startState = t.state, this.changes = Oe.empty(this.startState.doc.length);
    for (let a of i)
      this.changes = this.changes.compose(a.changes);
    let s = [];
    this.changes.iterChangedRanges((a, o, u, h) => s.push(new vi(a, o, u, h))), this.changedRanges = s;
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new mu(t, e, i);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 18) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((t) => t.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class MS extends Ut {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(t) {
    super(), this.view = t, this.decorations = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = ft.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(t.contentDOM), this.children = [new re()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new vi(0, 0, 0, t.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(t) {
    var e;
    let i = t.changedRanges;
    this.minWidth > 0 && i.length && (i.every(({ fromA: d, toA: p }) => p < this.minWidthFrom || d > this.minWidthTo) ? (this.minWidthFrom = t.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = t.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(t);
    let s = -1;
    this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((e = this.domChanged) === null || e === void 0) && e.newSel ? s = this.domChanged.newSel.head : !E2(t.changes, this.hasComposition) && !t.selectionSet && (s = t.state.selection.main.head));
    let a = s > -1 ? A2(this.view, t.changes, s) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: d, to: p } = this.hasComposition;
      i = new vi(d, p, t.changes.mapPos(d, -1), t.changes.mapPos(p, 1)).addToSet(i.slice());
    }
    this.hasComposition = a ? { from: a.range.fromB, to: a.range.toB } : null, (st.ie || st.chrome) && !a && t && t.state.doc.lines != t.startState.doc.lines && (this.forceSelection = !0);
    let o = this.decorations, u = this.updateDeco(), h = C2(o, u, t.changes);
    return i = vi.extendWithRanges(i, h), !(this.flags & 7) && i.length == 0 ? !1 : (this.updateInner(i, t.startState.doc.length, a), t.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(t, e, i) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(t, e, i);
    let { observer: s } = this.view;
    s.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let o = st.chrome || st.ios ? { node: s.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, o), this.flags &= -8, o && (o.written || s.selectionRange.focusNode != o.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (o) => o.flags &= -9
      /* ViewFlag.Composition */
    );
    let a = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let o of this.children)
        o instanceof wn && o.widget instanceof Ad && a.push(o.dom);
    s.updateGaps(a);
  }
  updateChildren(t, e, i) {
    let s = i ? i.range.addToSet(t.slice()) : t, a = this.childCursor(e);
    for (let o = s.length - 1; ; o--) {
      let u = o >= 0 ? s[o] : null;
      if (!u)
        break;
      let { fromA: h, toA: d, fromB: p, toB: g } = u, y, Q, b, x;
      if (i && i.range.fromB < g && i.range.toB > p) {
        let H = $a.build(this.view.state.doc, p, i.range.fromB, this.decorations, this.dynamicDecorationMap), _ = $a.build(this.view.state.doc, i.range.toB, g, this.decorations, this.dynamicDecorationMap);
        Q = H.breakAtStart, b = H.openStart, x = _.openEnd;
        let W = this.compositionView(i);
        _.breakAtStart ? W.breakAfter = 1 : _.content.length && W.merge(W.length, W.length, _.content[0], !1, _.openStart, 0) && (W.breakAfter = _.content[0].breakAfter, _.content.shift()), H.content.length && W.merge(0, 0, H.content[H.content.length - 1], !0, 0, H.openEnd) && H.content.pop(), y = H.content.concat(W).concat(_.content);
      } else
        ({ content: y, breakAtStart: Q, openStart: b, openEnd: x } = $a.build(this.view.state.doc, p, g, this.decorations, this.dynamicDecorationMap));
      let { i: P, off: A } = a.findPos(d, 1), { i: V, off: G } = a.findPos(h, -1);
      Cv(this, V, G, P, A, y, Q, b, x);
    }
    i && this.fixCompositionDOM(i);
  }
  updateEditContextFormatting(t) {
    this.editContextFormatting = this.editContextFormatting.map(t.changes);
    for (let e of t.transactions)
      for (let i of e.effects)
        i.is(eb) && (this.editContextFormatting = i.value);
  }
  compositionView(t) {
    let e = new Pi(t.text.nodeValue);
    e.flags |= 8;
    for (let { deco: s } of t.marks)
      e = new $n(s, [e], e.length);
    let i = new re();
    return i.append(e, 0), i;
  }
  fixCompositionDOM(t) {
    let e = (a, o) => {
      o.flags |= 8 | (o.children.some(
        (h) => h.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(o);
      let u = Ut.get(a);
      u && u != o && (u.dom = null), o.setDOM(a);
    }, i = this.childPos(t.range.fromB, 1), s = this.children[i.i];
    e(t.line, s);
    for (let a = t.marks.length - 1; a >= -1; a--)
      i = s.childPos(i.off, 1), s = s.children[i.i], e(a >= 0 ? t.marks[a].node : t.text, s);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(t = !1, e = !1) {
    (t || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let i = this.view.root.activeElement, s = i == this.dom, a = !s && !(this.view.state.facet(xn) || this.dom.tabIndex > -1) && Kc(this.dom, this.view.observer.selectionRange) && !(i && this.dom.contains(i));
    if (!(s || e || a))
      return;
    let o = this.forceSelection;
    this.forceSelection = !1;
    let u = this.view.state.selection.main, h = this.moveToLine(this.domAtPos(u.anchor)), d = u.empty ? h : this.moveToLine(this.domAtPos(u.head));
    if (st.gecko && u.empty && !this.hasComposition && R2(h)) {
      let g = document.createTextNode("");
      this.view.observer.ignore(() => h.node.insertBefore(g, h.node.childNodes[h.offset] || null)), h = d = new qe(g, 0), o = !0;
    }
    let p = this.view.observer.selectionRange;
    (o || !p.focusNode || (!Ta(h.node, h.offset, p.anchorNode, p.anchorOffset) || !Ta(d.node, d.offset, p.focusNode, p.focusOffset)) && !this.suppressWidgetCursorChange(p, u)) && (this.view.observer.ignore(() => {
      st.android && st.chrome && this.dom.contains(p.focusNode) && Z2(p.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let g = Ca(this.view.root);
      if (g) if (u.empty) {
        if (st.gecko) {
          let y = M2(h.node, h.offset);
          if (y && y != 3) {
            let Q = (y == 1 ? Av : Mv)(h.node, h.offset);
            Q && (h = new qe(Q.node, Q.offset));
          }
        }
        g.collapse(h.node, h.offset), u.bidiLevel != null && g.caretBidiLevel !== void 0 && (g.caretBidiLevel = u.bidiLevel);
      } else if (g.extend) {
        g.collapse(h.node, h.offset);
        try {
          g.extend(d.node, d.offset);
        } catch {
        }
      } else {
        let y = document.createRange();
        u.anchor > u.head && ([h, d] = [d, h]), y.setEnd(d.node, d.offset), y.setStart(h.node, h.offset), g.removeAllRanges(), g.addRange(y);
      }
      a && this.view.root.activeElement == this.dom && (this.dom.blur(), i && i.focus());
    }), this.view.observer.setSelectionRange(h, d)), this.impreciseAnchor = h.precise ? null : new qe(p.anchorNode, p.anchorOffset), this.impreciseHead = d.precise ? null : new qe(p.focusNode, p.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(t, e) {
    return this.hasComposition && e.empty && Ta(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset) && this.posFromDOM(t.focusNode, t.focusOffset) == e.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: t } = this, e = t.state.selection.main, i = Ca(t.root), { anchorNode: s, anchorOffset: a } = t.observer.selectionRange;
    if (!i || !e.empty || !e.assoc || !i.modify)
      return;
    let o = re.find(this, e.head);
    if (!o)
      return;
    let u = o.posAtStart;
    if (e.head == u || e.head == u + o.length)
      return;
    let h = this.coordsAt(e.head, -1), d = this.coordsAt(e.head, 1);
    if (!h || !d || h.bottom > d.top)
      return;
    let p = this.domAtPos(e.head + e.assoc);
    i.collapse(p.node, p.offset), i.modify("move", e.assoc < 0 ? "forward" : "backward", "lineboundary"), t.observer.readSelectionRange();
    let g = t.observer.selectionRange;
    t.docView.posFromDOM(g.anchorNode, g.anchorOffset) != e.from && i.collapse(s, a);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(t) {
    let e = this.dom, i;
    if (t.node != e)
      return t;
    for (let s = t.offset; !i && s < e.childNodes.length; s++) {
      let a = Ut.get(e.childNodes[s]);
      a instanceof re && (i = a.domAtPos(0));
    }
    for (let s = t.offset - 1; !i && s >= 0; s--) {
      let a = Ut.get(e.childNodes[s]);
      a instanceof re && (i = a.domAtPos(a.length));
    }
    return i ? new qe(i.node, i.offset, !0) : t;
  }
  nearest(t) {
    for (let e = t; e; ) {
      let i = Ut.get(e);
      if (i && i.rootView == this)
        return i;
      e = e.parentNode;
    }
    return null;
  }
  posFromDOM(t, e) {
    let i = this.nearest(t);
    if (!i)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return i.localPosFromDOM(t, e) + i.posAtStart;
  }
  domAtPos(t) {
    let { i: e, off: i } = this.childCursor().findPos(t, -1);
    for (; e < this.children.length - 1; ) {
      let s = this.children[e];
      if (i < s.length || s instanceof re)
        break;
      e++, i = 0;
    }
    return this.children[e].domAtPos(i);
  }
  coordsAt(t, e) {
    let i = null, s = 0;
    for (let a = this.length, o = this.children.length - 1; o >= 0; o--) {
      let u = this.children[o], h = a - u.breakAfter, d = h - u.length;
      if (h < t)
        break;
      if (d <= t && (d < t || u.covers(-1)) && (h > t || u.covers(1)) && (!i || u instanceof re && !(i instanceof re && e >= 0)))
        i = u, s = d;
      else if (i && d == t && h == t && u instanceof wn && Math.abs(e) < 2) {
        if (u.deco.startSide < 0)
          break;
        o && (i = null);
      }
      a = d;
    }
    return i ? i.coordsAt(t - s, e) : null;
  }
  coordsForChar(t) {
    let { i: e, off: i } = this.childPos(t, 1), s = this.children[e];
    if (!(s instanceof re))
      return null;
    for (; s.children.length; ) {
      let { i: u, off: h } = s.childPos(i, 1);
      for (; ; u++) {
        if (u == s.children.length)
          return null;
        if ((s = s.children[u]).length)
          break;
      }
      i = h;
    }
    if (!(s instanceof Pi))
      return null;
    let a = Te(s.text, i);
    if (a == i)
      return null;
    let o = Nl(s.dom, i, a).getClientRects();
    for (let u = 0; u < o.length; u++) {
      let h = o[u];
      if (u == o.length - 1 || h.top < h.bottom && h.left < h.right)
        return h;
    }
    return null;
  }
  measureVisibleLineHeights(t) {
    let e = [], { from: i, to: s } = t, a = this.view.contentDOM.clientWidth, o = a > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, u = -1, h = this.view.textDirection == Bt.LTR;
    for (let d = 0, p = 0; p < this.children.length; p++) {
      let g = this.children[p], y = d + g.length;
      if (y > s)
        break;
      if (d >= i) {
        let Q = g.dom.getBoundingClientRect();
        if (e.push(Q.height), o) {
          let b = g.dom.lastChild, x = b ? Fs(b) : [];
          if (x.length) {
            let P = x[x.length - 1], A = h ? P.right - Q.left : Q.right - P.left;
            A > u && (u = A, this.minWidth = a, this.minWidthFrom = d, this.minWidthTo = y);
          }
        }
      }
      d = y + g.breakAfter;
    }
    return e;
  }
  textDirectionAt(t) {
    let { i: e } = this.childPos(t, 1);
    return getComputedStyle(this.children[e].dom).direction == "rtl" ? Bt.RTL : Bt.LTR;
  }
  measureTextSize() {
    for (let a of this.children)
      if (a instanceof re) {
        let o = a.measureTextSize();
        if (o)
          return o;
      }
    let t = document.createElement("div"), e, i, s;
    return t.className = "cm-line", t.style.width = "99999px", t.style.position = "absolute", t.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(t);
      let a = Fs(t.firstChild)[0];
      e = t.getBoundingClientRect().height, i = a ? a.width / 27 : 7, s = a ? a.height : e, t.remove();
    }), { lineHeight: e, charWidth: i, textHeight: s };
  }
  childCursor(t = this.length) {
    let e = this.children.length;
    return e && (t -= this.children[--e].length), new qv(this.children, t, e);
  }
  computeBlockGapDeco() {
    let t = [], e = this.view.viewState;
    for (let i = 0, s = 0; ; s++) {
      let a = s == e.viewports.length ? null : e.viewports[s], o = a ? a.from - 1 : this.length;
      if (o > i) {
        let u = (e.lineBlockAt(o).bottom - e.lineBlockAt(i).top) / this.view.scaleY;
        t.push(ft.replace({
          widget: new Ad(u),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(i, o));
      }
      if (!a)
        break;
      i = a.to + 1;
    }
    return ft.set(t);
  }
  updateDeco() {
    let t = 1, e = this.view.state.facet(Za).map((a) => (this.dynamicDecorationMap[t++] = typeof a == "function") ? a(this.view) : a), i = !1, s = this.view.state.facet(nb).map((a, o) => {
      let u = typeof a == "function";
      return u && (i = !0), u ? a(this.view) : a;
    });
    for (s.length && (this.dynamicDecorationMap[t++] = i, e.push(Mt.join(s))), this.decorations = [
      this.editContextFormatting,
      ...e,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; t < this.decorations.length; )
      this.dynamicDecorationMap[t++] = !1;
    return this.decorations;
  }
  scrollIntoView(t) {
    if (t.isSnapshot) {
      let d = this.view.viewState.lineBlockAt(t.range.head);
      this.view.scrollDOM.scrollTop = d.top - t.yMargin, this.view.scrollDOM.scrollLeft = t.xMargin;
      return;
    }
    for (let d of this.view.state.facet(tb))
      try {
        if (d(this.view, t.range, t))
          return !0;
      } catch (p) {
        Be(this.view.state, p, "scroll handler");
      }
    let { range: e } = t, i = this.coordsAt(e.head, e.empty ? e.assoc : e.head > e.anchor ? -1 : 1), s;
    if (!i)
      return;
    !e.empty && (s = this.coordsAt(e.anchor, e.anchor > e.head ? -1 : 1)) && (i = {
      left: Math.min(i.left, s.left),
      top: Math.min(i.top, s.top),
      right: Math.max(i.right, s.right),
      bottom: Math.max(i.bottom, s.bottom)
    });
    let a = xp(this.view), o = {
      left: i.left - a.left,
      top: i.top - a.top,
      right: i.right + a.right,
      bottom: i.bottom + a.bottom
    }, { offsetWidth: u, offsetHeight: h } = this.view.scrollDOM;
    a2(this.view.scrollDOM, o, e.head < e.anchor ? -1 : 1, t.x, t.y, Math.max(Math.min(t.xMargin, u), -u), Math.max(Math.min(t.yMargin, h), -h), this.view.textDirection == Bt.LTR);
  }
}
function R2(n) {
  return n.node.nodeType == 1 && n.node.firstChild && (n.offset == 0 || n.node.childNodes[n.offset - 1].contentEditable == "false") && (n.offset == n.node.childNodes.length || n.node.childNodes[n.offset].contentEditable == "false");
}
function rb(n, t) {
  let e = n.observer.selectionRange;
  if (!e.focusNode)
    return null;
  let i = Av(e.focusNode, e.focusOffset), s = Mv(e.focusNode, e.focusOffset), a = i || s;
  if (s && i && s.node != i.node) {
    let u = Ut.get(s.node);
    if (!u || u instanceof Pi && u.text != s.node.nodeValue)
      a = s;
    else if (n.docView.lastCompositionAfterCursor) {
      let h = Ut.get(i.node);
      !h || h instanceof Pi && h.text != i.node.nodeValue || (a = s);
    }
  }
  if (n.docView.lastCompositionAfterCursor = a != i, !a)
    return null;
  let o = t - a.offset;
  return { from: o, to: o + a.node.nodeValue.length, node: a.node };
}
function A2(n, t, e) {
  let i = rb(n, e);
  if (!i)
    return null;
  let { node: s, from: a, to: o } = i, u = s.nodeValue;
  if (/[\n\r]/.test(u) || n.state.doc.sliceString(i.from, i.to) != u)
    return null;
  let h = t.invertedDesc, d = new vi(h.mapPos(a), h.mapPos(o), a, o), p = [];
  for (let g = s.parentNode; ; g = g.parentNode) {
    let y = Ut.get(g);
    if (y instanceof $n)
      p.push({ node: g, deco: y.mark });
    else {
      if (y instanceof re || g.nodeName == "DIV" && g.parentNode == n.contentDOM)
        return { range: d, text: s, marks: p, line: g };
      if (g != n.contentDOM)
        p.push({ node: g, deco: new Ka({
          inclusive: !0,
          attributes: g2(g),
          tagName: g.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function M2(n, t) {
  return n.nodeType != 1 ? 0 : (t && n.childNodes[t - 1].contentEditable == "false" ? 1 : 0) | (t < n.childNodes.length && n.childNodes[t].contentEditable == "false" ? 2 : 0);
}
let q2 = class {
  constructor() {
    this.changes = [];
  }
  compareRange(t, e) {
    Jc(t, e, this.changes);
  }
  comparePoint(t, e) {
    Jc(t, e, this.changes);
  }
  boundChange(t) {
    Jc(t, t, this.changes);
  }
};
function C2(n, t, e) {
  let i = new q2();
  return Mt.compare(n, t, e, i), i.changes;
}
function Z2(n, t) {
  for (let e = n; e && e != t; e = e.assignedSlot || e.parentNode)
    if (e.nodeType == 1 && e.contentEditable == "false")
      return !0;
  return !1;
}
function E2(n, t) {
  let e = !1;
  return t && n.iterChangedRanges((i, s) => {
    i < t.to && s > t.from && (e = !0);
  }), e;
}
function X2(n, t, e = 1) {
  let i = n.charCategorizer(t), s = n.doc.lineAt(t), a = t - s.from;
  if (s.length == 0)
    return j.cursor(t);
  a == 0 ? e = 1 : a == s.length && (e = -1);
  let o = a, u = a;
  e < 0 ? o = Te(s.text, a, !1) : u = Te(s.text, a);
  let h = i(s.text.slice(o, u));
  for (; o > 0; ) {
    let d = Te(s.text, o, !1);
    if (i(s.text.slice(d, o)) != h)
      break;
    o = d;
  }
  for (; u < s.length; ) {
    let d = Te(s.text, u);
    if (i(s.text.slice(u, d)) != h)
      break;
    u = d;
  }
  return j.range(o + s.from, u + s.from);
}
function _2(n, t) {
  return t.left > n ? t.left - n : Math.max(0, n - t.right);
}
function z2(n, t) {
  return t.top > n ? t.top - n : Math.max(0, n - t.bottom);
}
function $O(n, t) {
  return n.top < t.bottom - 1 && n.bottom > t.top + 1;
}
function qS(n, t) {
  return t < n.top ? { top: t, left: n.left, right: n.right, bottom: n.bottom } : n;
}
function CS(n, t) {
  return t > n.bottom ? { top: n.top, left: n.left, right: n.right, bottom: t } : n;
}
function Ed(n, t, e) {
  let i, s, a, o, u = !1, h, d, p, g;
  for (let b = n.firstChild; b; b = b.nextSibling) {
    let x = Fs(b);
    for (let P = 0; P < x.length; P++) {
      let A = x[P];
      s && $O(s, A) && (A = qS(CS(A, s.bottom), s.top));
      let V = _2(t, A), G = z2(e, A);
      if (V == 0 && G == 0)
        return b.nodeType == 3 ? ZS(b, t, e) : Ed(b, t, e);
      if (!i || o > G || o == G && a > V) {
        i = b, s = A, a = V, o = G;
        let H = G ? e < A.top ? -1 : 1 : V ? t < A.left ? -1 : 1 : 0;
        u = !H || (H > 0 ? P < x.length - 1 : P > 0);
      }
      V == 0 ? e > A.bottom && (!p || p.bottom < A.bottom) ? (h = b, p = A) : e < A.top && (!g || g.top > A.top) && (d = b, g = A) : p && $O(p, A) ? p = CS(p, A.bottom) : g && $O(g, A) && (g = qS(g, A.top));
    }
  }
  if (p && p.bottom >= e ? (i = h, s = p) : g && g.top <= e && (i = d, s = g), !i)
    return { node: n, offset: 0 };
  let y = Math.max(s.left, Math.min(s.right, t));
  if (i.nodeType == 3)
    return ZS(i, y, e);
  if (u && i.contentEditable != "false")
    return Ed(i, y, e);
  let Q = Array.prototype.indexOf.call(n.childNodes, i) + (t >= (s.left + s.right) / 2 ? 1 : 0);
  return { node: n, offset: Q };
}
function ZS(n, t, e) {
  let i = n.nodeValue.length, s = -1, a = 1e9, o = 0;
  for (let u = 0; u < i; u++) {
    let h = Nl(n, u, u + 1).getClientRects();
    for (let d = 0; d < h.length; d++) {
      let p = h[d];
      if (p.top == p.bottom)
        continue;
      o || (o = t - p.left);
      let g = (p.top > e ? p.top - e : e - p.bottom) - 1;
      if (p.left - 1 <= t && p.right + 1 >= t && g < a) {
        let y = t >= (p.left + p.right) / 2, Q = y;
        if ((st.chrome || st.gecko) && Nl(n, u).getBoundingClientRect().left == p.right && (Q = !y), g <= 0)
          return { node: n, offset: u + (Q ? 1 : 0) };
        s = u + (Q ? 1 : 0), a = g;
      }
    }
  }
  return { node: n, offset: s > -1 ? s : o > 0 ? n.nodeValue.length : 0 };
}
function ab(n, t, e, i = -1) {
  var s, a;
  let o = n.contentDOM.getBoundingClientRect(), u = o.top + n.viewState.paddingTop, h, { docHeight: d } = n.viewState, { x: p, y: g } = t, y = g - u;
  if (y < 0)
    return 0;
  if (y > d)
    return n.state.doc.length;
  for (let H = n.viewState.heightOracle.textHeight / 2, _ = !1; h = n.elementAtHeight(y), h.type != Ee.Text; )
    for (; y = i > 0 ? h.bottom + H : h.top - H, !(y >= 0 && y <= d); ) {
      if (_)
        return e ? null : 0;
      _ = !0, i = -i;
    }
  g = u + y;
  let Q = h.from;
  if (Q < n.viewport.from)
    return n.viewport.from == 0 ? 0 : e ? null : ES(n, o, h, p, g);
  if (Q > n.viewport.to)
    return n.viewport.to == n.state.doc.length ? n.state.doc.length : e ? null : ES(n, o, h, p, g);
  let b = n.dom.ownerDocument, x = n.root.elementFromPoint ? n.root : b, P = x.elementFromPoint(p, g);
  P && !n.contentDOM.contains(P) && (P = null), P || (p = Math.max(o.left + 1, Math.min(o.right - 1, p)), P = x.elementFromPoint(p, g), P && !n.contentDOM.contains(P) && (P = null));
  let A, V = -1;
  if (P && ((s = n.docView.nearest(P)) === null || s === void 0 ? void 0 : s.isEditable) != !1) {
    if (b.caretPositionFromPoint) {
      let H = b.caretPositionFromPoint(p, g);
      H && ({ offsetNode: A, offset: V } = H);
    } else if (b.caretRangeFromPoint) {
      let H = b.caretRangeFromPoint(p, g);
      H && ({ startContainer: A, startOffset: V } = H, (!n.contentDOM.contains(A) || st.safari && D2(A, V, p) || st.chrome && V2(A, V, p)) && (A = void 0));
    }
    A && (V = Math.min(Ki(A), V));
  }
  if (!A || !n.docView.dom.contains(A)) {
    let H = re.find(n.docView, Q);
    if (!H)
      return y > h.top + h.height / 2 ? h.to : h.from;
    ({ node: A, offset: V } = Ed(H.dom, p, g));
  }
  let G = n.docView.nearest(A);
  if (!G)
    return null;
  if (G.isWidget && ((a = G.dom) === null || a === void 0 ? void 0 : a.nodeType) == 1) {
    let H = G.dom.getBoundingClientRect();
    return t.y < H.top || t.y <= H.bottom && t.x <= (H.left + H.right) / 2 ? G.posAtStart : G.posAtEnd;
  } else
    return G.localPosFromDOM(A, V) + G.posAtStart;
}
function ES(n, t, e, i, s) {
  let a = Math.round((i - t.left) * n.defaultCharacterWidth);
  if (n.lineWrapping && e.height > n.defaultLineHeight * 1.5) {
    let u = n.viewState.heightOracle.textHeight, h = Math.floor((s - e.top - (n.defaultLineHeight - u) * 0.5) / u);
    a += h * n.viewState.heightOracle.lineLength;
  }
  let o = n.state.sliceDoc(e.from, e.to);
  return e.from + vd(o, a, n.state.tabSize);
}
function D2(n, t, e) {
  let i;
  if (n.nodeType != 3 || t != (i = n.nodeValue.length))
    return !1;
  for (let s = n.nextSibling; s; s = s.nextSibling)
    if (s.nodeType != 1 || s.nodeName != "BR")
      return !1;
  return Nl(n, i - 1, i).getBoundingClientRect().left > e;
}
function V2(n, t, e) {
  if (t != 0)
    return !1;
  for (let s = n; ; ) {
    let a = s.parentNode;
    if (!a || a.nodeType != 1 || a.firstChild != s)
      return !1;
    if (a.classList.contains("cm-line"))
      break;
    s = a;
  }
  let i = n.nodeType == 1 ? n.getBoundingClientRect() : Nl(n, 0, Math.max(n.nodeValue.length, 1)).getBoundingClientRect();
  return e - i.left > 5;
}
function Xd(n, t, e) {
  let i = n.lineBlockAt(t);
  if (Array.isArray(i.type)) {
    let s;
    for (let a of i.type) {
      if (a.from > t)
        break;
      if (!(a.to < t)) {
        if (a.from < t && a.to > t)
          return a;
        (!s || a.type == Ee.Text && (s.type != a.type || (e < 0 ? a.from < t : a.to > t))) && (s = a);
      }
    }
    return s || i;
  }
  return i;
}
function Y2(n, t, e, i) {
  let s = Xd(n, t.head, t.assoc || -1), a = !i || s.type != Ee.Text || !(n.lineWrapping || s.widgetLineBreaks) ? null : n.coordsAtPos(t.assoc < 0 && t.head > s.from ? t.head - 1 : t.head);
  if (a) {
    let o = n.dom.getBoundingClientRect(), u = n.textDirectionAt(s.from), h = n.posAtCoords({
      x: e == (u == Bt.LTR) ? o.right - 1 : o.left + 1,
      y: (a.top + a.bottom) / 2
    });
    if (h != null)
      return j.cursor(h, e ? -1 : 1);
  }
  return j.cursor(e ? s.to : s.from, e ? -1 : 1);
}
function XS(n, t, e, i) {
  let s = n.state.doc.lineAt(t.head), a = n.bidiSpans(s), o = n.textDirectionAt(s.from);
  for (let u = t, h = null; ; ) {
    let d = T2(s, a, o, u, e), p = Bv;
    if (!d) {
      if (s.number == (e ? n.state.doc.lines : 1))
        return u;
      p = `
`, s = n.state.doc.line(s.number + (e ? 1 : -1)), a = n.bidiSpans(s), d = n.visualLineSide(s, !e);
    }
    if (h) {
      if (!h(p))
        return u;
    } else {
      if (!i)
        return d;
      h = i(p);
    }
    u = d;
  }
}
function U2(n, t, e) {
  let i = n.state.charCategorizer(t), s = i(e);
  return (a) => {
    let o = i(a);
    return s == Wt.Space && (s = o), s == o;
  };
}
function j2(n, t, e, i) {
  let s = t.head, a = e ? 1 : -1;
  if (s == (e ? n.state.doc.length : 0))
    return j.cursor(s, t.assoc);
  let o = t.goalColumn, u, h = n.contentDOM.getBoundingClientRect(), d = n.coordsAtPos(s, t.assoc || -1), p = n.documentTop;
  if (d)
    o == null && (o = d.left - h.left), u = a < 0 ? d.top : d.bottom;
  else {
    let Q = n.viewState.lineBlockAt(s);
    o == null && (o = Math.min(h.right - h.left, n.defaultCharacterWidth * (s - Q.from))), u = (a < 0 ? Q.top : Q.bottom) + p;
  }
  let g = h.left + o, y = i ?? n.viewState.heightOracle.textHeight >> 1;
  for (let Q = 0; ; Q += 10) {
    let b = u + (y + Q) * a, x = ab(n, { x: g, y: b }, !1, a);
    if (b < h.top || b > h.bottom || (a < 0 ? x < s : x > s)) {
      let P = n.docView.coordsForChar(x), A = !P || b < P.top ? -1 : 1;
      return j.cursor(x, A, void 0, o);
    }
  }
}
function Ic(n, t, e) {
  for (; ; ) {
    let i = 0;
    for (let s of n)
      s.between(t - 1, t + 1, (a, o, u) => {
        if (t > a && t < o) {
          let h = i || e || (t - a < o - t ? -1 : 1);
          t = h < 0 ? a : o, i = h;
        }
      });
    if (!i)
      return t;
  }
}
function PO(n, t, e) {
  let i = Ic(n.state.facet(bp).map((s) => s(n)), e.from, t.head > e.from ? -1 : 1);
  return i == e.from ? e : j.cursor(i, i < e.from ? 1 : -1);
}
const Qa = "￿";
class L2 {
  constructor(t, e) {
    this.points = t, this.text = "", this.lineSeparator = e.facet($t.lineSeparator);
  }
  append(t) {
    this.text += t;
  }
  lineBreak() {
    this.text += Qa;
  }
  readRange(t, e) {
    if (!t)
      return this;
    let i = t.parentNode;
    for (let s = t; ; ) {
      this.findPointBefore(i, s);
      let a = this.text.length;
      this.readNode(s);
      let o = s.nextSibling;
      if (o == e)
        break;
      let u = Ut.get(s), h = Ut.get(o);
      (u && h ? u.breakAfter : (u ? u.breakAfter : du(s)) || du(o) && (s.nodeName != "BR" || s.cmIgnore) && this.text.length > a) && this.lineBreak(), s = o;
    }
    return this.findPointBefore(i, e), this;
  }
  readTextNode(t) {
    let e = t.nodeValue;
    for (let i of this.points)
      i.node == t && (i.pos = this.text.length + Math.min(i.offset, e.length));
    for (let i = 0, s = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let a = -1, o = 1, u;
      if (this.lineSeparator ? (a = e.indexOf(this.lineSeparator, i), o = this.lineSeparator.length) : (u = s.exec(e)) && (a = u.index, o = u[0].length), this.append(e.slice(i, a < 0 ? e.length : a)), a < 0)
        break;
      if (this.lineBreak(), o > 1)
        for (let h of this.points)
          h.node == t && h.pos > this.text.length && (h.pos -= o - 1);
      i = a + o;
    }
  }
  readNode(t) {
    if (t.cmIgnore)
      return;
    let e = Ut.get(t), i = e && e.overrideDOMText;
    if (i != null) {
      this.findPointInside(t, i.length);
      for (let s = i.iter(); !s.next().done; )
        s.lineBreak ? this.lineBreak() : this.append(s.value);
    } else t.nodeType == 3 ? this.readTextNode(t) : t.nodeName == "BR" ? t.nextSibling && this.lineBreak() : t.nodeType == 1 && this.readRange(t.firstChild, null);
  }
  findPointBefore(t, e) {
    for (let i of this.points)
      i.node == t && t.childNodes[i.offset] == e && (i.pos = this.text.length);
  }
  findPointInside(t, e) {
    for (let i of this.points)
      (t.nodeType == 3 ? i.node == t : t.contains(i.node)) && (i.pos = this.text.length + (B2(t, i.node, i.offset) ? e : 0));
  }
}
function B2(n, t, e) {
  for (; ; ) {
    if (!t || e < Ki(t))
      return !1;
    if (t == n)
      return !0;
    e = Gl(t) + 1, t = t.parentNode;
  }
}
class _S {
  constructor(t, e) {
    this.node = t, this.offset = e, this.pos = -1;
  }
}
class G2 {
  constructor(t, e, i, s) {
    this.typeOver = s, this.bounds = null, this.text = "", this.domChanged = e > -1;
    let { impreciseHead: a, impreciseAnchor: o } = t.docView;
    if (t.state.readOnly && e > -1)
      this.newSel = null;
    else if (e > -1 && (this.bounds = t.docView.domBoundsAround(e, i, 0))) {
      let u = a || o ? [] : H2(t), h = new L2(u, t.state);
      h.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = h.text, this.newSel = K2(u, this.bounds.from);
    } else {
      let u = t.observer.selectionRange, h = a && a.node == u.focusNode && a.offset == u.focusOffset || !kd(t.contentDOM, u.focusNode) ? t.state.selection.main.head : t.docView.posFromDOM(u.focusNode, u.focusOffset), d = o && o.node == u.anchorNode && o.offset == u.anchorOffset || !kd(t.contentDOM, u.anchorNode) ? t.state.selection.main.anchor : t.docView.posFromDOM(u.anchorNode, u.anchorOffset), p = t.viewport;
      if ((st.ios || st.chrome) && t.state.selection.main.empty && h != d && (p.from > 0 || p.to < t.state.doc.length)) {
        let g = Math.min(h, d), y = Math.max(h, d), Q = p.from - g, b = p.to - y;
        (Q == 0 || Q == 1 || g == 0) && (b == 0 || b == -1 || y == t.state.doc.length) && (h = 0, d = t.state.doc.length);
      }
      this.newSel = j.single(d, h);
    }
  }
}
function ob(n, t) {
  let e, { newSel: i } = t, s = n.state.selection.main, a = n.inputState.lastKeyTime > Date.now() - 100 ? n.inputState.lastKeyCode : -1;
  if (t.bounds) {
    let { from: o, to: u } = t.bounds, h = s.from, d = null;
    (a === 8 || st.android && t.text.length < u - o) && (h = s.to, d = "end");
    let p = W2(n.state.doc.sliceString(o, u, Qa), t.text, h - o, d);
    p && (st.chrome && a == 13 && p.toB == p.from + 2 && t.text.slice(p.from, p.toB) == Qa + Qa && p.toB--, e = {
      from: o + p.from,
      to: o + p.toA,
      insert: Rt.of(t.text.slice(p.from, p.toB).split(Qa))
    });
  } else i && (!n.hasFocus && n.state.facet(xn) || i.main.eq(s)) && (i = null);
  if (!e && !i)
    return !1;
  if (!e && t.typeOver && !s.empty && i && i.main.empty ? e = { from: s.from, to: s.to, insert: n.state.doc.slice(s.from, s.to) } : (st.mac || st.android) && e && e.from == e.to && e.from == s.head - 1 && /^\. ?$/.test(e.insert.toString()) && n.contentDOM.getAttribute("autocorrect") == "off" ? (i && e.insert.length == 2 && (i = j.single(i.main.anchor - 1, i.main.head - 1)), e = { from: e.from, to: e.to, insert: Rt.of([e.insert.toString().replace(".", " ")]) }) : e && e.from >= s.from && e.to <= s.to && (e.from != s.from || e.to != s.to) && s.to - s.from - (e.to - e.from) <= 4 ? e = {
    from: s.from,
    to: s.to,
    insert: n.state.doc.slice(s.from, e.from).append(e.insert).append(n.state.doc.slice(e.to, s.to))
  } : st.chrome && e && e.from == e.to && e.from == s.head && e.insert.toString() == `
 ` && n.lineWrapping && (i && (i = j.single(i.main.anchor - 1, i.main.head - 1)), e = { from: s.from, to: s.to, insert: Rt.of([" "]) }), e)
    return kp(n, e, i, a);
  if (i && !i.main.eq(s)) {
    let o = !1, u = "select";
    return n.inputState.lastSelectionTime > Date.now() - 50 && (n.inputState.lastSelectionOrigin == "select" && (o = !0), u = n.inputState.lastSelectionOrigin), n.dispatch({ selection: i, scrollIntoView: o, userEvent: u }), !0;
  } else
    return !1;
}
function kp(n, t, e, i = -1) {
  if (st.ios && n.inputState.flushIOSKey(t))
    return !0;
  let s = n.state.selection.main;
  if (st.android && (t.to == s.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (t.from == s.from || t.from == s.from - 1 && n.state.sliceDoc(t.from, s.from) == " ") && t.insert.length == 1 && t.insert.lines == 2 && Ns(n.contentDOM, "Enter", 13) || (t.from == s.from - 1 && t.to == s.to && t.insert.length == 0 || i == 8 && t.insert.length < t.to - t.from && t.to > s.head) && Ns(n.contentDOM, "Backspace", 8) || t.from == s.from && t.to == s.to + 1 && t.insert.length == 0 && Ns(n.contentDOM, "Delete", 46)))
    return !0;
  let a = t.insert.toString();
  n.inputState.composing >= 0 && n.inputState.composing++;
  let o, u = () => o || (o = N2(n, t, e));
  return n.state.facet(Kv).some((h) => h(n, t.from, t.to, a, u)) || n.dispatch(u()), !0;
}
function N2(n, t, e) {
  let i, s = n.state, a = s.selection.main;
  if (t.from >= a.from && t.to <= a.to && t.to - t.from >= (a.to - a.from) / 3 && (!e || e.main.empty && e.main.from == t.from + t.insert.length) && n.inputState.composing < 0) {
    let u = a.from < t.from ? s.sliceDoc(a.from, t.from) : "", h = a.to > t.to ? s.sliceDoc(t.to, a.to) : "";
    i = s.replaceSelection(n.state.toText(u + t.insert.sliceString(0, void 0, n.state.lineBreak) + h));
  } else {
    let u = s.changes(t), h = e && e.main.to <= u.newLength ? e.main : void 0;
    if (s.selection.ranges.length > 1 && n.inputState.composing >= 0 && t.to <= a.to && t.to >= a.to - 10) {
      let d = n.state.sliceDoc(t.from, t.to), p, g = e && rb(n, e.main.head);
      if (g) {
        let b = t.insert.length - (t.to - t.from);
        p = { from: g.from, to: g.to - b };
      } else
        p = n.state.doc.lineAt(a.head);
      let y = a.to - t.to, Q = a.to - a.from;
      i = s.changeByRange((b) => {
        if (b.from == a.from && b.to == a.to)
          return { changes: u, range: h || b.map(u) };
        let x = b.to - y, P = x - d.length;
        if (b.to - b.from != Q || n.state.sliceDoc(P, x) != d || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        b.to >= p.from && b.from <= p.to)
          return { range: b };
        let A = s.changes({ from: P, to: x, insert: t.insert }), V = b.to - a.to;
        return {
          changes: A,
          range: h ? j.range(Math.max(0, h.anchor + V), Math.max(0, h.head + V)) : b.map(A)
        };
      });
    } else
      i = {
        changes: u,
        selection: h && s.selection.replaceRange(h)
      };
  }
  let o = "input.type";
  return (n.composing || n.inputState.compositionPendingChange && n.inputState.compositionEndedAt > Date.now() - 50) && (n.inputState.compositionPendingChange = !1, o += ".compose", n.inputState.compositionFirstChange && (o += ".start", n.inputState.compositionFirstChange = !1)), s.update(i, { userEvent: o, scrollIntoView: !0 });
}
function W2(n, t, e, i) {
  let s = Math.min(n.length, t.length), a = 0;
  for (; a < s && n.charCodeAt(a) == t.charCodeAt(a); )
    a++;
  if (a == s && n.length == t.length)
    return null;
  let o = n.length, u = t.length;
  for (; o > 0 && u > 0 && n.charCodeAt(o - 1) == t.charCodeAt(u - 1); )
    o--, u--;
  if (i == "end") {
    let h = Math.max(0, a - Math.min(o, u));
    e -= o + h - a;
  }
  if (o < a && n.length < t.length) {
    let h = e <= a && e >= o ? a - e : 0;
    a -= h, u = a + (u - o), o = a;
  } else if (u < a) {
    let h = e <= a && e >= u ? a - e : 0;
    a -= h, o = a + (o - u), u = a;
  }
  return { from: a, toA: o, toB: u };
}
function H2(n) {
  let t = [];
  if (n.root.activeElement != n.contentDOM)
    return t;
  let { anchorNode: e, anchorOffset: i, focusNode: s, focusOffset: a } = n.observer.selectionRange;
  return e && (t.push(new _S(e, i)), (s != e || a != i) && t.push(new _S(s, a))), t;
}
function K2(n, t) {
  if (n.length == 0)
    return null;
  let e = n[0].pos, i = n.length == 2 ? n[1].pos : e;
  return e > -1 && i > -1 ? j.single(e + t, i + t) : null;
}
class J2 {
  setSelectionOrigin(t) {
    this.lastSelectionOrigin = t, this.lastSelectionTime = Date.now();
  }
  constructor(t) {
    this.view = t, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = t.hasFocus, st.safari && t.contentDOM.addEventListener("input", () => null), st.gecko && OP(t.contentDOM.ownerDocument);
  }
  handleEvent(t) {
    !sP(this.view, t) || this.ignoreDuringComposition(t) || t.type == "keydown" && this.keydown(t) || (this.view.updateState != 0 ? Promise.resolve().then(() => this.runHandlers(t.type, t)) : this.runHandlers(t.type, t));
  }
  runHandlers(t, e) {
    let i = this.handlers[t];
    if (i) {
      for (let s of i.observers)
        s(this.view, e);
      for (let s of i.handlers) {
        if (e.defaultPrevented)
          break;
        if (s(this.view, e)) {
          e.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(t) {
    let e = I2(t), i = this.handlers, s = this.view.contentDOM;
    for (let a in e)
      if (a != "scroll") {
        let o = !e[a].handlers.length, u = i[a];
        u && o != !u.handlers.length && (s.removeEventListener(a, this.handleEvent), u = null), u || s.addEventListener(a, this.handleEvent, { passive: o });
      }
    for (let a in i)
      a != "scroll" && !e[a] && s.removeEventListener(a, this.handleEvent);
    this.handlers = e;
  }
  keydown(t) {
    if (this.lastKeyCode = t.keyCode, this.lastKeyTime = Date.now(), t.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return !0;
    if (this.tabFocusMode > 0 && t.keyCode != 27 && ub.indexOf(t.keyCode) < 0 && (this.tabFocusMode = -1), st.android && st.chrome && !t.synthetic && (t.keyCode == 13 || t.keyCode == 8))
      return this.view.observer.delayAndroidKey(t.key, t.keyCode), !0;
    let e;
    return st.ios && !t.synthetic && !t.altKey && !t.metaKey && ((e = cb.find((i) => i.keyCode == t.keyCode)) && !t.ctrlKey || F2.indexOf(t.key) > -1 && t.ctrlKey && !t.shiftKey) ? (this.pendingIOSKey = e || t, setTimeout(() => this.flushIOSKey(), 250), !0) : (t.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(t) {
    let e = this.pendingIOSKey;
    return !e || e.key == "Enter" && t && t.from < t.to && /^\S+$/.test(t.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, Ns(this.view.contentDOM, e.key, e.keyCode, e instanceof KeyboardEvent ? e : void 0));
  }
  ignoreDuringComposition(t) {
    return /^key/.test(t.type) ? this.composing > 0 ? !0 : st.safari && !st.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(t) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = t;
  }
  update(t) {
    this.view.observer.update(t), this.mouseSelection && this.mouseSelection.update(t), this.draggedContent && t.docChanged && (this.draggedContent = this.draggedContent.map(t.changes)), t.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function zS(n, t) {
  return (e, i) => {
    try {
      return t.call(n, i, e);
    } catch (s) {
      Be(e.state, s);
    }
  };
}
function I2(n) {
  let t = /* @__PURE__ */ Object.create(null);
  function e(i) {
    return t[i] || (t[i] = { observers: [], handlers: [] });
  }
  for (let i of n) {
    let s = i.spec;
    if (s && s.domEventHandlers)
      for (let a in s.domEventHandlers) {
        let o = s.domEventHandlers[a];
        o && e(a).handlers.push(zS(i.value, o));
      }
    if (s && s.domEventObservers)
      for (let a in s.domEventObservers) {
        let o = s.domEventObservers[a];
        o && e(a).observers.push(zS(i.value, o));
      }
  }
  for (let i in Ri)
    e(i).handlers.push(Ri[i]);
  for (let i in bi)
    e(i).observers.push(bi[i]);
  return t;
}
const cb = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], F2 = "dthko", ub = [16, 17, 18, 20, 91, 92, 224, 225], Pc = 6;
function Rc(n) {
  return Math.max(0, n) * 0.7 + 8;
}
function tP(n, t) {
  return Math.max(Math.abs(n.clientX - t.clientX), Math.abs(n.clientY - t.clientY));
}
class eP {
  constructor(t, e, i, s) {
    this.view = t, this.startEvent = e, this.style = i, this.mustSelect = s, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = e, this.scrollParents = o2(t.contentDOM), this.atoms = t.state.facet(bp).map((o) => o(t));
    let a = t.contentDOM.ownerDocument;
    a.addEventListener("mousemove", this.move = this.move.bind(this)), a.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = e.shiftKey, this.multiple = t.state.facet($t.allowMultipleSelections) && iP(t, e), this.dragging = lP(t, e) && Ob(e) == 1 ? null : !1;
  }
  start(t) {
    this.dragging === !1 && this.select(t);
  }
  move(t) {
    if (t.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && tP(this.startEvent, t) < 10)
      return;
    this.select(this.lastEvent = t);
    let e = 0, i = 0, s = 0, a = 0, o = this.view.win.innerWidth, u = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: s, right: o } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: a, bottom: u } = this.scrollParents.y.getBoundingClientRect());
    let h = xp(this.view);
    t.clientX - h.left <= s + Pc ? e = -Rc(s - t.clientX) : t.clientX + h.right >= o - Pc && (e = Rc(t.clientX - o)), t.clientY - h.top <= a + Pc ? i = -Rc(a - t.clientY) : t.clientY + h.bottom >= u - Pc && (i = Rc(t.clientY - u)), this.setScrollSpeed(e, i);
  }
  up(t) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || t.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let t = this.view.contentDOM.ownerDocument;
    t.removeEventListener("mousemove", this.move), t.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(t, e) {
    this.scrollSpeed = { x: t, y: e }, t || e ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: t, y: e } = this.scrollSpeed;
    t && this.scrollParents.x && (this.scrollParents.x.scrollLeft += t, t = 0), e && this.scrollParents.y && (this.scrollParents.y.scrollTop += e, e = 0), (t || e) && this.view.win.scrollBy(t, e), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(t) {
    let e = null;
    for (let i = 0; i < t.ranges.length; i++) {
      let s = t.ranges[i], a = null;
      if (s.empty) {
        let o = Ic(this.atoms, s.from, 0);
        o != s.from && (a = j.cursor(o, -1));
      } else {
        let o = Ic(this.atoms, s.from, -1), u = Ic(this.atoms, s.to, 1);
        (o != s.from || u != s.to) && (a = j.range(s.from == s.anchor ? o : u, s.from == s.head ? o : u));
      }
      a && (e || (e = t.ranges.slice()), e[i] = a);
    }
    return e ? j.create(e, t.mainIndex) : t;
  }
  select(t) {
    let { view: e } = this, i = this.skipAtoms(this.style.get(t, this.extend, this.multiple));
    (this.mustSelect || !i.eq(e.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: i,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(t) {
    t.transactions.some((e) => e.isUserEvent("input.type")) ? this.destroy() : this.style.update(t) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function iP(n, t) {
  let e = n.state.facet(Gv);
  return e.length ? e[0](t) : st.mac ? t.metaKey : t.ctrlKey;
}
function nP(n, t) {
  let e = n.state.facet(Nv);
  return e.length ? e[0](t) : st.mac ? !t.altKey : !t.ctrlKey;
}
function lP(n, t) {
  let { main: e } = n.state.selection;
  if (e.empty)
    return !1;
  let i = Ca(n.root);
  if (!i || i.rangeCount == 0)
    return !0;
  let s = i.getRangeAt(0).getClientRects();
  for (let a = 0; a < s.length; a++) {
    let o = s[a];
    if (o.left <= t.clientX && o.right >= t.clientX && o.top <= t.clientY && o.bottom >= t.clientY)
      return !0;
  }
  return !1;
}
function sP(n, t) {
  if (!t.bubbles)
    return !0;
  if (t.defaultPrevented)
    return !1;
  for (let e = t.target, i; e != n.contentDOM; e = e.parentNode)
    if (!e || e.nodeType == 11 || (i = Ut.get(e)) && i.ignoreEvent(t))
      return !1;
  return !0;
}
const Ri = /* @__PURE__ */ Object.create(null), bi = /* @__PURE__ */ Object.create(null), fb = st.ie && st.ie_version < 15 || st.ios && st.webkit_version < 604;
function rP(n) {
  let t = n.dom.parentNode;
  if (!t)
    return;
  let e = t.appendChild(document.createElement("textarea"));
  e.style.cssText = "position: fixed; left: -10000px; top: 10px", e.focus(), setTimeout(() => {
    n.focus(), e.remove(), hb(n, e.value);
  }, 50);
}
function Vu(n, t, e) {
  for (let i of n.facet(t))
    e = i(e, n);
  return e;
}
function hb(n, t) {
  t = Vu(n.state, Sp, t);
  let { state: e } = n, i, s = 1, a = e.toText(t), o = a.lines == e.selection.ranges.length;
  if (_d != null && e.selection.ranges.every((h) => h.empty) && _d == a.toString()) {
    let h = -1;
    i = e.changeByRange((d) => {
      let p = e.doc.lineAt(d.from);
      if (p.from == h)
        return { range: d };
      h = p.from;
      let g = e.toText((o ? a.line(s++).text : t) + e.lineBreak);
      return {
        changes: { from: p.from, insert: g },
        range: j.cursor(d.from + g.length)
      };
    });
  } else o ? i = e.changeByRange((h) => {
    let d = a.line(s++);
    return {
      changes: { from: h.from, to: h.to, insert: d.text },
      range: j.cursor(h.from + d.length)
    };
  }) : i = e.replaceSelection(a);
  n.dispatch(i, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
bi.scroll = (n) => {
  n.inputState.lastScrollTop = n.scrollDOM.scrollTop, n.inputState.lastScrollLeft = n.scrollDOM.scrollLeft;
};
Ri.keydown = (n, t) => (n.inputState.setSelectionOrigin("select"), t.keyCode == 27 && n.inputState.tabFocusMode != 0 && (n.inputState.tabFocusMode = Date.now() + 2e3), !1);
bi.touchstart = (n, t) => {
  n.inputState.lastTouchTime = Date.now(), n.inputState.setSelectionOrigin("select.pointer");
};
bi.touchmove = (n) => {
  n.inputState.setSelectionOrigin("select.pointer");
};
Ri.mousedown = (n, t) => {
  if (n.observer.flush(), n.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let e = null;
  for (let i of n.state.facet(Wv))
    if (e = i(n, t), e)
      break;
  if (!e && t.button == 0 && (e = cP(n, t)), e) {
    let i = !n.hasFocus;
    n.inputState.startMouseSelection(new eP(n, t, e, i)), i && n.observer.ignore(() => {
      $v(n.contentDOM);
      let a = n.root.activeElement;
      a && !a.contains(n.contentDOM) && a.blur();
    });
    let s = n.inputState.mouseSelection;
    if (s)
      return s.start(t), s.dragging === !1;
  }
  return !1;
};
function DS(n, t, e, i) {
  if (i == 1)
    return j.cursor(t, e);
  if (i == 2)
    return X2(n.state, t, e);
  {
    let s = re.find(n.docView, t), a = n.state.doc.lineAt(s ? s.posAtEnd : t), o = s ? s.posAtStart : a.from, u = s ? s.posAtEnd : a.to;
    return u < n.state.doc.length && u == a.to && u++, j.range(o, u);
  }
}
let VS = (n, t, e) => t >= e.top && t <= e.bottom && n >= e.left && n <= e.right;
function aP(n, t, e, i) {
  let s = re.find(n.docView, t);
  if (!s)
    return 1;
  let a = t - s.posAtStart;
  if (a == 0)
    return 1;
  if (a == s.length)
    return -1;
  let o = s.coordsAt(a, -1);
  if (o && VS(e, i, o))
    return -1;
  let u = s.coordsAt(a, 1);
  return u && VS(e, i, u) ? 1 : o && o.bottom >= i ? -1 : 1;
}
function YS(n, t) {
  let e = n.posAtCoords({ x: t.clientX, y: t.clientY }, !1);
  return { pos: e, bias: aP(n, e, t.clientX, t.clientY) };
}
const oP = st.ie && st.ie_version <= 11;
let US = null, jS = 0, LS = 0;
function Ob(n) {
  if (!oP)
    return n.detail;
  let t = US, e = LS;
  return US = n, LS = Date.now(), jS = !t || e > Date.now() - 400 && Math.abs(t.clientX - n.clientX) < 2 && Math.abs(t.clientY - n.clientY) < 2 ? (jS + 1) % 3 : 1;
}
function cP(n, t) {
  let e = YS(n, t), i = Ob(t), s = n.state.selection;
  return {
    update(a) {
      a.docChanged && (e.pos = a.changes.mapPos(e.pos), s = s.map(a.changes));
    },
    get(a, o, u) {
      let h = YS(n, a), d, p = DS(n, h.pos, h.bias, i);
      if (e.pos != h.pos && !o) {
        let g = DS(n, e.pos, e.bias, i), y = Math.min(g.from, p.from), Q = Math.max(g.to, p.to);
        p = y < p.from ? j.range(y, Q) : j.range(Q, y);
      }
      return o ? s.replaceRange(s.main.extend(p.from, p.to)) : u && i == 1 && s.ranges.length > 1 && (d = uP(s, h.pos)) ? d : u ? s.addRange(p) : j.create([p]);
    }
  };
}
function uP(n, t) {
  for (let e = 0; e < n.ranges.length; e++) {
    let { from: i, to: s } = n.ranges[e];
    if (i <= t && s >= t)
      return j.create(n.ranges.slice(0, e).concat(n.ranges.slice(e + 1)), n.mainIndex == e ? 0 : n.mainIndex - (n.mainIndex > e ? 1 : 0));
  }
  return null;
}
Ri.dragstart = (n, t) => {
  let { selection: { main: e } } = n.state;
  if (t.target.draggable) {
    let s = n.docView.nearest(t.target);
    if (s && s.isWidget) {
      let a = s.posAtStart, o = a + s.length;
      (a >= e.to || o <= e.from) && (e = j.range(a, o));
    }
  }
  let { inputState: i } = n;
  return i.mouseSelection && (i.mouseSelection.dragging = !0), i.draggedContent = e, t.dataTransfer && (t.dataTransfer.setData("Text", Vu(n.state, Qp, n.state.sliceDoc(e.from, e.to))), t.dataTransfer.effectAllowed = "copyMove"), !1;
};
Ri.dragend = (n) => (n.inputState.draggedContent = null, !1);
function BS(n, t, e, i) {
  if (e = Vu(n.state, Sp, e), !e)
    return;
  let s = n.posAtCoords({ x: t.clientX, y: t.clientY }, !1), { draggedContent: a } = n.inputState, o = i && a && nP(n, t) ? { from: a.from, to: a.to } : null, u = { from: s, insert: e }, h = n.state.changes(o ? [o, u] : u);
  n.focus(), n.dispatch({
    changes: h,
    selection: { anchor: h.mapPos(s, -1), head: h.mapPos(s, 1) },
    userEvent: o ? "move.drop" : "input.drop"
  }), n.inputState.draggedContent = null;
}
Ri.drop = (n, t) => {
  if (!t.dataTransfer)
    return !1;
  if (n.state.readOnly)
    return !0;
  let e = t.dataTransfer.files;
  if (e && e.length) {
    let i = Array(e.length), s = 0, a = () => {
      ++s == e.length && BS(n, t, i.filter((o) => o != null).join(n.state.lineBreak), !1);
    };
    for (let o = 0; o < e.length; o++) {
      let u = new FileReader();
      u.onerror = a, u.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(u.result) || (i[o] = u.result), a();
      }, u.readAsText(e[o]);
    }
    return !0;
  } else {
    let i = t.dataTransfer.getData("Text");
    if (i)
      return BS(n, t, i, !0), !0;
  }
  return !1;
};
Ri.paste = (n, t) => {
  if (n.state.readOnly)
    return !0;
  n.observer.flush();
  let e = fb ? null : t.clipboardData;
  return e ? (hb(n, e.getData("text/plain") || e.getData("text/uri-list")), !0) : (rP(n), !1);
};
function fP(n, t) {
  let e = n.dom.parentNode;
  if (!e)
    return;
  let i = e.appendChild(document.createElement("textarea"));
  i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.value = t, i.focus(), i.selectionEnd = t.length, i.selectionStart = 0, setTimeout(() => {
    i.remove(), n.focus();
  }, 50);
}
function hP(n) {
  let t = [], e = [], i = !1;
  for (let s of n.selection.ranges)
    s.empty || (t.push(n.sliceDoc(s.from, s.to)), e.push(s));
  if (!t.length) {
    let s = -1;
    for (let { from: a } of n.selection.ranges) {
      let o = n.doc.lineAt(a);
      o.number > s && (t.push(o.text), e.push({ from: o.from, to: Math.min(n.doc.length, o.to + 1) })), s = o.number;
    }
    i = !0;
  }
  return { text: Vu(n, Qp, t.join(n.lineBreak)), ranges: e, linewise: i };
}
let _d = null;
Ri.copy = Ri.cut = (n, t) => {
  let { text: e, ranges: i, linewise: s } = hP(n.state);
  if (!e && !s)
    return !1;
  _d = s ? e : null, t.type == "cut" && !n.state.readOnly && n.dispatch({
    changes: i,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let a = fb ? null : t.clipboardData;
  return a ? (a.clearData(), a.setData("text/plain", e), !0) : (fP(n, e), !1);
};
const db = /* @__PURE__ */ Ii.define();
function pb(n, t) {
  let e = [];
  for (let i of n.facet(Jv)) {
    let s = i(n, t);
    s && e.push(s);
  }
  return e.length ? n.update({ effects: e, annotations: db.of(!0) }) : null;
}
function mb(n) {
  setTimeout(() => {
    let t = n.hasFocus;
    if (t != n.inputState.notifiedFocused) {
      let e = pb(n.state, t);
      e ? n.dispatch(e) : n.update([]);
    }
  }, 10);
}
bi.focus = (n) => {
  n.inputState.lastFocusTime = Date.now(), !n.scrollDOM.scrollTop && (n.inputState.lastScrollTop || n.inputState.lastScrollLeft) && (n.scrollDOM.scrollTop = n.inputState.lastScrollTop, n.scrollDOM.scrollLeft = n.inputState.lastScrollLeft), mb(n);
};
bi.blur = (n) => {
  n.observer.clearSelectionRange(), mb(n);
};
bi.compositionstart = bi.compositionupdate = (n) => {
  n.observer.editContext || (n.inputState.compositionFirstChange == null && (n.inputState.compositionFirstChange = !0), n.inputState.composing < 0 && (n.inputState.composing = 0));
};
bi.compositionend = (n) => {
  n.observer.editContext || (n.inputState.composing = -1, n.inputState.compositionEndedAt = Date.now(), n.inputState.compositionPendingKey = !0, n.inputState.compositionPendingChange = n.observer.pendingRecords().length > 0, n.inputState.compositionFirstChange = null, st.chrome && st.android ? n.observer.flushSoon() : n.inputState.compositionPendingChange ? Promise.resolve().then(() => n.observer.flush()) : setTimeout(() => {
    n.inputState.composing < 0 && n.docView.hasComposition && n.update([]);
  }, 50));
};
bi.contextmenu = (n) => {
  n.inputState.lastContextMenu = Date.now();
};
Ri.beforeinput = (n, t) => {
  var e, i;
  if (t.inputType == "insertReplacementText" && n.observer.editContext) {
    let a = (e = t.dataTransfer) === null || e === void 0 ? void 0 : e.getData("text/plain"), o = t.getTargetRanges();
    if (a && o.length) {
      let u = o[0], h = n.posAtDOM(u.startContainer, u.startOffset), d = n.posAtDOM(u.endContainer, u.endOffset);
      return kp(n, { from: h, to: d, insert: n.state.toText(a) }, null), !0;
    }
  }
  let s;
  if (st.chrome && st.android && (s = cb.find((a) => a.inputType == t.inputType)) && (n.observer.delayAndroidKey(s.key, s.keyCode), s.key == "Backspace" || s.key == "Delete")) {
    let a = ((i = window.visualViewport) === null || i === void 0 ? void 0 : i.height) || 0;
    setTimeout(() => {
      var o;
      (((o = window.visualViewport) === null || o === void 0 ? void 0 : o.height) || 0) > a + 10 && n.hasFocus && (n.contentDOM.blur(), n.focus());
    }, 100);
  }
  return st.ios && t.inputType == "deleteContentForward" && n.observer.flushSoon(), st.safari && t.inputType == "insertText" && n.inputState.composing >= 0 && setTimeout(() => bi.compositionend(n, t), 20), !1;
};
const GS = /* @__PURE__ */ new Set();
function OP(n) {
  GS.has(n) || (GS.add(n), n.addEventListener("copy", () => {
  }), n.addEventListener("cut", () => {
  }));
}
const NS = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let ir = !1;
function WS() {
  ir = !1;
}
class dP {
  constructor(t) {
    this.lineWrapping = t, this.doc = Rt.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(t, e) {
    let i = this.doc.lineAt(e).number - this.doc.lineAt(t).number + 1;
    return this.lineWrapping && (i += Math.max(0, Math.ceil((e - t - i * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * i;
  }
  heightForLine(t) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((t - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(t) {
    return this.doc = t, this;
  }
  mustRefreshForWrapping(t) {
    return NS.indexOf(t) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(t) {
    let e = !1;
    for (let i = 0; i < t.length; i++) {
      let s = t[i];
      s < 0 ? i++ : this.heightSamples[Math.floor(s * 10)] || (e = !0, this.heightSamples[Math.floor(s * 10)] = !0);
    }
    return e;
  }
  refresh(t, e, i, s, a, o) {
    let u = NS.indexOf(t) > -1, h = Math.round(e) != Math.round(this.lineHeight) || this.lineWrapping != u;
    if (this.lineWrapping = u, this.lineHeight = e, this.charWidth = i, this.textHeight = s, this.lineLength = a, h) {
      this.heightSamples = {};
      for (let d = 0; d < o.length; d++) {
        let p = o[d];
        p < 0 ? d++ : this.heightSamples[Math.floor(p * 10)] = !0;
      }
    }
    return h;
  }
}
class pP {
  constructor(t, e) {
    this.from = t, this.heights = e, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class Bi {
  /**
  @internal
  */
  constructor(t, e, i, s, a) {
    this.from = t, this.length = e, this.top = i, this.height = s, this._content = a;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? Ee.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof fl ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(t) {
    let e = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(t._content) ? t._content : [t]);
    return new Bi(this.from, this.length + t.length, this.top, this.height + t.height, e);
  }
}
var Lt = /* @__PURE__ */ function(n) {
  return n[n.ByPos = 0] = "ByPos", n[n.ByHeight = 1] = "ByHeight", n[n.ByPosNoHeight = 2] = "ByPosNoHeight", n;
}(Lt || (Lt = {}));
const Fc = 1e-3;
class Xe {
  constructor(t, e, i = 2) {
    this.length = t, this.height = e, this.flags = i;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(t) {
    this.flags = (t ? 2 : 0) | this.flags & -3;
  }
  setHeight(t) {
    this.height != t && (Math.abs(this.height - t) > Fc && (ir = !0), this.height = t);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(t, e, i) {
    return Xe.of(i);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(t, e) {
    e.push(this);
  }
  decomposeRight(t, e) {
    e.push(this);
  }
  applyChanges(t, e, i, s) {
    let a = this, o = i.doc;
    for (let u = s.length - 1; u >= 0; u--) {
      let { fromA: h, toA: d, fromB: p, toB: g } = s[u], y = a.lineAt(h, Lt.ByPosNoHeight, i.setDoc(e), 0, 0), Q = y.to >= d ? y : a.lineAt(d, Lt.ByPosNoHeight, i, 0, 0);
      for (g += Q.to - d, d = Q.to; u > 0 && y.from <= s[u - 1].toA; )
        h = s[u - 1].fromA, p = s[u - 1].fromB, u--, h < y.from && (y = a.lineAt(h, Lt.ByPosNoHeight, i, 0, 0));
      p += y.from - h, h = y.from;
      let b = wp.build(i.setDoc(o), t, p, g);
      a = gu(a, a.replace(h, d, b));
    }
    return a.updateHeight(i, 0);
  }
  static empty() {
    return new ri(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(t) {
    if (t.length == 1)
      return t[0];
    let e = 0, i = t.length, s = 0, a = 0;
    for (; ; )
      if (e == i)
        if (s > a * 2) {
          let u = t[e - 1];
          u.break ? t.splice(--e, 1, u.left, null, u.right) : t.splice(--e, 1, u.left, u.right), i += 1 + u.break, s -= u.size;
        } else if (a > s * 2) {
          let u = t[i];
          u.break ? t.splice(i, 1, u.left, null, u.right) : t.splice(i, 1, u.left, u.right), i += 2 + u.break, a -= u.size;
        } else
          break;
      else if (s < a) {
        let u = t[e++];
        u && (s += u.size);
      } else {
        let u = t[--i];
        u && (a += u.size);
      }
    let o = 0;
    return t[e - 1] == null ? (o = 1, e--) : t[e] == null && (o = 1, i++), new mP(Xe.of(t.slice(0, e)), o, Xe.of(t.slice(i)));
  }
}
function gu(n, t) {
  return n == t ? n : (n.constructor != t.constructor && (ir = !0), t);
}
Xe.prototype.size = 1;
class gb extends Xe {
  constructor(t, e, i) {
    super(t, e), this.deco = i;
  }
  blockAt(t, e, i, s) {
    return new Bi(s, this.length, i, this.height, this.deco || 0);
  }
  lineAt(t, e, i, s, a) {
    return this.blockAt(0, i, s, a);
  }
  forEachLine(t, e, i, s, a, o) {
    t <= a + this.length && e >= a && o(this.blockAt(0, i, s, a));
  }
  updateHeight(t, e = 0, i = !1, s) {
    return s && s.from <= e && s.more && this.setHeight(s.heights[s.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class ri extends gb {
  constructor(t, e) {
    super(t, e, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(t, e, i, s) {
    return new Bi(s, this.length, i, this.height, this.breaks);
  }
  replace(t, e, i) {
    let s = i[0];
    return i.length == 1 && (s instanceof ri || s instanceof xe && s.flags & 4) && Math.abs(this.length - s.length) < 10 ? (s instanceof xe ? s = new ri(s.length, this.height) : s.height = this.height, this.outdated || (s.outdated = !1), s) : Xe.of(i);
  }
  updateHeight(t, e = 0, i = !1, s) {
    return s && s.from <= e && s.more ? this.setHeight(s.heights[s.index++]) : (i || this.outdated) && this.setHeight(Math.max(this.widgetHeight, t.heightForLine(this.length - this.collapsed)) + this.breaks * t.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class xe extends Xe {
  constructor(t) {
    super(t, 0);
  }
  heightMetrics(t, e) {
    let i = t.doc.lineAt(e).number, s = t.doc.lineAt(e + this.length).number, a = s - i + 1, o, u = 0;
    if (t.lineWrapping) {
      let h = Math.min(this.height, t.lineHeight * a);
      o = h / a, this.length > a + 1 && (u = (this.height - h) / (this.length - a - 1));
    } else
      o = this.height / a;
    return { firstLine: i, lastLine: s, perLine: o, perChar: u };
  }
  blockAt(t, e, i, s) {
    let { firstLine: a, lastLine: o, perLine: u, perChar: h } = this.heightMetrics(e, s);
    if (e.lineWrapping) {
      let d = s + (t < e.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (t - i) / this.height)) * this.length)), p = e.doc.lineAt(d), g = u + p.length * h, y = Math.max(i, t - g / 2);
      return new Bi(p.from, p.length, y, g, 0);
    } else {
      let d = Math.max(0, Math.min(o - a, Math.floor((t - i) / u))), { from: p, length: g } = e.doc.line(a + d);
      return new Bi(p, g, i + u * d, u, 0);
    }
  }
  lineAt(t, e, i, s, a) {
    if (e == Lt.ByHeight)
      return this.blockAt(t, i, s, a);
    if (e == Lt.ByPosNoHeight) {
      let { from: Q, to: b } = i.doc.lineAt(t);
      return new Bi(Q, b - Q, 0, 0, 0);
    }
    let { firstLine: o, perLine: u, perChar: h } = this.heightMetrics(i, a), d = i.doc.lineAt(t), p = u + d.length * h, g = d.number - o, y = s + u * g + h * (d.from - a - g);
    return new Bi(d.from, d.length, Math.max(s, Math.min(y, s + this.height - p)), p, 0);
  }
  forEachLine(t, e, i, s, a, o) {
    t = Math.max(t, a), e = Math.min(e, a + this.length);
    let { firstLine: u, perLine: h, perChar: d } = this.heightMetrics(i, a);
    for (let p = t, g = s; p <= e; ) {
      let y = i.doc.lineAt(p);
      if (p == t) {
        let b = y.number - u;
        g += h * b + d * (t - a - b);
      }
      let Q = h + d * y.length;
      o(new Bi(y.from, y.length, g, Q, 0)), g += Q, p = y.to + 1;
    }
  }
  replace(t, e, i) {
    let s = this.length - e;
    if (s > 0) {
      let a = i[i.length - 1];
      a instanceof xe ? i[i.length - 1] = new xe(a.length + s) : i.push(null, new xe(s - 1));
    }
    if (t > 0) {
      let a = i[0];
      a instanceof xe ? i[0] = new xe(t + a.length) : i.unshift(new xe(t - 1), null);
    }
    return Xe.of(i);
  }
  decomposeLeft(t, e) {
    e.push(new xe(t - 1), null);
  }
  decomposeRight(t, e) {
    e.push(null, new xe(this.length - t - 1));
  }
  updateHeight(t, e = 0, i = !1, s) {
    let a = e + this.length;
    if (s && s.from <= e + this.length && s.more) {
      let o = [], u = Math.max(e, s.from), h = -1;
      for (s.from > e && o.push(new xe(s.from - e - 1).updateHeight(t, e)); u <= a && s.more; ) {
        let p = t.doc.lineAt(u).length;
        o.length && o.push(null);
        let g = s.heights[s.index++];
        h == -1 ? h = g : Math.abs(g - h) >= Fc && (h = -2);
        let y = new ri(p, g);
        y.outdated = !1, o.push(y), u += p + 1;
      }
      u <= a && o.push(null, new xe(a - u).updateHeight(t, u));
      let d = Xe.of(o);
      return (h < 0 || Math.abs(d.height - this.height) >= Fc || Math.abs(h - this.heightMetrics(t, e).perLine) >= Fc) && (ir = !0), gu(this, d);
    } else (i || this.outdated) && (this.setHeight(t.heightForGap(e, e + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class mP extends Xe {
  constructor(t, e, i) {
    super(t.length + e + i.length, t.height + i.height, e | (t.outdated || i.outdated ? 2 : 0)), this.left = t, this.right = i, this.size = t.size + i.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(t, e, i, s) {
    let a = i + this.left.height;
    return t < a ? this.left.blockAt(t, e, i, s) : this.right.blockAt(t, e, a, s + this.left.length + this.break);
  }
  lineAt(t, e, i, s, a) {
    let o = s + this.left.height, u = a + this.left.length + this.break, h = e == Lt.ByHeight ? t < o : t < u, d = h ? this.left.lineAt(t, e, i, s, a) : this.right.lineAt(t, e, i, o, u);
    if (this.break || (h ? d.to < u : d.from > u))
      return d;
    let p = e == Lt.ByPosNoHeight ? Lt.ByPosNoHeight : Lt.ByPos;
    return h ? d.join(this.right.lineAt(u, p, i, o, u)) : this.left.lineAt(u, p, i, s, a).join(d);
  }
  forEachLine(t, e, i, s, a, o) {
    let u = s + this.left.height, h = a + this.left.length + this.break;
    if (this.break)
      t < h && this.left.forEachLine(t, e, i, s, a, o), e >= h && this.right.forEachLine(t, e, i, u, h, o);
    else {
      let d = this.lineAt(h, Lt.ByPos, i, s, a);
      t < d.from && this.left.forEachLine(t, d.from - 1, i, s, a, o), d.to >= t && d.from <= e && o(d), e > d.to && this.right.forEachLine(d.to + 1, e, i, u, h, o);
    }
  }
  replace(t, e, i) {
    let s = this.left.length + this.break;
    if (e < s)
      return this.balanced(this.left.replace(t, e, i), this.right);
    if (t > this.left.length)
      return this.balanced(this.left, this.right.replace(t - s, e - s, i));
    let a = [];
    t > 0 && this.decomposeLeft(t, a);
    let o = a.length;
    for (let u of i)
      a.push(u);
    if (t > 0 && HS(a, o - 1), e < this.length) {
      let u = a.length;
      this.decomposeRight(e, a), HS(a, u);
    }
    return Xe.of(a);
  }
  decomposeLeft(t, e) {
    let i = this.left.length;
    if (t <= i)
      return this.left.decomposeLeft(t, e);
    e.push(this.left), this.break && (i++, t >= i && e.push(null)), t > i && this.right.decomposeLeft(t - i, e);
  }
  decomposeRight(t, e) {
    let i = this.left.length, s = i + this.break;
    if (t >= s)
      return this.right.decomposeRight(t - s, e);
    t < i && this.left.decomposeRight(t, e), this.break && t < s && e.push(null), e.push(this.right);
  }
  balanced(t, e) {
    return t.size > 2 * e.size || e.size > 2 * t.size ? Xe.of(this.break ? [t, null, e] : [t, e]) : (this.left = gu(this.left, t), this.right = gu(this.right, e), this.setHeight(t.height + e.height), this.outdated = t.outdated || e.outdated, this.size = t.size + e.size, this.length = t.length + this.break + e.length, this);
  }
  updateHeight(t, e = 0, i = !1, s) {
    let { left: a, right: o } = this, u = e + a.length + this.break, h = null;
    return s && s.from <= e + a.length && s.more ? h = a = a.updateHeight(t, e, i, s) : a.updateHeight(t, e, i), s && s.from <= u + o.length && s.more ? h = o = o.updateHeight(t, u, i, s) : o.updateHeight(t, u, i), h ? this.balanced(a, o) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function HS(n, t) {
  let e, i;
  n[t] == null && (e = n[t - 1]) instanceof xe && (i = n[t + 1]) instanceof xe && n.splice(t - 1, 3, new xe(e.length + 1 + i.length));
}
const gP = 5;
class wp {
  constructor(t, e) {
    this.pos = t, this.oracle = e, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = t;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(t, e) {
    if (this.lineStart > -1) {
      let i = Math.min(e, this.lineEnd), s = this.nodes[this.nodes.length - 1];
      s instanceof ri ? s.length += i - this.pos : (i > this.pos || !this.isCovered) && this.nodes.push(new ri(i - this.pos, -1)), this.writtenTo = i, e > i && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = e;
  }
  point(t, e, i) {
    if (t < e || i.heightRelevant) {
      let s = i.widget ? i.widget.estimatedHeight : 0, a = i.widget ? i.widget.lineBreaks : 0;
      s < 0 && (s = this.oracle.lineHeight);
      let o = e - t;
      i.block ? this.addBlock(new gb(o, s, i)) : (o || a || s >= gP) && this.addLineDeco(s, a, o);
    } else e > t && this.span(t, e);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: t, to: e } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = t, this.lineEnd = e, this.writtenTo < t && ((this.writtenTo < t - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, t - 1)), this.nodes.push(null)), this.pos > t && this.nodes.push(new ri(this.pos - t, -1)), this.writtenTo = this.pos;
  }
  blankContent(t, e) {
    let i = new xe(e - t);
    return this.oracle.doc.lineAt(t).to == e && (i.flags |= 4), i;
  }
  ensureLine() {
    this.enterLine();
    let t = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (t instanceof ri)
      return t;
    let e = new ri(0, -1);
    return this.nodes.push(e), e;
  }
  addBlock(t) {
    this.enterLine();
    let e = t.deco;
    e && e.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(t), this.writtenTo = this.pos = this.pos + t.length, e && e.endSide > 0 && (this.covering = t);
  }
  addLineDeco(t, e, i) {
    let s = this.ensureLine();
    s.length += i, s.collapsed += i, s.widgetHeight = Math.max(s.widgetHeight, t), s.breaks += e, this.writtenTo = this.pos = this.pos + i;
  }
  finish(t) {
    let e = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(e instanceof ri) && !this.isCovered ? this.nodes.push(new ri(0, -1)) : (this.writtenTo < this.pos || e == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let i = t;
    for (let s of this.nodes)
      s instanceof ri && s.updateHeight(this.oracle, i), i += s ? s.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(t, e, i, s) {
    let a = new wp(i, t);
    return Mt.spans(e, i, s, a, 0), a.finish(i);
  }
}
function yP(n, t, e) {
  let i = new SP();
  return Mt.compare(n, t, e, i, 0), i.changes;
}
class SP {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(t, e, i, s) {
    (t < e || i && i.heightRelevant || s && s.heightRelevant) && Jc(t, e, this.changes, 5);
  }
}
function QP(n, t) {
  let e = n.getBoundingClientRect(), i = n.ownerDocument, s = i.defaultView || window, a = Math.max(0, e.left), o = Math.min(s.innerWidth, e.right), u = Math.max(0, e.top), h = Math.min(s.innerHeight, e.bottom);
  for (let d = n.parentNode; d && d != i.body; )
    if (d.nodeType == 1) {
      let p = d, g = window.getComputedStyle(p);
      if ((p.scrollHeight > p.clientHeight || p.scrollWidth > p.clientWidth) && g.overflow != "visible") {
        let y = p.getBoundingClientRect();
        a = Math.max(a, y.left), o = Math.min(o, y.right), u = Math.max(u, y.top), h = Math.min(d == n.parentNode ? s.innerHeight : h, y.bottom);
      }
      d = g.position == "absolute" || g.position == "fixed" ? p.offsetParent : p.parentNode;
    } else if (d.nodeType == 11)
      d = d.host;
    else
      break;
  return {
    left: a - e.left,
    right: Math.max(a, o) - e.left,
    top: u - (e.top + t),
    bottom: Math.max(u, h) - (e.top + t)
  };
}
function vP(n) {
  let t = n.getBoundingClientRect(), e = n.ownerDocument.defaultView || window;
  return t.left < e.innerWidth && t.right > 0 && t.top < e.innerHeight && t.bottom > 0;
}
function bP(n, t) {
  let e = n.getBoundingClientRect();
  return {
    left: 0,
    right: e.right - e.left,
    top: t,
    bottom: e.bottom - (e.top + t)
  };
}
class RO {
  constructor(t, e, i, s) {
    this.from = t, this.to = e, this.size = i, this.displaySize = s;
  }
  static same(t, e) {
    if (t.length != e.length)
      return !1;
    for (let i = 0; i < t.length; i++) {
      let s = t[i], a = e[i];
      if (s.from != a.from || s.to != a.to || s.size != a.size)
        return !1;
    }
    return !0;
  }
  draw(t, e) {
    return ft.replace({
      widget: new xP(this.displaySize * (e ? t.scaleY : t.scaleX), e)
    }).range(this.from, this.to);
  }
}
class xP extends tn {
  constructor(t, e) {
    super(), this.size = t, this.vertical = e;
  }
  eq(t) {
    return t.size == this.size && t.vertical == this.vertical;
  }
  toDOM() {
    let t = document.createElement("div");
    return this.vertical ? t.style.height = this.size + "px" : (t.style.width = this.size + "px", t.style.height = "2px", t.style.display = "inline-block"), t;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class KS {
  constructor(t) {
    this.state = t, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = JS, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = Bt.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let e = t.facet(vp).some((i) => typeof i != "function" && i.class == "cm-lineWrapping");
    this.heightOracle = new dP(e), this.stateDeco = t.facet(Za).filter((i) => typeof i != "function"), this.heightMap = Xe.empty().applyChanges(this.stateDeco, Rt.empty, this.heightOracle.setDoc(t.doc), [new vi(0, 0, 0, t.doc.length)]);
    for (let i = 0; i < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); i++)
      ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = ft.set(this.lineGaps.map((i) => i.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let t = [this.viewport], { main: e } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let s = i ? e.head : e.anchor;
      if (!t.some(({ from: a, to: o }) => s >= a && s <= o)) {
        let { from: a, to: o } = this.lineBlockAt(s);
        t.push(new Ac(a, o));
      }
    }
    return this.viewports = t.sort((i, s) => i.from - s.from), this.updateScaler();
  }
  updateScaler() {
    let t = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? JS : new Tp(this.heightOracle, this.heightMap, this.viewports), t.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (t) => {
      this.viewportLines.push(va(t, this.scaler));
    });
  }
  update(t, e = null) {
    this.state = t.state;
    let i = this.stateDeco;
    this.stateDeco = this.state.facet(Za).filter((p) => typeof p != "function");
    let s = t.changedRanges, a = vi.extendWithRanges(s, yP(i, this.stateDeco, t ? t.changes : Oe.empty(this.state.doc.length))), o = this.heightMap.height, u = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    WS(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, t.startState.doc, this.heightOracle.setDoc(this.state.doc), a), (this.heightMap.height != o || ir) && (t.flags |= 2), u ? (this.scrollAnchorPos = t.changes.mapPos(u.from, -1), this.scrollAnchorHeight = u.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = o);
    let h = a.length ? this.mapViewport(this.viewport, t.changes) : this.viewport;
    (e && (e.range.head < h.from || e.range.head > h.to) || !this.viewportIsAppropriate(h)) && (h = this.getViewport(0, e));
    let d = h.from != this.viewport.from || h.to != this.viewport.to;
    this.viewport = h, t.flags |= this.updateForViewport(), (d || !t.changes.empty || t.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, t.changes))), t.flags |= this.computeVisibleRanges(t.changes), e && (this.scrollTarget = e), !this.mustEnforceCursorAssoc && t.selectionSet && t.view.lineWrapping && t.state.selection.main.empty && t.state.selection.main.assoc && !t.state.facet(Fv) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(t) {
    let e = t.contentDOM, i = window.getComputedStyle(e), s = this.heightOracle, a = i.whiteSpace;
    this.defaultTextDirection = i.direction == "rtl" ? Bt.RTL : Bt.LTR;
    let o = this.heightOracle.mustRefreshForWrapping(a), u = e.getBoundingClientRect(), h = o || this.mustMeasureContent || this.contentDOMHeight != u.height;
    this.contentDOMHeight = u.height, this.mustMeasureContent = !1;
    let d = 0, p = 0;
    if (u.width && u.height) {
      let { scaleX: H, scaleY: _ } = Tv(e, u);
      (H > 5e-3 && Math.abs(this.scaleX - H) > 5e-3 || _ > 5e-3 && Math.abs(this.scaleY - _) > 5e-3) && (this.scaleX = H, this.scaleY = _, d |= 16, o = h = !0);
    }
    let g = (parseInt(i.paddingTop) || 0) * this.scaleY, y = (parseInt(i.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != g || this.paddingBottom != y) && (this.paddingTop = g, this.paddingBottom = y, d |= 18), this.editorWidth != t.scrollDOM.clientWidth && (s.lineWrapping && (h = !0), this.editorWidth = t.scrollDOM.clientWidth, d |= 16);
    let Q = t.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != Q && (this.scrollAnchorHeight = -1, this.scrollTop = Q), this.scrolledToBottom = Rv(t.scrollDOM);
    let b = (this.printing ? bP : QP)(e, this.paddingTop), x = b.top - this.pixelViewport.top, P = b.bottom - this.pixelViewport.bottom;
    this.pixelViewport = b;
    let A = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (A != this.inView && (this.inView = A, A && (h = !0)), !this.inView && !this.scrollTarget && !vP(t.dom))
      return 0;
    let V = u.width;
    if ((this.contentDOMWidth != V || this.editorHeight != t.scrollDOM.clientHeight) && (this.contentDOMWidth = u.width, this.editorHeight = t.scrollDOM.clientHeight, d |= 16), h) {
      let H = t.docView.measureVisibleLineHeights(this.viewport);
      if (s.mustRefreshForHeights(H) && (o = !0), o || s.lineWrapping && Math.abs(V - this.contentDOMWidth) > s.charWidth) {
        let { lineHeight: _, charWidth: W, textHeight: q } = t.docView.measureTextSize();
        o = _ > 0 && s.refresh(a, _, W, q, V / W, H), o && (t.docView.minWidth = 0, d |= 16);
      }
      x > 0 && P > 0 ? p = Math.max(x, P) : x < 0 && P < 0 && (p = Math.min(x, P)), WS();
      for (let _ of this.viewports) {
        let W = _.from == this.viewport.from ? H : t.docView.measureVisibleLineHeights(_);
        this.heightMap = (o ? Xe.empty().applyChanges(this.stateDeco, Rt.empty, this.heightOracle, [new vi(0, 0, 0, t.state.doc.length)]) : this.heightMap).updateHeight(s, 0, o, new pP(_.from, W));
      }
      ir && (d |= 2);
    }
    let G = !this.viewportIsAppropriate(this.viewport, p) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return G && (d & 2 && (d |= this.updateScaler()), this.viewport = this.getViewport(p, this.scrollTarget), d |= this.updateForViewport()), (d & 2 || G) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, t)), d |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, t.docView.enforceCursorAssoc()), d;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(t, e) {
    let i = 0.5 - Math.max(-0.5, Math.min(0.5, t / 1e3 / 2)), s = this.heightMap, a = this.heightOracle, { visibleTop: o, visibleBottom: u } = this, h = new Ac(s.lineAt(o - i * 1e3, Lt.ByHeight, a, 0, 0).from, s.lineAt(u + (1 - i) * 1e3, Lt.ByHeight, a, 0, 0).to);
    if (e) {
      let { head: d } = e.range;
      if (d < h.from || d > h.to) {
        let p = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), g = s.lineAt(d, Lt.ByPos, a, 0, 0), y;
        e.y == "center" ? y = (g.top + g.bottom) / 2 - p / 2 : e.y == "start" || e.y == "nearest" && d < h.from ? y = g.top : y = g.bottom - p, h = new Ac(s.lineAt(y - 1e3 / 2, Lt.ByHeight, a, 0, 0).from, s.lineAt(y + p + 1e3 / 2, Lt.ByHeight, a, 0, 0).to);
      }
    }
    return h;
  }
  mapViewport(t, e) {
    let i = e.mapPos(t.from, -1), s = e.mapPos(t.to, 1);
    return new Ac(this.heightMap.lineAt(i, Lt.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(s, Lt.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: t, to: e }, i = 0) {
    if (!this.inView)
      return !0;
    let { top: s } = this.heightMap.lineAt(t, Lt.ByPos, this.heightOracle, 0, 0), { bottom: a } = this.heightMap.lineAt(e, Lt.ByPos, this.heightOracle, 0, 0), { visibleTop: o, visibleBottom: u } = this;
    return (t == 0 || s <= o - Math.max(10, Math.min(
      -i,
      250
      /* VP.MaxCoverMargin */
    ))) && (e == this.state.doc.length || a >= u + Math.max(10, Math.min(
      i,
      250
      /* VP.MaxCoverMargin */
    ))) && s > o - 2 * 1e3 && a < u + 2 * 1e3;
  }
  mapLineGaps(t, e) {
    if (!t.length || e.empty)
      return t;
    let i = [];
    for (let s of t)
      e.touchesRange(s.from, s.to) || i.push(new RO(e.mapPos(s.from), e.mapPos(s.to), s.size, s.displaySize));
    return i;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(t, e) {
    let i = this.heightOracle.lineWrapping, s = i ? 1e4 : 2e3, a = s >> 1, o = s << 1;
    if (this.defaultTextDirection != Bt.LTR && !i)
      return [];
    let u = [], h = (p, g, y, Q) => {
      if (g - p < a)
        return;
      let b = this.state.selection.main, x = [b.from];
      b.empty || x.push(b.to);
      for (let A of x)
        if (A > p && A < g) {
          h(p, A - 10, y, Q), h(A + 10, g, y, Q);
          return;
        }
      let P = wP(t, (A) => A.from >= y.from && A.to <= y.to && Math.abs(A.from - p) < a && Math.abs(A.to - g) < a && !x.some((V) => A.from < V && A.to > V));
      if (!P) {
        if (g < y.to && e && i && e.visibleRanges.some((G) => G.from <= g && G.to >= g)) {
          let G = e.moveToLineBoundary(j.cursor(g), !1, !0).head;
          G > p && (g = G);
        }
        let A = this.gapSize(y, p, g, Q), V = i || A < 2e6 ? A : 2e6;
        P = new RO(p, g, A, V);
      }
      u.push(P);
    }, d = (p) => {
      if (p.length < o || p.type != Ee.Text)
        return;
      let g = kP(p.from, p.to, this.stateDeco);
      if (g.total < o)
        return;
      let y = this.scrollTarget ? this.scrollTarget.range.head : null, Q, b;
      if (i) {
        let x = s / this.heightOracle.lineLength * this.heightOracle.lineHeight, P, A;
        if (y != null) {
          let V = qc(g, y), G = ((this.visibleBottom - this.visibleTop) / 2 + x) / p.height;
          P = V - G, A = V + G;
        } else
          P = (this.visibleTop - p.top - x) / p.height, A = (this.visibleBottom - p.top + x) / p.height;
        Q = Mc(g, P), b = Mc(g, A);
      } else {
        let x = g.total * this.heightOracle.charWidth, P = s * this.heightOracle.charWidth, A = 0;
        if (x > 2e6)
          for (let W of t)
            W.from >= p.from && W.from < p.to && W.size != W.displaySize && W.from * this.heightOracle.charWidth + A < this.pixelViewport.left && (A = W.size - W.displaySize);
        let V = this.pixelViewport.left + A, G = this.pixelViewport.right + A, H, _;
        if (y != null) {
          let W = qc(g, y), q = ((G - V) / 2 + P) / x;
          H = W - q, _ = W + q;
        } else
          H = (V - P) / x, _ = (G + P) / x;
        Q = Mc(g, H), b = Mc(g, _);
      }
      Q > p.from && h(p.from, Q, p, g), b < p.to && h(b, p.to, p, g);
    };
    for (let p of this.viewportLines)
      Array.isArray(p.type) ? p.type.forEach(d) : d(p);
    return u;
  }
  gapSize(t, e, i, s) {
    let a = qc(s, i) - qc(s, e);
    return this.heightOracle.lineWrapping ? t.height * a : s.total * this.heightOracle.charWidth * a;
  }
  updateLineGaps(t) {
    RO.same(t, this.lineGaps) || (this.lineGaps = t, this.lineGapDeco = ft.set(t.map((e) => e.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges(t) {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let i = [];
    Mt.spans(e, this.viewport.from, this.viewport.to, {
      span(a, o) {
        i.push({ from: a, to: o });
      },
      point() {
      }
    }, 20);
    let s = 0;
    if (i.length != this.visibleRanges.length)
      s = 12;
    else
      for (let a = 0; a < i.length && !(s & 8); a++) {
        let o = this.visibleRanges[a], u = i[a];
        (o.from != u.from || o.to != u.to) && (s |= 4, t && t.mapPos(o.from, -1) == u.from && t.mapPos(o.to, 1) == u.to || (s |= 8));
      }
    return this.visibleRanges = i, s;
  }
  lineBlockAt(t) {
    return t >= this.viewport.from && t <= this.viewport.to && this.viewportLines.find((e) => e.from <= t && e.to >= t) || va(this.heightMap.lineAt(t, Lt.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(t) {
    return t >= this.viewportLines[0].top && t <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((e) => e.top <= t && e.bottom >= t) || va(this.heightMap.lineAt(this.scaler.fromDOM(t), Lt.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(t) {
    let e = this.lineBlockAtHeight(t + 8);
    return e.from >= this.viewport.from || this.viewportLines[0].top - t > 200 ? e : this.viewportLines[0];
  }
  elementAtHeight(t) {
    return va(this.heightMap.blockAt(this.scaler.fromDOM(t), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Ac {
  constructor(t, e) {
    this.from = t, this.to = e;
  }
}
function kP(n, t, e) {
  let i = [], s = n, a = 0;
  return Mt.spans(e, n, t, {
    span() {
    },
    point(o, u) {
      o > s && (i.push({ from: s, to: o }), a += o - s), s = u;
    }
  }, 20), s < t && (i.push({ from: s, to: t }), a += t - s), { total: a, ranges: i };
}
function Mc({ total: n, ranges: t }, e) {
  if (e <= 0)
    return t[0].from;
  if (e >= 1)
    return t[t.length - 1].to;
  let i = Math.floor(n * e);
  for (let s = 0; ; s++) {
    let { from: a, to: o } = t[s], u = o - a;
    if (i <= u)
      return a + i;
    i -= u;
  }
}
function qc(n, t) {
  let e = 0;
  for (let { from: i, to: s } of n.ranges) {
    if (t <= s) {
      e += t - i;
      break;
    }
    e += s - i;
  }
  return e / n.total;
}
function wP(n, t) {
  for (let e of n)
    if (t(e))
      return e;
}
const JS = {
  toDOM(n) {
    return n;
  },
  fromDOM(n) {
    return n;
  },
  scale: 1,
  eq(n) {
    return n == this;
  }
};
class Tp {
  constructor(t, e, i) {
    let s = 0, a = 0, o = 0;
    this.viewports = i.map(({ from: u, to: h }) => {
      let d = e.lineAt(u, Lt.ByPos, t, 0, 0).top, p = e.lineAt(h, Lt.ByPos, t, 0, 0).bottom;
      return s += p - d, { from: u, to: h, top: d, bottom: p, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - s) / (e.height - s);
    for (let u of this.viewports)
      u.domTop = o + (u.top - a) * this.scale, o = u.domBottom = u.domTop + (u.bottom - u.top), a = u.bottom;
  }
  toDOM(t) {
    for (let e = 0, i = 0, s = 0; ; e++) {
      let a = e < this.viewports.length ? this.viewports[e] : null;
      if (!a || t < a.top)
        return s + (t - i) * this.scale;
      if (t <= a.bottom)
        return a.domTop + (t - a.top);
      i = a.bottom, s = a.domBottom;
    }
  }
  fromDOM(t) {
    for (let e = 0, i = 0, s = 0; ; e++) {
      let a = e < this.viewports.length ? this.viewports[e] : null;
      if (!a || t < a.domTop)
        return i + (t - s) / this.scale;
      if (t <= a.domBottom)
        return a.top + (t - a.domTop);
      i = a.bottom, s = a.domBottom;
    }
  }
  eq(t) {
    return t instanceof Tp ? this.scale == t.scale && this.viewports.length == t.viewports.length && this.viewports.every((e, i) => e.from == t.viewports[i].from && e.to == t.viewports[i].to) : !1;
  }
}
function va(n, t) {
  if (t.scale == 1)
    return n;
  let e = t.toDOM(n.top), i = t.toDOM(n.bottom);
  return new Bi(n.from, n.length, e, i - e, Array.isArray(n._content) ? n._content.map((s) => va(s, t)) : n._content);
}
const Cc = /* @__PURE__ */ lt.define({ combine: (n) => n.join(" ") }), zd = /* @__PURE__ */ lt.define({ combine: (n) => n.indexOf(!0) > -1 }), Dd = /* @__PURE__ */ cl.newName(), yb = /* @__PURE__ */ cl.newName(), Sb = /* @__PURE__ */ cl.newName(), Qb = { "&light": "." + yb, "&dark": "." + Sb };
function Vd(n, t, e) {
  return new cl(t, {
    finish(i) {
      return /&/.test(i) ? i.replace(/&\w*/, (s) => {
        if (s == "&")
          return n;
        if (!e || !e[s])
          throw new RangeError(`Unsupported selector: ${s}`);
        return e[s];
      }) : n + " " + i;
    }
  });
}
const TP = /* @__PURE__ */ Vd("." + Dd, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top",
    userSelect: "none"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, Qb), $P = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, AO = st.ie && st.ie_version <= 11;
class PP {
  constructor(t) {
    this.view = t, this.active = !1, this.editContext = null, this.selectionRange = new c2(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = t.contentDOM, this.observer = new MutationObserver((e) => {
      for (let i of e)
        this.queue.push(i);
      (st.ie && st.ie_version <= 11 || st.ios && t.composing) && e.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && t.constructor.EDIT_CONTEXT !== !1 && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(st.chrome && st.chrome_version < 126) && (this.editContext = new AP(t), t.state.facet(xn) && (t.contentDOM.editContext = this.editContext.editContext)), AO && (this.onCharData = (e) => {
      this.queue.push({
        target: e.target,
        type: "characterData",
        oldValue: e.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var e;
      ((e = this.view.docView) === null || e === void 0 ? void 0 : e.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(t.scrollDOM)), this.addWindowListeners(this.win = t.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((e) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), e.length > 0 && e[e.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((e) => {
      e.length > 0 && e[e.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(t) {
    this.view.inputState.runHandlers("scroll", t), this.intersecting && this.view.measure();
  }
  onScroll(t) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(t);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(t) {
    (t.type == "change" || !t.type) && !t.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(t) {
    if (this.gapIntersection && (t.length != this.gaps.length || this.gaps.some((e, i) => e != t[i]))) {
      this.gapIntersection.disconnect();
      for (let e of t)
        this.gapIntersection.observe(e);
      this.gaps = t;
    }
  }
  onSelectionChange(t) {
    let e = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: i } = this, s = this.selectionRange;
    if (i.state.facet(xn) ? i.root.activeElement != this.dom : !Kc(this.dom, s))
      return;
    let a = s.anchorNode && i.docView.nearest(s.anchorNode);
    if (a && a.ignoreEvent(t)) {
      e || (this.selectionChanged = !1);
      return;
    }
    (st.ie && st.ie_version <= 11 || st.android && st.chrome) && !i.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    s.focusNode && Ta(s.focusNode, s.focusOffset, s.anchorNode, s.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: t } = this, e = Ca(t.root);
    if (!e)
      return !1;
    let i = st.safari && t.root.nodeType == 11 && t.root.activeElement == this.dom && RP(this.view, e) || e;
    if (!i || this.selectionRange.eq(i))
      return !1;
    let s = Kc(this.dom, i);
    return s && !this.selectionChanged && t.inputState.lastFocusTime > Date.now() - 200 && t.inputState.lastTouchTime < Date.now() - 300 && f2(this.dom, i) ? (this.view.inputState.lastFocusTime = 0, t.docView.updateSelection(), !1) : (this.selectionRange.setRange(i), s && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(t, e) {
    this.selectionRange.set(t.node, t.offset, e.node, e.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let t = 0, e = null;
    for (let i = this.dom; i; )
      if (i.nodeType == 1)
        !e && t < this.scrollTargets.length && this.scrollTargets[t] == i ? t++ : e || (e = this.scrollTargets.slice(0, t)), e && e.push(i), i = i.assignedSlot || i.parentNode;
      else if (i.nodeType == 11)
        i = i.host;
      else
        break;
    if (t < this.scrollTargets.length && !e && (e = this.scrollTargets.slice(0, t)), e) {
      for (let i of this.scrollTargets)
        i.removeEventListener("scroll", this.onScroll);
      for (let i of this.scrollTargets = e)
        i.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(t) {
    if (!this.active)
      return t();
    try {
      return this.stop(), t();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, $P), AO && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), AO && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(t, e) {
    var i;
    if (!this.delayedAndroidKey) {
      let s = () => {
        let a = this.delayedAndroidKey;
        a && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = a.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && a.force && Ns(this.dom, a.key, a.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(s);
    }
    (!this.delayedAndroidKey || t == "Enter") && (this.delayedAndroidKey = {
      key: t,
      keyCode: e,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((i = this.delayedAndroidKey) === null || i === void 0) && i.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let t of this.observer.takeRecords())
      this.queue.push(t);
    return this.queue;
  }
  processRecords() {
    let t = this.pendingRecords();
    t.length && (this.queue = []);
    let e = -1, i = -1, s = !1;
    for (let a of t) {
      let o = this.readMutation(a);
      o && (o.typeOver && (s = !0), e == -1 ? { from: e, to: i } = o : (e = Math.min(o.from, e), i = Math.max(o.to, i)));
    }
    return { from: e, to: i, typeOver: s };
  }
  readChange() {
    let { from: t, to: e, typeOver: i } = this.processRecords(), s = this.selectionChanged && Kc(this.dom, this.selectionRange);
    if (t < 0 && !s)
      return null;
    t > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let a = new G2(this.view, t, e, i);
    return this.view.docView.domChanged = { newSel: a.newSel ? a.newSel.main : null }, a;
  }
  // Apply pending changes, if any
  flush(t = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    t && this.readSelectionRange();
    let e = this.readChange();
    if (!e)
      return this.view.requestMeasure(), !1;
    let i = this.view.state, s = ob(this.view, e);
    return this.view.state == i && (e.domChanged || e.newSel && !e.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), s;
  }
  readMutation(t) {
    let e = this.view.docView.nearest(t.target);
    if (!e || e.ignoreMutation(t))
      return null;
    if (e.markDirty(t.type == "attributes"), t.type == "attributes" && (e.flags |= 4), t.type == "childList") {
      let i = IS(e, t.previousSibling || t.target.previousSibling, -1), s = IS(e, t.nextSibling || t.target.nextSibling, 1);
      return {
        from: i ? e.posAfter(i) : e.posAtStart,
        to: s ? e.posBefore(s) : e.posAtEnd,
        typeOver: !1
      };
    } else return t.type == "characterData" ? { from: e.posAtStart, to: e.posAtEnd, typeOver: t.target.nodeValue == t.oldValue } : null;
  }
  setWindow(t) {
    t != this.win && (this.removeWindowListeners(this.win), this.win = t, this.addWindowListeners(this.win));
  }
  addWindowListeners(t) {
    t.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : t.addEventListener("beforeprint", this.onPrint), t.addEventListener("scroll", this.onScroll), t.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(t) {
    t.removeEventListener("scroll", this.onScroll), t.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : t.removeEventListener("beforeprint", this.onPrint), t.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(t) {
    this.editContext && (this.editContext.update(t), t.startState.facet(xn) != t.state.facet(xn) && (t.view.contentDOM.editContext = t.state.facet(xn) ? this.editContext.editContext : null));
  }
  destroy() {
    var t, e, i;
    this.stop(), (t = this.intersection) === null || t === void 0 || t.disconnect(), (e = this.gapIntersection) === null || e === void 0 || e.disconnect(), (i = this.resizeScroll) === null || i === void 0 || i.disconnect();
    for (let s of this.scrollTargets)
      s.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
}
function IS(n, t, e) {
  for (; t; ) {
    let i = Ut.get(t);
    if (i && i.parent == n)
      return i;
    let s = t.parentNode;
    t = s != n.dom ? s : e > 0 ? t.nextSibling : t.previousSibling;
  }
  return null;
}
function FS(n, t) {
  let e = t.startContainer, i = t.startOffset, s = t.endContainer, a = t.endOffset, o = n.docView.domAtPos(n.state.selection.main.anchor);
  return Ta(o.node, o.offset, s, a) && ([e, i, s, a] = [s, a, e, i]), { anchorNode: e, anchorOffset: i, focusNode: s, focusOffset: a };
}
function RP(n, t) {
  if (t.getComposedRanges) {
    let s = t.getComposedRanges(n.root)[0];
    if (s)
      return FS(n, s);
  }
  let e = null;
  function i(s) {
    s.preventDefault(), s.stopImmediatePropagation(), e = s.getTargetRanges()[0];
  }
  return n.contentDOM.addEventListener("beforeinput", i, !0), n.dom.ownerDocument.execCommand("indent"), n.contentDOM.removeEventListener("beforeinput", i, !0), e ? FS(n, e) : null;
}
class AP {
  constructor(t) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.composing = null, this.resetRange(t.state);
    let e = this.editContext = new window.EditContext({
      text: t.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, t.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(t.state.selection.main.head)
    });
    this.handlers.textupdate = (i) => {
      let s = t.state.selection.main, { anchor: a, head: o } = s, u = this.toEditorPos(i.updateRangeStart), h = this.toEditorPos(i.updateRangeEnd);
      t.inputState.composing >= 0 && !this.composing && (this.composing = { contextBase: i.updateRangeStart, editorBase: u, drifted: !1 });
      let d = { from: u, to: h, insert: Rt.of(i.text.split(`
`)) };
      if (d.from == this.from && a < this.from ? d.from = a : d.to == this.to && a > this.to && (d.to = a), d.from == d.to && !d.insert.length) {
        let p = j.single(this.toEditorPos(i.selectionStart), this.toEditorPos(i.selectionEnd));
        p.main.eq(s) || t.dispatch({ selection: p, userEvent: "select" });
        return;
      }
      if ((st.mac || st.android) && d.from == o - 1 && /^\. ?$/.test(i.text) && t.contentDOM.getAttribute("autocorrect") == "off" && (d = { from: u, to: h, insert: Rt.of([i.text.replace(".", " ")]) }), this.pendingContextChange = d, !t.state.readOnly) {
        let p = this.to - this.from + (d.to - d.from + d.insert.length);
        kp(t, d, j.single(this.toEditorPos(i.selectionStart, p), this.toEditorPos(i.selectionEnd, p)));
      }
      this.pendingContextChange && (this.revertPending(t.state), this.setSelection(t.state));
    }, this.handlers.characterboundsupdate = (i) => {
      let s = [], a = null;
      for (let o = this.toEditorPos(i.rangeStart), u = this.toEditorPos(i.rangeEnd); o < u; o++) {
        let h = t.coordsForChar(o);
        a = h && new DOMRect(h.left, h.top, h.right - h.left, h.bottom - h.top) || a || new DOMRect(), s.push(a);
      }
      e.updateCharacterBounds(i.rangeStart, s);
    }, this.handlers.textformatupdate = (i) => {
      let s = [];
      for (let a of i.getTextFormats()) {
        let o = a.underlineStyle, u = a.underlineThickness;
        if (o != "None" && u != "None") {
          let h = this.toEditorPos(a.rangeStart), d = this.toEditorPos(a.rangeEnd);
          if (h < d) {
            let p = `text-decoration: underline ${o == "Dashed" ? "dashed " : o == "Squiggle" ? "wavy " : ""}${u == "Thin" ? 1 : 2}px`;
            s.push(ft.mark({ attributes: { style: p } }).range(h, d));
          }
        }
      }
      t.dispatch({ effects: eb.of(ft.set(s)) });
    }, this.handlers.compositionstart = () => {
      t.inputState.composing < 0 && (t.inputState.composing = 0, t.inputState.compositionFirstChange = !0);
    }, this.handlers.compositionend = () => {
      if (t.inputState.composing = -1, t.inputState.compositionFirstChange = null, this.composing) {
        let { drifted: i } = this.composing;
        this.composing = null, i && this.reset(t.state);
      }
    };
    for (let i in this.handlers)
      e.addEventListener(i, this.handlers[i]);
    this.measureReq = { read: (i) => {
      this.editContext.updateControlBounds(i.contentDOM.getBoundingClientRect());
      let s = Ca(i.root);
      s && s.rangeCount && this.editContext.updateSelectionBounds(s.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(t) {
    let e = 0, i = !1, s = this.pendingContextChange;
    return t.changes.iterChanges((a, o, u, h, d) => {
      if (i)
        return;
      let p = d.length - (o - a);
      if (s && o >= s.to)
        if (s.from == a && s.to == o && s.insert.eq(d)) {
          s = this.pendingContextChange = null, e += p, this.to += p;
          return;
        } else
          s = null, this.revertPending(t.state);
      if (a += e, o += e, o <= this.from)
        this.from += p, this.to += p;
      else if (a < this.to) {
        if (a < this.from || o > this.to || this.to - this.from + d.length > 3e4) {
          i = !0;
          return;
        }
        this.editContext.updateText(this.toContextPos(a), this.toContextPos(o), d.toString()), this.to += p;
      }
      e += p;
    }), s && !i && this.revertPending(t.state), !i;
  }
  update(t) {
    let e = this.pendingContextChange, i = t.startState.selection.main;
    this.composing && (this.composing.drifted || !t.changes.touchesRange(i.from, i.to) && t.transactions.some((s) => !s.isUserEvent("input.type") && s.changes.touchesRange(this.from, this.to))) ? (this.composing.drifted = !0, this.composing.editorBase = t.changes.mapPos(this.composing.editorBase)) : !this.applyEdits(t) || !this.rangeIsValid(t.state) ? (this.pendingContextChange = null, this.reset(t.state)) : (t.docChanged || t.selectionSet || e) && this.setSelection(t.state), (t.geometryChanged || t.docChanged || t.selectionSet) && t.view.requestMeasure(this.measureReq);
  }
  resetRange(t) {
    let { head: e } = t.selection.main;
    this.from = Math.max(
      0,
      e - 1e4
      /* CxVp.Margin */
    ), this.to = Math.min(
      t.doc.length,
      e + 1e4
      /* CxVp.Margin */
    );
  }
  reset(t) {
    this.resetRange(t), this.editContext.updateText(0, this.editContext.text.length, t.doc.sliceString(this.from, this.to)), this.setSelection(t);
  }
  revertPending(t) {
    let e = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(e.from), this.toContextPos(e.from + e.insert.length), t.doc.sliceString(e.from, e.to));
  }
  setSelection(t) {
    let { main: e } = t.selection, i = this.toContextPos(Math.max(this.from, Math.min(this.to, e.anchor))), s = this.toContextPos(e.head);
    (this.editContext.selectionStart != i || this.editContext.selectionEnd != s) && this.editContext.updateSelection(i, s);
  }
  rangeIsValid(t) {
    let { head: e } = t.selection.main;
    return !(this.from > 0 && e - this.from < 500 || this.to < t.doc.length && this.to - e < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(t, e = this.to - this.from) {
    t = Math.min(t, e);
    let i = this.composing;
    return i && i.drifted ? i.editorBase + (t - i.contextBase) : t + this.from;
  }
  toContextPos(t) {
    let e = this.composing;
    return e && e.drifted ? e.contextBase + (t - e.editorBase) : t - this.from;
  }
  destroy() {
    for (let t in this.handlers)
      this.editContext.removeEventListener(t, this.handlers[t]);
  }
}
class it {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return !!this.inputState && this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return !!this.inputState && this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(t = {}) {
    var e;
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), t.parent && t.parent.appendChild(this.dom);
    let { dispatch: i } = t;
    this.dispatchTransactions = t.dispatchTransactions || i && ((s) => s.forEach((a) => i(a, this))) || ((s) => this.update(s)), this.dispatch = this.dispatch.bind(this), this._root = t.root || u2(t.parent) || document, this.viewState = new KS(t.state || $t.create(t)), t.scrollTo && t.scrollTo.is($c) && (this.viewState.scrollTarget = t.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(ya).map((s) => new TO(s));
    for (let s of this.plugins)
      s.update(this);
    this.observer = new PP(this), this.inputState = new J2(this), this.inputState.ensureHandlers(this.plugins), this.docView = new MS(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((e = document.fonts) === null || e === void 0) && e.ready && document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...t) {
    let e = t.length == 1 && t[0] instanceof oe ? t : t.length == 1 && Array.isArray(t[0]) ? t[0] : [this.state.update(...t)];
    this.dispatchTransactions(e, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(t) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let e = !1, i = !1, s, a = this.state;
    for (let y of t) {
      if (y.startState != a)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      a = y.state;
    }
    if (this.destroyed) {
      this.viewState.state = a;
      return;
    }
    let o = this.hasFocus, u = 0, h = null;
    t.some((y) => y.annotation(db)) ? (this.inputState.notifiedFocused = o, u = 1) : o != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = o, h = pb(a, o), h || (u = 1));
    let d = this.observer.delayedAndroidKey, p = null;
    if (d ? (this.observer.clearDelayedAndroidKey(), p = this.observer.readChange(), (p && !this.state.doc.eq(a.doc) || !this.state.selection.eq(a.selection)) && (p = null)) : this.observer.clear(), a.facet($t.phrases) != this.state.facet($t.phrases))
      return this.setState(a);
    s = mu.create(this, a, t), s.flags |= u;
    let g = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let y of t) {
        if (g && (g = g.map(y.changes)), y.scrollIntoView) {
          let { main: Q } = y.state.selection;
          g = new Ws(Q.empty ? Q : j.cursor(Q.head, Q.head > Q.anchor ? -1 : 1));
        }
        for (let Q of y.effects)
          Q.is($c) && (g = Q.value.clip(this.state));
      }
      this.viewState.update(s, g), this.bidiCache = yu.update(this.bidiCache, s.changes), s.empty || (this.updatePlugins(s), this.inputState.update(s)), e = this.docView.update(s), this.state.facet(Sa) != this.styleModules && this.mountStyles(), i = this.updateAttrs(), this.showAnnouncements(t), this.docView.updateSelection(e, t.some((y) => y.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (s.startState.facet(Cc) != s.state.facet(Cc) && (this.viewState.mustMeasureContent = !0), (e || i || g || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), e && this.docViewUpdate(), !s.empty)
      for (let y of this.state.facet(Zd))
        try {
          y(s);
        } catch (Q) {
          Be(this.state, Q, "update listener");
        }
    (h || p) && Promise.resolve().then(() => {
      h && this.state == h.startState && this.dispatch(h), p && !ob(this, p) && d.force && Ns(this.contentDOM, d.key, d.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(t) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = t;
      return;
    }
    this.updateState = 2;
    let e = this.hasFocus;
    try {
      for (let i of this.plugins)
        i.destroy(this);
      this.viewState = new KS(t), this.plugins = t.facet(ya).map((i) => new TO(i)), this.pluginMap.clear();
      for (let i of this.plugins)
        i.update(this);
      this.docView.destroy(), this.docView = new MS(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    e && this.focus(), this.requestMeasure();
  }
  updatePlugins(t) {
    let e = t.startState.facet(ya), i = t.state.facet(ya);
    if (e != i) {
      let s = [];
      for (let a of i) {
        let o = e.indexOf(a);
        if (o < 0)
          s.push(new TO(a));
        else {
          let u = this.plugins[o];
          u.mustUpdate = t, s.push(u);
        }
      }
      for (let a of this.plugins)
        a.mustUpdate != t && a.destroy(this);
      this.plugins = s, this.pluginMap.clear();
    } else
      for (let s of this.plugins)
        s.mustUpdate = t;
    for (let s = 0; s < this.plugins.length; s++)
      this.plugins[s].update(this);
    e != i && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let t of this.plugins) {
      let e = t.value;
      if (e && e.docViewUpdate)
        try {
          e.docViewUpdate(this);
        } catch (i) {
          Be(this.state, i, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(t = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, t && this.observer.forceFlush();
    let e = null, i = this.scrollDOM, s = i.scrollTop * this.scaleY, { scrollAnchorPos: a, scrollAnchorHeight: o } = this.viewState;
    Math.abs(s - this.viewState.scrollTop) > 1 && (o = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let u = 0; ; u++) {
        if (o < 0)
          if (Rv(i))
            a = -1, o = this.viewState.heightMap.height;
          else {
            let Q = this.viewState.scrollAnchorAt(s);
            a = Q.from, o = Q.top;
          }
        this.updateState = 1;
        let h = this.viewState.measure(this);
        if (!h && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (u > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let d = [];
        h & 4 || ([this.measureRequests, d] = [d, this.measureRequests]);
        let p = d.map((Q) => {
          try {
            return Q.read(this);
          } catch (b) {
            return Be(this.state, b), t1;
          }
        }), g = mu.create(this, this.state, []), y = !1;
        g.flags |= h, e ? e.flags |= h : e = g, this.updateState = 2, g.empty || (this.updatePlugins(g), this.inputState.update(g), this.updateAttrs(), y = this.docView.update(g), y && this.docViewUpdate());
        for (let Q = 0; Q < d.length; Q++)
          if (p[Q] != t1)
            try {
              let b = d[Q];
              b.write && b.write(p[Q], this);
            } catch (b) {
              Be(this.state, b);
            }
        if (y && this.docView.updateSelection(!0), !g.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, o = -1;
              continue;
            } else {
              let b = (a < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(a).top) - o;
              if (b > 1 || b < -1) {
                s = s + b, i.scrollTop = s / this.scaleY, o = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (e && !e.empty)
      for (let u of this.state.facet(Zd))
        u(e);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return Dd + " " + (this.state.facet(zd) ? Sb : yb) + " " + this.state.facet(Cc);
  }
  updateAttrs() {
    let t = e1(this, ib, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), e = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: this.state.facet(xn) ? "true" : "false",
      class: "cm-content",
      style: `${st.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (e["aria-readonly"] = "true"), e1(this, vp, e);
    let i = this.observer.ignore(() => {
      let s = Rd(this.contentDOM, this.contentAttrs, e), a = Rd(this.dom, this.editorAttrs, t);
      return s || a;
    });
    return this.editorAttrs = t, this.contentAttrs = e, i;
  }
  showAnnouncements(t) {
    let e = !0;
    for (let i of t)
      for (let s of i.effects)
        if (s.is(it.announce)) {
          e && (this.announceDOM.textContent = ""), e = !1;
          let a = this.announceDOM.appendChild(document.createElement("div"));
          a.textContent = s.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(Sa);
    let t = this.state.facet(it.cspNonce);
    cl.mount(this.root, this.styleModules.concat(TP).reverse(), t ? { nonce: t } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(t) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), t) {
      if (this.measureRequests.indexOf(t) > -1)
        return;
      if (t.key != null) {
        for (let e = 0; e < this.measureRequests.length; e++)
          if (this.measureRequests[e].key === t.key) {
            this.measureRequests[e] = t;
            return;
          }
      }
      this.measureRequests.push(t);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(t) {
    let e = this.pluginMap.get(t);
    return (e === void 0 || e && e.spec != t) && this.pluginMap.set(t, e = this.plugins.find((i) => i.spec == t) || null), e && e.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(t) {
    return this.readMeasured(), this.viewState.elementAtHeight(t);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(t) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(t);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(t) {
    return this.viewState.lineBlockAt(t);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(t, e, i) {
    return PO(this, t, XS(this, t, e, i));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(t, e) {
    return PO(this, t, XS(this, t, e, (i) => U2(this, t.head, i)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(t, e) {
    let i = this.bidiSpans(t), s = this.textDirectionAt(t.from), a = i[e ? i.length - 1 : 0];
    return j.cursor(a.side(e, s) + t.from, a.forward(!e, s) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(t, e, i = !0) {
    return Y2(this, t, e, i);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(t, e, i) {
    return PO(this, t, j2(this, t, e, i));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(t) {
    return this.docView.domAtPos(t);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(t, e = 0) {
    return this.docView.posFromDOM(t, e);
  }
  posAtCoords(t, e = !0) {
    return this.readMeasured(), ab(this, t, e);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(t, e = 1) {
    this.readMeasured();
    let i = this.docView.coordsAt(t, e);
    if (!i || i.left == i.right)
      return i;
    let s = this.state.doc.lineAt(t), a = this.bidiSpans(s), o = a[rl.find(a, t - s.from, -1, e)];
    return Ha(i, o.dir == Bt.LTR == e > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(t) {
    return this.readMeasured(), this.docView.coordsForChar(t);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(t) {
    return !this.state.facet(Iv) || t < this.viewport.from || t > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(t));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(t) {
    if (t.length > MP)
      return Lv(t.length);
    let e = this.textDirectionAt(t.from), i;
    for (let a of this.bidiCache)
      if (a.from == t.from && a.dir == e && (a.fresh || jv(a.isolates, i = AS(this, t))))
        return a.order;
    i || (i = AS(this, t));
    let s = w2(t.text, e, i);
    return this.bidiCache.push(new yu(t.from, t.to, e, i, !0, s)), s;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var t;
    return (this.dom.ownerDocument.hasFocus() || st.safari && ((t = this.inputState) === null || t === void 0 ? void 0 : t.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      $v(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(t) {
    this._root != t && (this._root = t, this.observer.setWindow((t.nodeType == 9 ? t : t.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let t of this.plugins)
      t.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(t, e = {}) {
    return $c.of(new Ws(typeof t == "number" ? j.cursor(t) : t, e.y, e.x, e.yMargin, e.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: t, scrollLeft: e } = this.scrollDOM, i = this.viewState.scrollAnchorAt(t);
    return $c.of(new Ws(j.cursor(i.from), "start", "start", i.top - t, e, !0));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(t) {
    t == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof t == "boolean" ? this.inputState.tabFocusMode = t ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + t);
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(t) {
    return ne.define(() => ({}), { eventHandlers: t });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(t) {
    return ne.define(() => ({}), { eventObservers: t });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(t, e) {
    let i = cl.newName(), s = [Cc.of(i), Sa.of(Vd(`.${i}`, t))];
    return e && e.dark && s.push(zd.of(!0)), s;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(t) {
    return dl.lowest(Sa.of(Vd("." + Dd, t, Qb)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(t) {
    var e;
    let i = t.querySelector(".cm-content"), s = i && Ut.get(i) || Ut.get(t);
    return ((e = s == null ? void 0 : s.rootView) === null || e === void 0 ? void 0 : e.view) || null;
  }
}
it.styleModule = Sa;
it.inputHandler = Kv;
it.clipboardInputFilter = Sp;
it.clipboardOutputFilter = Qp;
it.scrollHandler = tb;
it.focusChangeEffect = Jv;
it.perLineTextDirection = Iv;
it.exceptionSink = Hv;
it.updateListener = Zd;
it.editable = xn;
it.mouseSelectionStyle = Wv;
it.dragMovesSelection = Nv;
it.clickAddsSelectionRange = Gv;
it.decorations = Za;
it.outerDecorations = nb;
it.atomicRanges = bp;
it.bidiIsolatedRanges = lb;
it.scrollMargins = sb;
it.darkTheme = zd;
it.cspNonce = /* @__PURE__ */ lt.define({ combine: (n) => n.length ? n[0] : "" });
it.contentAttributes = vp;
it.editorAttributes = ib;
it.lineWrapping = /* @__PURE__ */ it.contentAttributes.of({ class: "cm-lineWrapping" });
it.announce = /* @__PURE__ */ yt.define();
const MP = 4096, t1 = {};
class yu {
  constructor(t, e, i, s, a, o) {
    this.from = t, this.to = e, this.dir = i, this.isolates = s, this.fresh = a, this.order = o;
  }
  static update(t, e) {
    if (e.empty && !t.some((a) => a.fresh))
      return t;
    let i = [], s = t.length ? t[t.length - 1].dir : Bt.LTR;
    for (let a = Math.max(0, t.length - 10); a < t.length; a++) {
      let o = t[a];
      o.dir == s && !e.touchesRange(o.from, o.to) && i.push(new yu(e.mapPos(o.from, 1), e.mapPos(o.to, -1), o.dir, o.isolates, !1, o.order));
    }
    return i;
  }
}
function e1(n, t, e) {
  for (let i = n.state.facet(t), s = i.length - 1; s >= 0; s--) {
    let a = i[s], o = typeof a == "function" ? a(n) : a;
    o && Pd(o, e);
  }
  return e;
}
const qP = st.mac ? "mac" : st.windows ? "win" : st.linux ? "linux" : "key";
function CP(n, t) {
  const e = n.split(/-(?!$)/);
  let i = e[e.length - 1];
  i == "Space" && (i = " ");
  let s, a, o, u;
  for (let h = 0; h < e.length - 1; ++h) {
    const d = e[h];
    if (/^(cmd|meta|m)$/i.test(d))
      u = !0;
    else if (/^a(lt)?$/i.test(d))
      s = !0;
    else if (/^(c|ctrl|control)$/i.test(d))
      a = !0;
    else if (/^s(hift)?$/i.test(d))
      o = !0;
    else if (/^mod$/i.test(d))
      t == "mac" ? u = !0 : a = !0;
    else
      throw new Error("Unrecognized modifier name: " + d);
  }
  return s && (i = "Alt-" + i), a && (i = "Ctrl-" + i), u && (i = "Meta-" + i), o && (i = "Shift-" + i), i;
}
function Zc(n, t, e) {
  return t.altKey && (n = "Alt-" + n), t.ctrlKey && (n = "Ctrl-" + n), t.metaKey && (n = "Meta-" + n), e !== !1 && t.shiftKey && (n = "Shift-" + n), n;
}
const ZP = /* @__PURE__ */ dl.default(/* @__PURE__ */ it.domEventHandlers({
  keydown(n, t) {
    return bb(vb(t.state), n, t, "editor");
  }
})), Jl = /* @__PURE__ */ lt.define({ enables: ZP }), i1 = /* @__PURE__ */ new WeakMap();
function vb(n) {
  let t = n.facet(Jl), e = i1.get(t);
  return e || i1.set(t, e = _P(t.reduce((i, s) => i.concat(s), []))), e;
}
function EP(n, t, e) {
  return bb(vb(n.state), t, n, e);
}
let nl = null;
const XP = 4e3;
function _P(n, t = qP) {
  let e = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null), s = (o, u) => {
    let h = i[o];
    if (h == null)
      i[o] = u;
    else if (h != u)
      throw new Error("Key binding " + o + " is used both as a regular binding and as a multi-stroke prefix");
  }, a = (o, u, h, d, p) => {
    var g, y;
    let Q = e[o] || (e[o] = /* @__PURE__ */ Object.create(null)), b = u.split(/ (?!$)/).map((A) => CP(A, t));
    for (let A = 1; A < b.length; A++) {
      let V = b.slice(0, A).join(" ");
      s(V, !0), Q[V] || (Q[V] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(G) => {
          let H = nl = { view: G, prefix: V, scope: o };
          return setTimeout(() => {
            nl == H && (nl = null);
          }, XP), !0;
        }]
      });
    }
    let x = b.join(" ");
    s(x, !1);
    let P = Q[x] || (Q[x] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((y = (g = Q._any) === null || g === void 0 ? void 0 : g.run) === null || y === void 0 ? void 0 : y.slice()) || []
    });
    h && P.run.push(h), d && (P.preventDefault = !0), p && (P.stopPropagation = !0);
  };
  for (let o of n) {
    let u = o.scope ? o.scope.split(" ") : ["editor"];
    if (o.any)
      for (let d of u) {
        let p = e[d] || (e[d] = /* @__PURE__ */ Object.create(null));
        p._any || (p._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: g } = o;
        for (let y in p)
          p[y].run.push((Q) => g(Q, Yd));
      }
    let h = o[t] || o.key;
    if (h)
      for (let d of u)
        a(d, h, o.run, o.preventDefault, o.stopPropagation), o.shift && a(d, "Shift-" + h, o.shift, o.preventDefault, o.stopPropagation);
  }
  return e;
}
let Yd = null;
function bb(n, t, e, i) {
  Yd = t;
  let s = s2(t), a = Ue(s, 0), o = Li(a) == s.length && s != " ", u = "", h = !1, d = !1, p = !1;
  nl && nl.view == e && nl.scope == i && (u = nl.prefix + " ", ub.indexOf(t.keyCode) < 0 && (d = !0, nl = null));
  let g = /* @__PURE__ */ new Set(), y = (P) => {
    if (P) {
      for (let A of P.run)
        if (!g.has(A) && (g.add(A), A(e)))
          return P.stopPropagation && (p = !0), !0;
      P.preventDefault && (P.stopPropagation && (p = !0), d = !0);
    }
    return !1;
  }, Q = n[i], b, x;
  return Q && (y(Q[u + Zc(s, t, !o)]) ? h = !0 : o && (t.altKey || t.metaKey || t.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(st.windows && t.ctrlKey && t.altKey) && (b = ul[t.keyCode]) && b != s ? (y(Q[u + Zc(b, t, !0)]) || t.shiftKey && (x = qa[t.keyCode]) != s && x != b && y(Q[u + Zc(x, t, !1)])) && (h = !0) : o && t.shiftKey && y(Q[u + Zc(s, t, !0)]) && (h = !0), !h && y(Q._any) && (h = !0)), d && (h = !0), h && p && t.stopPropagation(), Yd = null, h;
}
class Ia {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(t, e, i, s, a) {
    this.className = t, this.left = e, this.top = i, this.width = s, this.height = a;
  }
  draw() {
    let t = document.createElement("div");
    return t.className = this.className, this.adjust(t), t;
  }
  update(t, e) {
    return e.className != this.className ? !1 : (this.adjust(t), !0);
  }
  adjust(t) {
    t.style.left = this.left + "px", t.style.top = this.top + "px", this.width != null && (t.style.width = this.width + "px"), t.style.height = this.height + "px";
  }
  eq(t) {
    return this.left == t.left && this.top == t.top && this.width == t.width && this.height == t.height && this.className == t.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(t, e, i) {
    if (i.empty) {
      let s = t.coordsAtPos(i.head, i.assoc || 1);
      if (!s)
        return [];
      let a = xb(t);
      return [new Ia(e, s.left - a.left, s.top - a.top, null, s.bottom - s.top)];
    } else
      return zP(t, e, i);
  }
}
function xb(n) {
  let t = n.scrollDOM.getBoundingClientRect();
  return { left: (n.textDirection == Bt.LTR ? t.left : t.right - n.scrollDOM.clientWidth * n.scaleX) - n.scrollDOM.scrollLeft * n.scaleX, top: t.top - n.scrollDOM.scrollTop * n.scaleY };
}
function n1(n, t, e, i) {
  let s = n.coordsAtPos(t, e * 2);
  if (!s)
    return i;
  let a = n.dom.getBoundingClientRect(), o = (s.top + s.bottom) / 2, u = n.posAtCoords({ x: a.left + 1, y: o }), h = n.posAtCoords({ x: a.right - 1, y: o });
  return u == null || h == null ? i : { from: Math.max(i.from, Math.min(u, h)), to: Math.min(i.to, Math.max(u, h)) };
}
function zP(n, t, e) {
  if (e.to <= n.viewport.from || e.from >= n.viewport.to)
    return [];
  let i = Math.max(e.from, n.viewport.from), s = Math.min(e.to, n.viewport.to), a = n.textDirection == Bt.LTR, o = n.contentDOM, u = o.getBoundingClientRect(), h = xb(n), d = o.querySelector(".cm-line"), p = d && window.getComputedStyle(d), g = u.left + (p ? parseInt(p.paddingLeft) + Math.min(0, parseInt(p.textIndent)) : 0), y = u.right - (p ? parseInt(p.paddingRight) : 0), Q = Xd(n, i, 1), b = Xd(n, s, -1), x = Q.type == Ee.Text ? Q : null, P = b.type == Ee.Text ? b : null;
  if (x && (n.lineWrapping || Q.widgetLineBreaks) && (x = n1(n, i, 1, x)), P && (n.lineWrapping || b.widgetLineBreaks) && (P = n1(n, s, -1, P)), x && P && x.from == P.from && x.to == P.to)
    return V(G(e.from, e.to, x));
  {
    let _ = x ? G(e.from, null, x) : H(Q, !1), W = P ? G(null, e.to, P) : H(b, !0), q = [];
    return (x || Q).to < (P || b).from - (x && P ? 1 : 0) || Q.widgetLineBreaks > 1 && _.bottom + n.defaultLineHeight / 2 < W.top ? q.push(A(g, _.bottom, y, W.top)) : _.bottom < W.top && n.elementAtHeight((_.bottom + W.top) / 2).type == Ee.Text && (_.bottom = W.top = (_.bottom + W.top) / 2), V(_).concat(q).concat(V(W));
  }
  function A(_, W, q, J) {
    return new Ia(t, _ - h.left, W - h.top, q - _, J - W);
  }
  function V({ top: _, bottom: W, horizontal: q }) {
    let J = [];
    for (let N = 0; N < q.length; N += 2)
      J.push(A(q[N], _, q[N + 1], W));
    return J;
  }
  function G(_, W, q) {
    let J = 1e9, N = -1e9, I = [];
    function K(at, ht, E, z, nt) {
      let Ot = n.coordsAtPos(at, at == q.to ? -2 : 2), T = n.coordsAtPos(E, E == q.from ? 2 : -2);
      !Ot || !T || (J = Math.min(Ot.top, T.top, J), N = Math.max(Ot.bottom, T.bottom, N), nt == Bt.LTR ? I.push(a && ht ? g : Ot.left, a && z ? y : T.right) : I.push(!a && z ? g : T.left, !a && ht ? y : Ot.right));
    }
    let Y = _ ?? q.from, ot = W ?? q.to;
    for (let at of n.visibleRanges)
      if (at.to > Y && at.from < ot)
        for (let ht = Math.max(at.from, Y), E = Math.min(at.to, ot); ; ) {
          let z = n.state.doc.lineAt(ht);
          for (let nt of n.bidiSpans(z)) {
            let Ot = nt.from + z.from, T = nt.to + z.from;
            if (Ot >= E)
              break;
            T > ht && K(Math.max(Ot, ht), _ == null && Ot <= Y, Math.min(T, E), W == null && T >= ot, nt.dir);
          }
          if (ht = z.to + 1, ht >= E)
            break;
        }
    return I.length == 0 && K(Y, _ == null, ot, W == null, n.textDirection), { top: J, bottom: N, horizontal: I };
  }
  function H(_, W) {
    let q = u.top + (W ? _.top : _.bottom);
    return { top: q, bottom: q, horizontal: [] };
  }
}
function DP(n, t) {
  return n.constructor == t.constructor && n.eq(t);
}
class VP {
  constructor(t, e) {
    this.view = t, this.layer = e, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = t.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), e.above && this.dom.classList.add("cm-layer-above"), e.class && this.dom.classList.add(e.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(t.state), t.requestMeasure(this.measureReq), e.mount && e.mount(this.dom, t);
  }
  update(t) {
    t.startState.facet(tu) != t.state.facet(tu) && this.setOrder(t.state), (this.layer.update(t, this.dom) || t.geometryChanged) && (this.scale(), t.view.requestMeasure(this.measureReq));
  }
  docViewUpdate(t) {
    this.layer.updateOnDocViewUpdate !== !1 && t.requestMeasure(this.measureReq);
  }
  setOrder(t) {
    let e = 0, i = t.facet(tu);
    for (; e < i.length && i[e] != this.layer; )
      e++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - e);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: t, scaleY: e } = this.view;
    (t != this.scaleX || e != this.scaleY) && (this.scaleX = t, this.scaleY = e, this.dom.style.transform = `scale(${1 / t}, ${1 / e})`);
  }
  draw(t) {
    if (t.length != this.drawn.length || t.some((e, i) => !DP(e, this.drawn[i]))) {
      let e = this.dom.firstChild, i = 0;
      for (let s of t)
        s.update && e && s.constructor && this.drawn[i].constructor && s.update(e, this.drawn[i]) ? (e = e.nextSibling, i++) : this.dom.insertBefore(s.draw(), e);
      for (; e; ) {
        let s = e.nextSibling;
        e.remove(), e = s;
      }
      this.drawn = t;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const tu = /* @__PURE__ */ lt.define();
function kb(n) {
  return [
    ne.define((t) => new VP(t, n)),
    tu.of(n)
  ];
}
const Ea = /* @__PURE__ */ lt.define({
  combine(n) {
    return Fi(n, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (t, e) => Math.min(t, e),
      drawRangeCursor: (t, e) => t || e
    });
  }
});
function YP(n = {}) {
  return [
    Ea.of(n),
    UP,
    jP,
    LP,
    Fv.of(!0)
  ];
}
function wb(n) {
  return n.startState.facet(Ea) != n.state.facet(Ea);
}
const UP = /* @__PURE__ */ kb({
  above: !0,
  markers(n) {
    let { state: t } = n, e = t.facet(Ea), i = [];
    for (let s of t.selection.ranges) {
      let a = s == t.selection.main;
      if (s.empty || e.drawRangeCursor) {
        let o = a ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", u = s.empty ? s : j.cursor(s.head, s.head > s.anchor ? -1 : 1);
        for (let h of Ia.forRange(n, o, u))
          i.push(h);
      }
    }
    return i;
  },
  update(n, t) {
    n.transactions.some((i) => i.selection) && (t.style.animationName = t.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let e = wb(n);
    return e && l1(n.state, t), n.docChanged || n.selectionSet || e;
  },
  mount(n, t) {
    l1(t.state, n);
  },
  class: "cm-cursorLayer"
});
function l1(n, t) {
  t.style.animationDuration = n.facet(Ea).cursorBlinkRate + "ms";
}
const jP = /* @__PURE__ */ kb({
  above: !1,
  markers(n) {
    return n.state.selection.ranges.map((t) => t.empty ? [] : Ia.forRange(n, "cm-selectionBackground", t)).reduce((t, e) => t.concat(e));
  },
  update(n, t) {
    return n.docChanged || n.selectionSet || n.viewportChanged || wb(n);
  },
  class: "cm-selectionLayer"
}), LP = /* @__PURE__ */ dl.highest(/* @__PURE__ */ it.theme({
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" },
    caretColor: "transparent !important"
  },
  ".cm-content": {
    caretColor: "transparent !important",
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
})), Tb = /* @__PURE__ */ yt.define({
  map(n, t) {
    return n == null ? null : t.mapPos(n);
  }
}), ba = /* @__PURE__ */ Se.define({
  create() {
    return null;
  },
  update(n, t) {
    return n != null && (n = t.changes.mapPos(n)), t.effects.reduce((e, i) => i.is(Tb) ? i.value : e, n);
  }
}), BP = /* @__PURE__ */ ne.fromClass(class {
  constructor(n) {
    this.view = n, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(n) {
    var t;
    let e = n.state.field(ba);
    e == null ? this.cursor != null && ((t = this.cursor) === null || t === void 0 || t.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (n.startState.field(ba) != e || n.docChanged || n.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: n } = this, t = n.state.field(ba), e = t != null && n.coordsAtPos(t);
    if (!e)
      return null;
    let i = n.scrollDOM.getBoundingClientRect();
    return {
      left: e.left - i.left + n.scrollDOM.scrollLeft * n.scaleX,
      top: e.top - i.top + n.scrollDOM.scrollTop * n.scaleY,
      height: e.bottom - e.top
    };
  }
  drawCursor(n) {
    if (this.cursor) {
      let { scaleX: t, scaleY: e } = this.view;
      n ? (this.cursor.style.left = n.left / t + "px", this.cursor.style.top = n.top / e + "px", this.cursor.style.height = n.height / e + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(n) {
    this.view.state.field(ba) != n && this.view.dispatch({ effects: Tb.of(n) });
  }
}, {
  eventObservers: {
    dragover(n) {
      this.setDropPos(this.view.posAtCoords({ x: n.clientX, y: n.clientY }));
    },
    dragleave(n) {
      (n.target == this.view.contentDOM || !this.view.contentDOM.contains(n.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function GP() {
  return [ba, BP];
}
function s1(n, t, e, i, s) {
  t.lastIndex = 0;
  for (let a = n.iterRange(e, i), o = e, u; !a.next().done; o += a.value.length)
    if (!a.lineBreak)
      for (; u = t.exec(a.value); )
        s(o + u.index, u);
}
function NP(n, t) {
  let e = n.visibleRanges;
  if (e.length == 1 && e[0].from == n.viewport.from && e[0].to == n.viewport.to)
    return e;
  let i = [];
  for (let { from: s, to: a } of e)
    s = Math.max(n.state.doc.lineAt(s).from, s - t), a = Math.min(n.state.doc.lineAt(a).to, a + t), i.length && i[i.length - 1].to >= s ? i[i.length - 1].to = a : i.push({ from: s, to: a });
  return i;
}
class WP {
  /**
  Create a decorator.
  */
  constructor(t) {
    const { regexp: e, decoration: i, decorate: s, boundary: a, maxLength: o = 1e3 } = t;
    if (!e.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = e, s)
      this.addMatch = (u, h, d, p) => s(p, d, d + u[0].length, u, h);
    else if (typeof i == "function")
      this.addMatch = (u, h, d, p) => {
        let g = i(u, h, d);
        g && p(d, d + u[0].length, g);
      };
    else if (i)
      this.addMatch = (u, h, d, p) => p(d, d + u[0].length, i);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = a, this.maxLength = o;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(t) {
    let e = new Tn(), i = e.add.bind(e);
    for (let { from: s, to: a } of NP(t, this.maxLength))
      s1(t.state.doc, this.regexp, s, a, (o, u) => this.addMatch(u, t, o, i));
    return e.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(t, e) {
    let i = 1e9, s = -1;
    return t.docChanged && t.changes.iterChanges((a, o, u, h) => {
      h >= t.view.viewport.from && u <= t.view.viewport.to && (i = Math.min(u, i), s = Math.max(h, s));
    }), t.viewportMoved || s - i > 1e3 ? this.createDeco(t.view) : s > -1 ? this.updateRange(t.view, e.map(t.changes), i, s) : e;
  }
  updateRange(t, e, i, s) {
    for (let a of t.visibleRanges) {
      let o = Math.max(a.from, i), u = Math.min(a.to, s);
      if (u >= o) {
        let h = t.state.doc.lineAt(o), d = h.to < u ? t.state.doc.lineAt(u) : h, p = Math.max(a.from, h.from), g = Math.min(a.to, d.to);
        if (this.boundary) {
          for (; o > h.from; o--)
            if (this.boundary.test(h.text[o - 1 - h.from])) {
              p = o;
              break;
            }
          for (; u < d.to; u++)
            if (this.boundary.test(d.text[u - d.from])) {
              g = u;
              break;
            }
        }
        let y = [], Q, b = (x, P, A) => y.push(A.range(x, P));
        if (h == d)
          for (this.regexp.lastIndex = p - h.from; (Q = this.regexp.exec(h.text)) && Q.index < g - h.from; )
            this.addMatch(Q, t, Q.index + h.from, b);
        else
          s1(t.state.doc, this.regexp, p, g, (x, P) => this.addMatch(P, t, x, b));
        e = e.update({ filterFrom: p, filterTo: g, filter: (x, P) => x < p || P > g, add: y });
      }
    }
    return e;
  }
}
const Ud = /x/.unicode != null ? "gu" : "g", HP = /* @__PURE__ */ new RegExp(`[\0-\b
--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]`, Ud), KP = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let MO = null;
function JP() {
  var n;
  if (MO == null && typeof document < "u" && document.body) {
    let t = document.body.style;
    MO = ((n = t.tabSize) !== null && n !== void 0 ? n : t.MozTabSize) != null;
  }
  return MO || !1;
}
const eu = /* @__PURE__ */ lt.define({
  combine(n) {
    let t = Fi(n, {
      render: null,
      specialChars: HP,
      addSpecialChars: null
    });
    return (t.replaceTabs = !JP()) && (t.specialChars = new RegExp("	|" + t.specialChars.source, Ud)), t.addSpecialChars && (t.specialChars = new RegExp(t.specialChars.source + "|" + t.addSpecialChars.source, Ud)), t;
  }
});
function IP(n = {}) {
  return [eu.of(n), FP()];
}
let r1 = null;
function FP() {
  return r1 || (r1 = ne.fromClass(class {
    constructor(n) {
      this.view = n, this.decorations = ft.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(n.state.facet(eu)), this.decorations = this.decorator.createDeco(n);
    }
    makeDecorator(n) {
      return new WP({
        regexp: n.specialChars,
        decoration: (t, e, i) => {
          let { doc: s } = e.state, a = Ue(t[0], 0);
          if (a == 9) {
            let o = s.lineAt(i), u = e.state.tabSize, h = rr(o.text, u, i - o.from);
            return ft.replace({
              widget: new nR((u - h % u) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[a] || (this.decorationCache[a] = ft.replace({ widget: new iR(n, a) }));
        },
        boundary: n.replaceTabs ? void 0 : /[^]/
      });
    }
    update(n) {
      let t = n.state.facet(eu);
      n.startState.facet(eu) != t ? (this.decorator = this.makeDecorator(t), this.decorations = this.decorator.createDeco(n.view)) : this.decorations = this.decorator.updateDeco(n, this.decorations);
    }
  }, {
    decorations: (n) => n.decorations
  }));
}
const tR = "•";
function eR(n) {
  return n >= 32 ? tR : n == 10 ? "␤" : String.fromCharCode(9216 + n);
}
class iR extends tn {
  constructor(t, e) {
    super(), this.options = t, this.code = e;
  }
  eq(t) {
    return t.code == this.code;
  }
  toDOM(t) {
    let e = eR(this.code), i = t.state.phrase("Control character") + " " + (KP[this.code] || "0x" + this.code.toString(16)), s = this.options.render && this.options.render(this.code, i, e);
    if (s)
      return s;
    let a = document.createElement("span");
    return a.textContent = e, a.title = i, a.setAttribute("aria-label", i), a.className = "cm-specialChar", a;
  }
  ignoreEvent() {
    return !1;
  }
}
class nR extends tn {
  constructor(t) {
    super(), this.width = t;
  }
  eq(t) {
    return t.width == this.width;
  }
  toDOM() {
    let t = document.createElement("span");
    return t.textContent = "	", t.className = "cm-tab", t.style.width = this.width + "px", t;
  }
  ignoreEvent() {
    return !1;
  }
}
function lR() {
  return rR;
}
const sR = /* @__PURE__ */ ft.line({ class: "cm-activeLine" }), rR = /* @__PURE__ */ ne.fromClass(class {
  constructor(n) {
    this.decorations = this.getDeco(n);
  }
  update(n) {
    (n.docChanged || n.selectionSet) && (this.decorations = this.getDeco(n.view));
  }
  getDeco(n) {
    let t = -1, e = [];
    for (let i of n.state.selection.ranges) {
      let s = n.lineBlockAt(i.head);
      s.from > t && (e.push(sR.range(s.from)), t = s.from);
    }
    return ft.set(e);
  }
}, {
  decorations: (n) => n.decorations
});
class aR extends tn {
  constructor(t) {
    super(), this.content = t;
  }
  toDOM(t) {
    let e = document.createElement("span");
    return e.className = "cm-placeholder", e.style.pointerEvents = "none", e.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : typeof this.content == "function" ? this.content(t) : this.content.cloneNode(!0)), e.setAttribute("aria-hidden", "true"), e;
  }
  coordsAt(t) {
    let e = t.firstChild ? Fs(t.firstChild) : [];
    if (!e.length)
      return null;
    let i = window.getComputedStyle(t.parentNode), s = Ha(e[0], i.direction != "rtl"), a = parseInt(i.lineHeight);
    return s.bottom - s.top > a * 1.5 ? { left: s.left, right: s.right, top: s.top, bottom: s.top + a } : s;
  }
  ignoreEvent() {
    return !1;
  }
}
function oR(n) {
  let t = ne.fromClass(class {
    constructor(e) {
      this.view = e, this.placeholder = n ? ft.set([ft.widget({ widget: new aR(n), side: 1 }).range(0)]) : ft.none;
    }
    get decorations() {
      return this.view.state.doc.length ? ft.none : this.placeholder;
    }
  }, { decorations: (e) => e.decorations });
  return typeof n == "string" ? [
    t,
    it.contentAttributes.of({ "aria-placeholder": n })
  ] : t;
}
const jd = 2e3;
function cR(n, t, e) {
  let i = Math.min(t.line, e.line), s = Math.max(t.line, e.line), a = [];
  if (t.off > jd || e.off > jd || t.col < 0 || e.col < 0) {
    let o = Math.min(t.off, e.off), u = Math.max(t.off, e.off);
    for (let h = i; h <= s; h++) {
      let d = n.doc.line(h);
      d.length <= u && a.push(j.range(d.from + o, d.to + u));
    }
  } else {
    let o = Math.min(t.col, e.col), u = Math.max(t.col, e.col);
    for (let h = i; h <= s; h++) {
      let d = n.doc.line(h), p = vd(d.text, o, n.tabSize, !0);
      if (p < 0)
        a.push(j.cursor(d.to));
      else {
        let g = vd(d.text, u, n.tabSize);
        a.push(j.range(d.from + p, d.from + g));
      }
    }
  }
  return a;
}
function uR(n, t) {
  let e = n.coordsAtPos(n.viewport.from);
  return e ? Math.round(Math.abs((e.left - t) / n.defaultCharacterWidth)) : -1;
}
function a1(n, t) {
  let e = n.posAtCoords({ x: t.clientX, y: t.clientY }, !1), i = n.state.doc.lineAt(e), s = e - i.from, a = s > jd ? -1 : s == i.length ? uR(n, t.clientX) : rr(i.text, n.state.tabSize, e - i.from);
  return { line: i.number, col: a, off: s };
}
function fR(n, t) {
  let e = a1(n, t), i = n.state.selection;
  return e ? {
    update(s) {
      if (s.docChanged) {
        let a = s.changes.mapPos(s.startState.doc.line(e.line).from), o = s.state.doc.lineAt(a);
        e = { line: o.number, col: e.col, off: Math.min(e.off, o.length) }, i = i.map(s.changes);
      }
    },
    get(s, a, o) {
      let u = a1(n, s);
      if (!u)
        return i;
      let h = cR(n.state, e, u);
      return h.length ? o ? j.create(h.concat(i.ranges)) : j.create(h) : i;
    }
  } : null;
}
function hR(n) {
  let t = (e) => e.altKey && e.button == 0;
  return it.mouseSelectionStyle.of((e, i) => t(i) ? fR(e, i) : null);
}
const OR = {
  Alt: [18, (n) => !!n.altKey],
  Control: [17, (n) => !!n.ctrlKey],
  Shift: [16, (n) => !!n.shiftKey],
  Meta: [91, (n) => !!n.metaKey]
}, dR = { style: "cursor: crosshair" };
function pR(n = {}) {
  let [t, e] = OR[n.key || "Alt"], i = ne.fromClass(class {
    constructor(s) {
      this.view = s, this.isDown = !1;
    }
    set(s) {
      this.isDown != s && (this.isDown = s, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(s) {
        this.set(s.keyCode == t || e(s));
      },
      keyup(s) {
        (s.keyCode == t || !e(s)) && this.set(!1);
      },
      mousemove(s) {
        this.set(e(s));
      }
    }
  });
  return [
    i,
    it.contentAttributes.of((s) => {
      var a;
      return !((a = s.plugin(i)) === null || a === void 0) && a.isDown ? dR : null;
    })
  ];
}
const fa = "-10000px";
class $b {
  constructor(t, e, i, s) {
    this.facet = e, this.createTooltipView = i, this.removeTooltipView = s, this.input = t.state.facet(e), this.tooltips = this.input.filter((o) => o);
    let a = null;
    this.tooltipViews = this.tooltips.map((o) => a = i(o, a));
  }
  update(t, e) {
    var i;
    let s = t.state.facet(this.facet), a = s.filter((h) => h);
    if (s === this.input) {
      for (let h of this.tooltipViews)
        h.update && h.update(t);
      return !1;
    }
    let o = [], u = e ? [] : null;
    for (let h = 0; h < a.length; h++) {
      let d = a[h], p = -1;
      if (d) {
        for (let g = 0; g < this.tooltips.length; g++) {
          let y = this.tooltips[g];
          y && y.create == d.create && (p = g);
        }
        if (p < 0)
          o[h] = this.createTooltipView(d, h ? o[h - 1] : null), u && (u[h] = !!d.above);
        else {
          let g = o[h] = this.tooltipViews[p];
          u && (u[h] = e[p]), g.update && g.update(t);
        }
      }
    }
    for (let h of this.tooltipViews)
      o.indexOf(h) < 0 && (this.removeTooltipView(h), (i = h.destroy) === null || i === void 0 || i.call(h));
    return e && (u.forEach((h, d) => e[d] = h), e.length = u.length), this.input = s, this.tooltips = a, this.tooltipViews = o, !0;
  }
}
function mR(n) {
  let t = n.dom.ownerDocument.documentElement;
  return { top: 0, left: 0, bottom: t.clientHeight, right: t.clientWidth };
}
const qO = /* @__PURE__ */ lt.define({
  combine: (n) => {
    var t, e, i;
    return {
      position: st.ios ? "absolute" : ((t = n.find((s) => s.position)) === null || t === void 0 ? void 0 : t.position) || "fixed",
      parent: ((e = n.find((s) => s.parent)) === null || e === void 0 ? void 0 : e.parent) || null,
      tooltipSpace: ((i = n.find((s) => s.tooltipSpace)) === null || i === void 0 ? void 0 : i.tooltipSpace) || mR
    };
  }
}), o1 = /* @__PURE__ */ new WeakMap(), $p = /* @__PURE__ */ ne.fromClass(class {
  constructor(n) {
    this.view = n, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let t = n.state.facet(qO);
    this.position = t.position, this.parent = t.parent, this.classes = n.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new $b(n, Pp, (e, i) => this.createTooltip(e, i), (e) => {
      this.resizeObserver && this.resizeObserver.unobserve(e.dom), e.dom.remove();
    }), this.above = this.manager.tooltips.map((e) => !!e.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((e) => {
      Date.now() > this.lastTransaction - 50 && e.length > 0 && e[e.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), n.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let n of this.manager.tooltipViews)
        this.intersectionObserver.observe(n.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(n) {
    n.transactions.length && (this.lastTransaction = Date.now());
    let t = this.manager.update(n, this.above);
    t && this.observeIntersection();
    let e = t || n.geometryChanged, i = n.state.facet(qO);
    if (i.position != this.position && !this.madeAbsolute) {
      this.position = i.position;
      for (let s of this.manager.tooltipViews)
        s.dom.style.position = this.position;
      e = !0;
    }
    if (i.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = i.parent, this.createContainer();
      for (let s of this.manager.tooltipViews)
        this.container.appendChild(s.dom);
      e = !0;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    e && this.maybeMeasure();
  }
  createTooltip(n, t) {
    let e = n.create(this.view), i = t ? t.dom : null;
    if (e.dom.classList.add("cm-tooltip"), n.arrow && !e.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let s = document.createElement("div");
      s.className = "cm-tooltip-arrow", e.dom.appendChild(s);
    }
    return e.dom.style.position = this.position, e.dom.style.top = fa, e.dom.style.left = "0px", this.container.insertBefore(e.dom, i), e.mount && e.mount(this.view), this.resizeObserver && this.resizeObserver.observe(e.dom), e;
  }
  destroy() {
    var n, t, e;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let i of this.manager.tooltipViews)
      i.dom.remove(), (n = i.destroy) === null || n === void 0 || n.call(i);
    this.parent && this.container.remove(), (t = this.resizeObserver) === null || t === void 0 || t.disconnect(), (e = this.intersectionObserver) === null || e === void 0 || e.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let n = 1, t = 1, e = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: a } = this.manager.tooltipViews[0];
      if (st.gecko)
        e = a.offsetParent != this.container.ownerDocument.body;
      else if (a.style.top == fa && a.style.left == "0px") {
        let o = a.getBoundingClientRect();
        e = Math.abs(o.top + 1e4) > 1 || Math.abs(o.left) > 1;
      }
    }
    if (e || this.position == "absolute")
      if (this.parent) {
        let a = this.parent.getBoundingClientRect();
        a.width && a.height && (n = a.width / this.parent.offsetWidth, t = a.height / this.parent.offsetHeight);
      } else
        ({ scaleX: n, scaleY: t } = this.view.viewState);
    let i = this.view.scrollDOM.getBoundingClientRect(), s = xp(this.view);
    return {
      visible: {
        left: i.left + s.left,
        top: i.top + s.top,
        right: i.right - s.right,
        bottom: i.bottom - s.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((a, o) => {
        let u = this.manager.tooltipViews[o];
        return u.getCoords ? u.getCoords(a.pos) : this.view.coordsAtPos(a.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: a }) => a.getBoundingClientRect()),
      space: this.view.state.facet(qO).tooltipSpace(this.view),
      scaleX: n,
      scaleY: t,
      makeAbsolute: e
    };
  }
  writeMeasure(n) {
    var t;
    if (n.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let u of this.manager.tooltipViews)
        u.dom.style.position = "absolute";
    }
    let { visible: e, space: i, scaleX: s, scaleY: a } = n, o = [];
    for (let u = 0; u < this.manager.tooltips.length; u++) {
      let h = this.manager.tooltips[u], d = this.manager.tooltipViews[u], { dom: p } = d, g = n.pos[u], y = n.size[u];
      if (!g || h.clip !== !1 && (g.bottom <= Math.max(e.top, i.top) || g.top >= Math.min(e.bottom, i.bottom) || g.right < Math.max(e.left, i.left) - 0.1 || g.left > Math.min(e.right, i.right) + 0.1)) {
        p.style.top = fa;
        continue;
      }
      let Q = h.arrow ? d.dom.querySelector(".cm-tooltip-arrow") : null, b = Q ? 7 : 0, x = y.right - y.left, P = (t = o1.get(d)) !== null && t !== void 0 ? t : y.bottom - y.top, A = d.offset || yR, V = this.view.textDirection == Bt.LTR, G = y.width > i.right - i.left ? V ? i.left : i.right - y.width : V ? Math.max(i.left, Math.min(g.left - (Q ? 14 : 0) + A.x, i.right - x)) : Math.min(Math.max(i.left, g.left - x + (Q ? 14 : 0) - A.x), i.right - x), H = this.above[u];
      !h.strictSide && (H ? g.top - P - b - A.y < i.top : g.bottom + P + b + A.y > i.bottom) && H == i.bottom - g.bottom > g.top - i.top && (H = this.above[u] = !H);
      let _ = (H ? g.top - i.top : i.bottom - g.bottom) - b;
      if (_ < P && d.resize !== !1) {
        if (_ < this.view.defaultLineHeight) {
          p.style.top = fa;
          continue;
        }
        o1.set(d, P), p.style.height = (P = _) / a + "px";
      } else p.style.height && (p.style.height = "");
      let W = H ? g.top - P - b - A.y : g.bottom + b + A.y, q = G + x;
      if (d.overlap !== !0)
        for (let J of o)
          J.left < q && J.right > G && J.top < W + P && J.bottom > W && (W = H ? J.top - P - 2 - b : J.bottom + b + 2);
      if (this.position == "absolute" ? (p.style.top = (W - n.parent.top) / a + "px", c1(p, (G - n.parent.left) / s)) : (p.style.top = W / a + "px", c1(p, G / s)), Q) {
        let J = g.left + (V ? A.x : -A.x) - (G + 14 - 7);
        Q.style.left = J / s + "px";
      }
      d.overlap !== !0 && o.push({ left: G, top: W, right: q, bottom: W + P }), p.classList.toggle("cm-tooltip-above", H), p.classList.toggle("cm-tooltip-below", !H), d.positioned && d.positioned(n.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let n of this.manager.tooltipViews)
        n.dom.style.top = fa;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function c1(n, t) {
  let e = parseInt(n.style.left, 10);
  (isNaN(e) || Math.abs(t - e) > 1) && (n.style.left = t + "px");
}
const gR = /* @__PURE__ */ it.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), yR = { x: 0, y: 0 }, Pp = /* @__PURE__ */ lt.define({
  enables: [$p, gR]
}), Su = /* @__PURE__ */ lt.define({
  combine: (n) => n.reduce((t, e) => t.concat(e), [])
});
class Yu {
  // Needs to be static so that host tooltip instances always match
  static create(t) {
    return new Yu(t);
  }
  constructor(t) {
    this.view = t, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new $b(t, Su, (e, i) => this.createHostedView(e, i), (e) => e.dom.remove());
  }
  createHostedView(t, e) {
    let i = t.create(this.view);
    return i.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(i.dom, e ? e.dom.nextSibling : this.dom.firstChild), this.mounted && i.mount && i.mount(this.view), i;
  }
  mount(t) {
    for (let e of this.manager.tooltipViews)
      e.mount && e.mount(t);
    this.mounted = !0;
  }
  positioned(t) {
    for (let e of this.manager.tooltipViews)
      e.positioned && e.positioned(t);
  }
  update(t) {
    this.manager.update(t);
  }
  destroy() {
    var t;
    for (let e of this.manager.tooltipViews)
      (t = e.destroy) === null || t === void 0 || t.call(e);
  }
  passProp(t) {
    let e;
    for (let i of this.manager.tooltipViews) {
      let s = i[t];
      if (s !== void 0) {
        if (e === void 0)
          e = s;
        else if (e !== s)
          return;
      }
    }
    return e;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const SR = /* @__PURE__ */ Pp.compute([Su], (n) => {
  let t = n.facet(Su);
  return t.length === 0 ? null : {
    pos: Math.min(...t.map((e) => e.pos)),
    end: Math.max(...t.map((e) => {
      var i;
      return (i = e.end) !== null && i !== void 0 ? i : e.pos;
    })),
    create: Yu.create,
    above: t[0].above,
    arrow: t.some((e) => e.arrow)
  };
});
class QR {
  constructor(t, e, i, s, a) {
    this.view = t, this.source = e, this.field = i, this.setHover = s, this.hoverTime = a, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: t.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), t.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), t.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let t = Date.now() - this.lastMove.time;
    t < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - t) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: t, lastMove: e } = this, i = t.docView.nearest(e.target);
    if (!i)
      return;
    let s, a = 1;
    if (i instanceof sl)
      s = i.posAtStart;
    else {
      if (s = t.posAtCoords(e), s == null)
        return;
      let u = t.coordsAtPos(s);
      if (!u || e.y < u.top || e.y > u.bottom || e.x < u.left - t.defaultCharacterWidth || e.x > u.right + t.defaultCharacterWidth)
        return;
      let h = t.bidiSpans(t.state.doc.lineAt(s)).find((p) => p.from <= s && p.to >= s), d = h && h.dir == Bt.RTL ? -1 : 1;
      a = e.x < u.left ? -d : d;
    }
    let o = this.source(t, s, a);
    if (o != null && o.then) {
      let u = this.pending = { pos: s };
      o.then((h) => {
        this.pending == u && (this.pending = null, h && !(Array.isArray(h) && !h.length) && t.dispatch({ effects: this.setHover.of(Array.isArray(h) ? h : [h]) }));
      }, (h) => Be(t.state, h, "hover tooltip"));
    } else o && !(Array.isArray(o) && !o.length) && t.dispatch({ effects: this.setHover.of(Array.isArray(o) ? o : [o]) });
  }
  get tooltip() {
    let t = this.view.plugin($p), e = t ? t.manager.tooltips.findIndex((i) => i.create == Yu.create) : -1;
    return e > -1 ? t.manager.tooltipViews[e] : null;
  }
  mousemove(t) {
    var e, i;
    this.lastMove = { x: t.clientX, y: t.clientY, target: t.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: s, tooltip: a } = this;
    if (s.length && a && !vR(a.dom, t) || this.pending) {
      let { pos: o } = s[0] || this.pending, u = (i = (e = s[0]) === null || e === void 0 ? void 0 : e.end) !== null && i !== void 0 ? i : o;
      (o == u ? this.view.posAtCoords(this.lastMove) != o : !bR(this.view, o, u, t.clientX, t.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(t) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: e } = this;
    if (e.length) {
      let { tooltip: i } = this;
      i && i.dom.contains(t.relatedTarget) ? this.watchTooltipLeave(i.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(t) {
    let e = (i) => {
      t.removeEventListener("mouseleave", e), this.active.length && !this.view.dom.contains(i.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    t.addEventListener("mouseleave", e);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const Ec = 4;
function vR(n, t) {
  let { left: e, right: i, top: s, bottom: a } = n.getBoundingClientRect(), o;
  if (o = n.querySelector(".cm-tooltip-arrow")) {
    let u = o.getBoundingClientRect();
    s = Math.min(u.top, s), a = Math.max(u.bottom, a);
  }
  return t.clientX >= e - Ec && t.clientX <= i + Ec && t.clientY >= s - Ec && t.clientY <= a + Ec;
}
function bR(n, t, e, i, s, a) {
  let o = n.scrollDOM.getBoundingClientRect(), u = n.documentTop + n.documentPadding.top + n.contentHeight;
  if (o.left > i || o.right < i || o.top > s || Math.min(o.bottom, u) < s)
    return !1;
  let h = n.posAtCoords({ x: i, y: s }, !1);
  return h >= t && h <= e;
}
function xR(n, t = {}) {
  let e = yt.define(), i = Se.define({
    create() {
      return [];
    },
    update(s, a) {
      if (s.length && (t.hideOnChange && (a.docChanged || a.selection) ? s = [] : t.hideOn && (s = s.filter((o) => !t.hideOn(a, o))), a.docChanged)) {
        let o = [];
        for (let u of s) {
          let h = a.changes.mapPos(u.pos, -1, we.TrackDel);
          if (h != null) {
            let d = Object.assign(/* @__PURE__ */ Object.create(null), u);
            d.pos = h, d.end != null && (d.end = a.changes.mapPos(d.end)), o.push(d);
          }
        }
        s = o;
      }
      for (let o of a.effects)
        o.is(e) && (s = o.value), o.is(kR) && (s = []);
      return s;
    },
    provide: (s) => Su.from(s)
  });
  return {
    active: i,
    extension: [
      i,
      ne.define((s) => new QR(
        s,
        n,
        i,
        e,
        t.hoverTime || 300
        /* Hover.Time */
      )),
      SR
    ]
  };
}
function Pb(n, t) {
  let e = n.plugin($p);
  if (!e)
    return null;
  let i = e.manager.tooltips.indexOf(t);
  return i < 0 ? null : e.manager.tooltipViews[i];
}
const kR = /* @__PURE__ */ yt.define(), u1 = /* @__PURE__ */ lt.define({
  combine(n) {
    let t, e;
    for (let i of n)
      t = t || i.topContainer, e = e || i.bottomContainer;
    return { topContainer: t, bottomContainer: e };
  }
});
function Xa(n, t) {
  let e = n.plugin(Rb), i = e ? e.specs.indexOf(t) : -1;
  return i > -1 ? e.panels[i] : null;
}
const Rb = /* @__PURE__ */ ne.fromClass(class {
  constructor(n) {
    this.input = n.state.facet(_a), this.specs = this.input.filter((e) => e), this.panels = this.specs.map((e) => e(n));
    let t = n.state.facet(u1);
    this.top = new Xc(n, !0, t.topContainer), this.bottom = new Xc(n, !1, t.bottomContainer), this.top.sync(this.panels.filter((e) => e.top)), this.bottom.sync(this.panels.filter((e) => !e.top));
    for (let e of this.panels)
      e.dom.classList.add("cm-panel"), e.mount && e.mount();
  }
  update(n) {
    let t = n.state.facet(u1);
    this.top.container != t.topContainer && (this.top.sync([]), this.top = new Xc(n.view, !0, t.topContainer)), this.bottom.container != t.bottomContainer && (this.bottom.sync([]), this.bottom = new Xc(n.view, !1, t.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let e = n.state.facet(_a);
    if (e != this.input) {
      let i = e.filter((h) => h), s = [], a = [], o = [], u = [];
      for (let h of i) {
        let d = this.specs.indexOf(h), p;
        d < 0 ? (p = h(n.view), u.push(p)) : (p = this.panels[d], p.update && p.update(n)), s.push(p), (p.top ? a : o).push(p);
      }
      this.specs = i, this.panels = s, this.top.sync(a), this.bottom.sync(o);
      for (let h of u)
        h.dom.classList.add("cm-panel"), h.mount && h.mount();
    } else
      for (let i of this.panels)
        i.update && i.update(n);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (n) => it.scrollMargins.of((t) => {
    let e = t.plugin(n);
    return e && { top: e.top.scrollMargin(), bottom: e.bottom.scrollMargin() };
  })
});
class Xc {
  constructor(t, e, i) {
    this.view = t, this.top = e, this.container = i, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(t) {
    for (let e of this.panels)
      e.destroy && t.indexOf(e) < 0 && e.destroy();
    this.panels = t, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let e = this.container || this.view.dom;
      e.insertBefore(this.dom, this.top ? e.firstChild : null);
    }
    let t = this.dom.firstChild;
    for (let e of this.panels)
      if (e.dom.parentNode == this.dom) {
        for (; t != e.dom; )
          t = f1(t);
        t = t.nextSibling;
      } else
        this.dom.insertBefore(e.dom, t);
    for (; t; )
      t = f1(t);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let t of this.classes.split(" "))
        t && this.container.classList.remove(t);
      for (let t of (this.classes = this.view.themeClasses).split(" "))
        t && this.container.classList.add(t);
    }
  }
}
function f1(n) {
  let t = n.nextSibling;
  return n.remove(), t;
}
const _a = /* @__PURE__ */ lt.define({
  enables: Rb
});
class Pn extends Bl {
  /**
  @internal
  */
  compare(t) {
    return this == t || this.constructor == t.constructor && this.eq(t);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(t) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(t) {
  }
}
Pn.prototype.elementClass = "";
Pn.prototype.toDOM = void 0;
Pn.prototype.mapMode = we.TrackBefore;
Pn.prototype.startSide = Pn.prototype.endSide = -1;
Pn.prototype.point = !0;
const iu = /* @__PURE__ */ lt.define(), wR = /* @__PURE__ */ lt.define(), TR = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => Mt.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, Pa = /* @__PURE__ */ lt.define();
function $R(n) {
  return [Ab(), Pa.of(Object.assign(Object.assign({}, TR), n))];
}
const h1 = /* @__PURE__ */ lt.define({
  combine: (n) => n.some((t) => t)
});
function Ab(n) {
  return [
    PR
  ];
}
const PR = /* @__PURE__ */ ne.fromClass(class {
  constructor(n) {
    this.view = n, this.prevViewport = n.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = n.state.facet(Pa).map((t) => new d1(n, t));
    for (let t of this.gutters)
      this.dom.appendChild(t.dom);
    this.fixed = !n.state.facet(h1), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), n.scrollDOM.insertBefore(this.dom, n.contentDOM);
  }
  update(n) {
    if (this.updateGutters(n)) {
      let t = this.prevViewport, e = n.view.viewport, i = Math.min(t.to, e.to) - Math.max(t.from, e.from);
      this.syncGutters(i < (e.to - e.from) * 0.8);
    }
    n.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px"), this.view.state.facet(h1) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = n.view.viewport;
  }
  syncGutters(n) {
    let t = this.dom.nextSibling;
    n && this.dom.remove();
    let e = Mt.iter(this.view.state.facet(iu), this.view.viewport.from), i = [], s = this.gutters.map((a) => new RR(a, this.view.viewport, -this.view.documentPadding.top));
    for (let a of this.view.viewportLineBlocks)
      if (i.length && (i = []), Array.isArray(a.type)) {
        let o = !0;
        for (let u of a.type)
          if (u.type == Ee.Text && o) {
            Ld(e, i, u.from);
            for (let h of s)
              h.line(this.view, u, i);
            o = !1;
          } else if (u.widget)
            for (let h of s)
              h.widget(this.view, u);
      } else if (a.type == Ee.Text) {
        Ld(e, i, a.from);
        for (let o of s)
          o.line(this.view, a, i);
      } else if (a.widget)
        for (let o of s)
          o.widget(this.view, a);
    for (let a of s)
      a.finish();
    n && this.view.scrollDOM.insertBefore(this.dom, t);
  }
  updateGutters(n) {
    let t = n.startState.facet(Pa), e = n.state.facet(Pa), i = n.docChanged || n.heightChanged || n.viewportChanged || !Mt.eq(n.startState.facet(iu), n.state.facet(iu), n.view.viewport.from, n.view.viewport.to);
    if (t == e)
      for (let s of this.gutters)
        s.update(n) && (i = !0);
    else {
      i = !0;
      let s = [];
      for (let a of e) {
        let o = t.indexOf(a);
        o < 0 ? s.push(new d1(this.view, a)) : (this.gutters[o].update(n), s.push(this.gutters[o]));
      }
      for (let a of this.gutters)
        a.dom.remove(), s.indexOf(a) < 0 && a.destroy();
      for (let a of s)
        this.dom.appendChild(a.dom);
      this.gutters = s;
    }
    return i;
  }
  destroy() {
    for (let n of this.gutters)
      n.destroy();
    this.dom.remove();
  }
}, {
  provide: (n) => it.scrollMargins.of((t) => {
    let e = t.plugin(n);
    return !e || e.gutters.length == 0 || !e.fixed ? null : t.textDirection == Bt.LTR ? { left: e.dom.offsetWidth * t.scaleX } : { right: e.dom.offsetWidth * t.scaleX };
  })
});
function O1(n) {
  return Array.isArray(n) ? n : [n];
}
function Ld(n, t, e) {
  for (; n.value && n.from <= e; )
    n.from == e && t.push(n.value), n.next();
}
class RR {
  constructor(t, e, i) {
    this.gutter = t, this.height = i, this.i = 0, this.cursor = Mt.iter(t.markers, e.from);
  }
  addElement(t, e, i) {
    let { gutter: s } = this, a = (e.top - this.height) / t.scaleY, o = e.height / t.scaleY;
    if (this.i == s.elements.length) {
      let u = new Mb(t, o, a, i);
      s.elements.push(u), s.dom.appendChild(u.dom);
    } else
      s.elements[this.i].update(t, o, a, i);
    this.height = e.bottom, this.i++;
  }
  line(t, e, i) {
    let s = [];
    Ld(this.cursor, s, e.from), i.length && (s = s.concat(i));
    let a = this.gutter.config.lineMarker(t, e, s);
    a && s.unshift(a);
    let o = this.gutter;
    s.length == 0 && !o.config.renderEmptyElements || this.addElement(t, e, s);
  }
  widget(t, e) {
    let i = this.gutter.config.widgetMarker(t, e.widget, e), s = i ? [i] : null;
    for (let a of t.state.facet(wR)) {
      let o = a(t, e.widget, e);
      o && (s || (s = [])).push(o);
    }
    s && this.addElement(t, e, s);
  }
  finish() {
    let t = this.gutter;
    for (; t.elements.length > this.i; ) {
      let e = t.elements.pop();
      t.dom.removeChild(e.dom), e.destroy();
    }
  }
}
class d1 {
  constructor(t, e) {
    this.view = t, this.config = e, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let i in e.domEventHandlers)
      this.dom.addEventListener(i, (s) => {
        let a = s.target, o;
        if (a != this.dom && this.dom.contains(a)) {
          for (; a.parentNode != this.dom; )
            a = a.parentNode;
          let h = a.getBoundingClientRect();
          o = (h.top + h.bottom) / 2;
        } else
          o = s.clientY;
        let u = t.lineBlockAtHeight(o - t.documentTop);
        e.domEventHandlers[i](t, u, s) && s.preventDefault();
      });
    this.markers = O1(e.markers(t)), e.initialSpacer && (this.spacer = new Mb(t, 0, 0, [e.initialSpacer(t)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(t) {
    let e = this.markers;
    if (this.markers = O1(this.config.markers(t.view)), this.spacer && this.config.updateSpacer) {
      let s = this.config.updateSpacer(this.spacer.markers[0], t);
      s != this.spacer.markers[0] && this.spacer.update(t.view, 0, 0, [s]);
    }
    let i = t.view.viewport;
    return !Mt.eq(this.markers, e, i.from, i.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(t) : !1);
  }
  destroy() {
    for (let t of this.elements)
      t.destroy();
  }
}
class Mb {
  constructor(t, e, i, s) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(t, e, i, s);
  }
  update(t, e, i, s) {
    this.height != e && (this.height = e, this.dom.style.height = e + "px"), this.above != i && (this.dom.style.marginTop = (this.above = i) ? i + "px" : ""), AR(this.markers, s) || this.setMarkers(t, s);
  }
  setMarkers(t, e) {
    let i = "cm-gutterElement", s = this.dom.firstChild;
    for (let a = 0, o = 0; ; ) {
      let u = o, h = a < e.length ? e[a++] : null, d = !1;
      if (h) {
        let p = h.elementClass;
        p && (i += " " + p);
        for (let g = o; g < this.markers.length; g++)
          if (this.markers[g].compare(h)) {
            u = g, d = !0;
            break;
          }
      } else
        u = this.markers.length;
      for (; o < u; ) {
        let p = this.markers[o++];
        if (p.toDOM) {
          p.destroy(s);
          let g = s.nextSibling;
          s.remove(), s = g;
        }
      }
      if (!h)
        break;
      h.toDOM && (d ? s = s.nextSibling : this.dom.insertBefore(h.toDOM(t), s)), d && o++;
    }
    this.dom.className = i, this.markers = e;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function AR(n, t) {
  if (n.length != t.length)
    return !1;
  for (let e = 0; e < n.length; e++)
    if (!n[e].compare(t[e]))
      return !1;
  return !0;
}
const MR = /* @__PURE__ */ lt.define(), qR = /* @__PURE__ */ lt.define(), js = /* @__PURE__ */ lt.define({
  combine(n) {
    return Fi(n, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(t, e) {
        let i = Object.assign({}, t);
        for (let s in e) {
          let a = i[s], o = e[s];
          i[s] = a ? (u, h, d) => a(u, h, d) || o(u, h, d) : o;
        }
        return i;
      }
    });
  }
});
class CO extends Pn {
  constructor(t) {
    super(), this.number = t;
  }
  eq(t) {
    return this.number == t.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function ZO(n, t) {
  return n.state.facet(js).formatNumber(t, n.state);
}
const CR = /* @__PURE__ */ Pa.compute([js], (n) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(t) {
    return t.state.facet(MR);
  },
  lineMarker(t, e, i) {
    return i.some((s) => s.toDOM) ? null : new CO(ZO(t, t.state.doc.lineAt(e.from).number));
  },
  widgetMarker: (t, e, i) => {
    for (let s of t.state.facet(qR)) {
      let a = s(t, e, i);
      if (a)
        return a;
    }
    return null;
  },
  lineMarkerChange: (t) => t.startState.facet(js) != t.state.facet(js),
  initialSpacer(t) {
    return new CO(ZO(t, p1(t.state.doc.lines)));
  },
  updateSpacer(t, e) {
    let i = ZO(e.view, p1(e.view.state.doc.lines));
    return i == t.number ? t : new CO(i);
  },
  domEventHandlers: n.facet(js).domEventHandlers
}));
function ZR(n = {}) {
  return [
    js.of(n),
    Ab(),
    CR
  ];
}
function p1(n) {
  let t = 9;
  for (; t < n; )
    t = t * 10 + 9;
  return t;
}
const ER = /* @__PURE__ */ new class extends Pn {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), XR = /* @__PURE__ */ iu.compute(["selection"], (n) => {
  let t = [], e = -1;
  for (let i of n.selection.ranges) {
    let s = n.doc.lineAt(i.head).from;
    s > e && (e = s, t.push(ER.range(s)));
  }
  return Mt.of(t);
});
function _R() {
  return XR;
}
const qb = 1024;
let zR = 0;
class EO {
  constructor(t, e) {
    this.from = t, this.to = e;
  }
}
class kt {
  /**
  Create a new node prop type.
  */
  constructor(t = {}) {
    this.id = zR++, this.perNode = !!t.perNode, this.deserialize = t.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(t) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof t != "function" && (t = We.match(t)), (e) => {
      let i = t(e);
      return i === void 0 ? null : [this, i];
    };
  }
}
kt.closedBy = new kt({ deserialize: (n) => n.split(" ") });
kt.openedBy = new kt({ deserialize: (n) => n.split(" ") });
kt.group = new kt({ deserialize: (n) => n.split(" ") });
kt.isolate = new kt({ deserialize: (n) => {
  if (n && n != "rtl" && n != "ltr" && n != "auto")
    throw new RangeError("Invalid value for isolate: " + n);
  return n || "auto";
} });
kt.contextHash = new kt({ perNode: !0 });
kt.lookAhead = new kt({ perNode: !0 });
kt.mounted = new kt({ perNode: !0 });
class Qu {
  constructor(t, e, i) {
    this.tree = t, this.overlay = e, this.parser = i;
  }
  /**
  @internal
  */
  static get(t) {
    return t && t.props && t.props[kt.mounted.id];
  }
}
const DR = /* @__PURE__ */ Object.create(null);
class We {
  /**
  @internal
  */
  constructor(t, e, i, s = 0) {
    this.name = t, this.props = e, this.id = i, this.flags = s;
  }
  /**
  Define a node type.
  */
  static define(t) {
    let e = t.props && t.props.length ? /* @__PURE__ */ Object.create(null) : DR, i = (t.top ? 1 : 0) | (t.skipped ? 2 : 0) | (t.error ? 4 : 0) | (t.name == null ? 8 : 0), s = new We(t.name || "", e, t.id, i);
    if (t.props) {
      for (let a of t.props)
        if (Array.isArray(a) || (a = a(s)), a) {
          if (a[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          e[a[0].id] = a[1];
        }
    }
    return s;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(t) {
    return this.props[t.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(t) {
    if (typeof t == "string") {
      if (this.name == t)
        return !0;
      let e = this.prop(kt.group);
      return e ? e.indexOf(t) > -1 : !1;
    }
    return this.id == t;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(t) {
    let e = /* @__PURE__ */ Object.create(null);
    for (let i in t)
      for (let s of i.split(" "))
        e[s] = t[i];
    return (i) => {
      for (let s = i.prop(kt.group), a = -1; a < (s ? s.length : 0); a++) {
        let o = e[a < 0 ? i.name : s[a]];
        if (o)
          return o;
      }
    };
  }
}
We.none = new We(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class Rp {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(t) {
    this.types = t;
    for (let e = 0; e < t.length; e++)
      if (t[e].id != e)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...t) {
    let e = [];
    for (let i of this.types) {
      let s = null;
      for (let a of t) {
        let o = a(i);
        o && (s || (s = Object.assign({}, i.props)), s[o[0].id] = o[1]);
      }
      e.push(s ? new We(i.name, s, i.id, i.flags) : i);
    }
    return new Rp(e);
  }
}
const _c = /* @__PURE__ */ new WeakMap(), m1 = /* @__PURE__ */ new WeakMap();
var ae;
(function(n) {
  n[n.ExcludeBuffers = 1] = "ExcludeBuffers", n[n.IncludeAnonymous = 2] = "IncludeAnonymous", n[n.IgnoreMounts = 4] = "IgnoreMounts", n[n.IgnoreOverlays = 8] = "IgnoreOverlays";
})(ae || (ae = {}));
class ce {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(t, e, i, s, a) {
    if (this.type = t, this.children = e, this.positions = i, this.length = s, this.props = null, a && a.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [o, u] of a)
        this.props[typeof o == "number" ? o : o.id] = u;
    }
  }
  /**
  @internal
  */
  toString() {
    let t = Qu.get(this);
    if (t && !t.overlay)
      return t.tree.toString();
    let e = "";
    for (let i of this.children) {
      let s = i.toString();
      s && (e && (e += ","), e += s);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (e.length ? "(" + e + ")" : "") : e;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(t = 0) {
    return new Gd(this.topNode, t);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(t, e = 0, i = 0) {
    let s = _c.get(this) || this.topNode, a = new Gd(s);
    return a.moveTo(t, e), _c.set(this, a._tree), a;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new Ne(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(t, e = 0) {
    let i = za(_c.get(this) || this.topNode, t, e, !1);
    return _c.set(this, i), i;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(t, e = 0) {
    let i = za(m1.get(this) || this.topNode, t, e, !0);
    return m1.set(this, i), i;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(t, e = 0) {
    return UR(this, t, e);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(t) {
    let { enter: e, leave: i, from: s = 0, to: a = this.length } = t, o = t.mode || 0, u = (o & ae.IncludeAnonymous) > 0;
    for (let h = this.cursor(o | ae.IncludeAnonymous); ; ) {
      let d = !1;
      if (h.from <= a && h.to >= s && (!u && h.type.isAnonymous || e(h) !== !1)) {
        if (h.firstChild())
          continue;
        d = !0;
      }
      for (; d && i && (u || !h.type.isAnonymous) && i(h), !h.nextSibling(); ) {
        if (!h.parent())
          return;
        d = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(t) {
    return t.perNode ? this.props ? this.props[t.id] : void 0 : this.type.prop(t);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let t = [];
    if (this.props)
      for (let e in this.props)
        t.push([+e, this.props[e]]);
    return t;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(t = {}) {
    return this.children.length <= 8 ? this : qp(We.none, this.children, this.positions, 0, this.children.length, 0, this.length, (e, i, s) => new ce(this.type, e, i, s, this.propValues), t.makeTree || ((e, i, s) => new ce(We.none, e, i, s)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(t) {
    return jR(t);
  }
}
ce.empty = new ce(We.none, [], [], 0);
class Ap {
  constructor(t, e) {
    this.buffer = t, this.index = e;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new Ap(this.buffer, this.index);
  }
}
class hl {
  /**
  Create a tree buffer.
  */
  constructor(t, e, i) {
    this.buffer = t, this.length = e, this.set = i;
  }
  /**
  @internal
  */
  get type() {
    return We.none;
  }
  /**
  @internal
  */
  toString() {
    let t = [];
    for (let e = 0; e < this.buffer.length; )
      t.push(this.childString(e)), e = this.buffer[e + 3];
    return t.join(",");
  }
  /**
  @internal
  */
  childString(t) {
    let e = this.buffer[t], i = this.buffer[t + 3], s = this.set.types[e], a = s.name;
    if (/\W/.test(a) && !s.isError && (a = JSON.stringify(a)), t += 4, i == t)
      return a;
    let o = [];
    for (; t < i; )
      o.push(this.childString(t)), t = this.buffer[t + 3];
    return a + "(" + o.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(t, e, i, s, a) {
    let { buffer: o } = this, u = -1;
    for (let h = t; h != e && !(Cb(a, s, o[h + 1], o[h + 2]) && (u = h, i > 0)); h = o[h + 3])
      ;
    return u;
  }
  /**
  @internal
  */
  slice(t, e, i) {
    let s = this.buffer, a = new Uint16Array(e - t), o = 0;
    for (let u = t, h = 0; u < e; ) {
      a[h++] = s[u++], a[h++] = s[u++] - i;
      let d = a[h++] = s[u++] - i;
      a[h++] = s[u++] - t, o = Math.max(o, d);
    }
    return new hl(a, o, this.set);
  }
}
function Cb(n, t, e, i) {
  switch (n) {
    case -2:
      return e < t;
    case -1:
      return i >= t && e < t;
    case 0:
      return e < t && i > t;
    case 1:
      return e <= t && i > t;
    case 2:
      return i > t;
    case 4:
      return !0;
  }
}
function za(n, t, e, i) {
  for (var s; n.from == n.to || (e < 1 ? n.from >= t : n.from > t) || (e > -1 ? n.to <= t : n.to < t); ) {
    let o = !i && n instanceof Ne && n.index < 0 ? null : n.parent;
    if (!o)
      return n;
    n = o;
  }
  let a = i ? 0 : ae.IgnoreOverlays;
  if (i)
    for (let o = n, u = o.parent; u; o = u, u = o.parent)
      o instanceof Ne && o.index < 0 && ((s = u.enter(t, e, a)) === null || s === void 0 ? void 0 : s.from) != o.from && (n = u);
  for (; ; ) {
    let o = n.enter(t, e, a);
    if (!o)
      return n;
    n = o;
  }
}
class Zb {
  cursor(t = 0) {
    return new Gd(this, t);
  }
  getChild(t, e = null, i = null) {
    let s = g1(this, t, e, i);
    return s.length ? s[0] : null;
  }
  getChildren(t, e = null, i = null) {
    return g1(this, t, e, i);
  }
  resolve(t, e = 0) {
    return za(this, t, e, !1);
  }
  resolveInner(t, e = 0) {
    return za(this, t, e, !0);
  }
  matchContext(t) {
    return Bd(this.parent, t);
  }
  enterUnfinishedNodesBefore(t) {
    let e = this.childBefore(t), i = this;
    for (; e; ) {
      let s = e.lastChild;
      if (!s || s.to != e.to)
        break;
      s.type.isError && s.from == s.to ? (i = e, e = s.prevSibling) : e = s;
    }
    return i;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class Ne extends Zb {
  constructor(t, e, i, s) {
    super(), this._tree = t, this.from = e, this.index = i, this._parent = s;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(t, e, i, s, a = 0) {
    for (let o = this; ; ) {
      for (let { children: u, positions: h } = o._tree, d = e > 0 ? u.length : -1; t != d; t += e) {
        let p = u[t], g = h[t] + o.from;
        if (Cb(s, i, g, g + p.length)) {
          if (p instanceof hl) {
            if (a & ae.ExcludeBuffers)
              continue;
            let y = p.findChild(0, p.buffer.length, e, i - g, s);
            if (y > -1)
              return new Gi(new VR(o, p, t, g), null, y);
          } else if (a & ae.IncludeAnonymous || !p.type.isAnonymous || Mp(p)) {
            let y;
            if (!(a & ae.IgnoreMounts) && (y = Qu.get(p)) && !y.overlay)
              return new Ne(y.tree, g, t, o);
            let Q = new Ne(p, g, t, o);
            return a & ae.IncludeAnonymous || !Q.type.isAnonymous ? Q : Q.nextChild(e < 0 ? p.children.length - 1 : 0, e, i, s);
          }
        }
      }
      if (a & ae.IncludeAnonymous || !o.type.isAnonymous || (o.index >= 0 ? t = o.index + e : t = e < 0 ? -1 : o._parent._tree.children.length, o = o._parent, !o))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(t) {
    return this.nextChild(
      0,
      1,
      t,
      2
      /* Side.After */
    );
  }
  childBefore(t) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  enter(t, e, i = 0) {
    let s;
    if (!(i & ae.IgnoreOverlays) && (s = Qu.get(this._tree)) && s.overlay) {
      let a = t - this.from;
      for (let { from: o, to: u } of s.overlay)
        if ((e > 0 ? o <= a : o < a) && (e < 0 ? u >= a : u > a))
          return new Ne(s.tree, s.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, t, e, i);
  }
  nextSignificantParent() {
    let t = this;
    for (; t.type.isAnonymous && t._parent; )
      t = t._parent;
    return t;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function g1(n, t, e, i) {
  let s = n.cursor(), a = [];
  if (!s.firstChild())
    return a;
  if (e != null) {
    for (let o = !1; !o; )
      if (o = s.type.is(e), !s.nextSibling())
        return a;
  }
  for (; ; ) {
    if (i != null && s.type.is(i))
      return a;
    if (s.type.is(t) && a.push(s.node), !s.nextSibling())
      return i == null ? a : [];
  }
}
function Bd(n, t, e = t.length - 1) {
  for (let i = n; e >= 0; i = i.parent) {
    if (!i)
      return !1;
    if (!i.type.isAnonymous) {
      if (t[e] && t[e] != i.name)
        return !1;
      e--;
    }
  }
  return !0;
}
class VR {
  constructor(t, e, i, s) {
    this.parent = t, this.buffer = e, this.index = i, this.start = s;
  }
}
class Gi extends Zb {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(t, e, i) {
    super(), this.context = t, this._parent = e, this.index = i, this.type = t.buffer.set.types[t.buffer.buffer[i]];
  }
  child(t, e, i) {
    let { buffer: s } = this.context, a = s.findChild(this.index + 4, s.buffer[this.index + 3], t, e - this.context.start, i);
    return a < 0 ? null : new Gi(this.context, this, a);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(t) {
    return this.child(
      1,
      t,
      2
      /* Side.After */
    );
  }
  childBefore(t) {
    return this.child(
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  enter(t, e, i = 0) {
    if (i & ae.ExcludeBuffers)
      return null;
    let { buffer: s } = this.context, a = s.findChild(this.index + 4, s.buffer[this.index + 3], e > 0 ? 1 : -1, t - this.context.start, e);
    return a < 0 ? null : new Gi(this.context, this, a);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(t) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + t,
      t,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: t } = this.context, e = t.buffer[this.index + 3];
    return e < (this._parent ? t.buffer[this._parent.index + 3] : t.buffer.length) ? new Gi(this.context, this._parent, e) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: t } = this.context, e = this._parent ? this._parent.index + 4 : 0;
    return this.index == e ? this.externalSibling(-1) : new Gi(this.context, this._parent, t.findChild(
      e,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let t = [], e = [], { buffer: i } = this.context, s = this.index + 4, a = i.buffer[this.index + 3];
    if (a > s) {
      let o = i.buffer[this.index + 1];
      t.push(i.slice(s, a, o)), e.push(0);
    }
    return new ce(this.type, t, e, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function Eb(n) {
  if (!n.length)
    return null;
  let t = 0, e = n[0];
  for (let a = 1; a < n.length; a++) {
    let o = n[a];
    (o.from > e.from || o.to < e.to) && (e = o, t = a);
  }
  let i = e instanceof Ne && e.index < 0 ? null : e.parent, s = n.slice();
  return i ? s[t] = i : s.splice(t, 1), new YR(s, e);
}
class YR {
  constructor(t, e) {
    this.heads = t, this.node = e;
  }
  get next() {
    return Eb(this.heads);
  }
}
function UR(n, t, e) {
  let i = n.resolveInner(t, e), s = null;
  for (let a = i instanceof Ne ? i : i.context.parent; a; a = a.parent)
    if (a.index < 0) {
      let o = a.parent;
      (s || (s = [i])).push(o.resolve(t, e)), a = o;
    } else {
      let o = Qu.get(a.tree);
      if (o && o.overlay && o.overlay[0].from <= t && o.overlay[o.overlay.length - 1].to >= t) {
        let u = new Ne(o.tree, o.overlay[0].from + a.from, -1, a);
        (s || (s = [i])).push(za(u, t, e, !1));
      }
    }
  return s ? Eb(s) : i;
}
class Gd {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(t, e = 0) {
    if (this.mode = e, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, t instanceof Ne)
      this.yieldNode(t);
    else {
      this._tree = t.context.parent, this.buffer = t.context;
      for (let i = t._parent; i; i = i._parent)
        this.stack.unshift(i.index);
      this.bufferNode = t, this.yieldBuf(t.index);
    }
  }
  yieldNode(t) {
    return t ? (this._tree = t, this.type = t.type, this.from = t.from, this.to = t.to, !0) : !1;
  }
  yieldBuf(t, e) {
    this.index = t;
    let { start: i, buffer: s } = this.buffer;
    return this.type = e || s.set.types[s.buffer[t]], this.from = i + s.buffer[t + 1], this.to = i + s.buffer[t + 2], !0;
  }
  /**
  @internal
  */
  yield(t) {
    return t ? t instanceof Ne ? (this.buffer = null, this.yieldNode(t)) : (this.buffer = t.context, this.yieldBuf(t.index, t.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(t, e, i) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(t < 0 ? this._tree._tree.children.length - 1 : 0, t, e, i, this.mode));
    let { buffer: s } = this.buffer, a = s.findChild(this.index + 4, s.buffer[this.index + 3], t, e - this.buffer.start, i);
    return a < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(a));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(t) {
    return this.enterChild(
      1,
      t,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(t) {
    return this.enterChild(
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(t, e, i = this.mode) {
    return this.buffer ? i & ae.ExcludeBuffers ? !1 : this.enterChild(1, t, e) : this.yield(this._tree.enter(t, e, i));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & ae.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let t = this.mode & ae.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(t);
  }
  /**
  @internal
  */
  sibling(t) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + t, t, 0, 4, this.mode)) : !1;
    let { buffer: e } = this.buffer, i = this.stack.length - 1;
    if (t < 0) {
      let s = i < 0 ? 0 : this.stack[i] + 4;
      if (this.index != s)
        return this.yieldBuf(e.findChild(
          s,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let s = e.buffer[this.index + 3];
      if (s < (i < 0 ? e.buffer.length : e.buffer[this.stack[i] + 3]))
        return this.yieldBuf(s);
    }
    return i < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + t, t, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(t) {
    let e, i, { buffer: s } = this;
    if (s) {
      if (t > 0) {
        if (this.index < s.buffer.buffer.length)
          return !1;
      } else
        for (let a = 0; a < this.index; a++)
          if (s.buffer.buffer[a + 3] < this.index)
            return !1;
      ({ index: e, parent: i } = s);
    } else
      ({ index: e, _parent: i } = this._tree);
    for (; i; { index: e, _parent: i } = i)
      if (e > -1)
        for (let a = e + t, o = t < 0 ? -1 : i._tree.children.length; a != o; a += t) {
          let u = i._tree.children[a];
          if (this.mode & ae.IncludeAnonymous || u instanceof hl || !u.type.isAnonymous || Mp(u))
            return !1;
        }
    return !0;
  }
  move(t, e) {
    if (e && this.enterChild(
      t,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(t))
        return !0;
      if (this.atLastNode(t) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(t = !0) {
    return this.move(1, t);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(t = !0) {
    return this.move(-1, t);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(t, e = 0) {
    for (; (this.from == this.to || (e < 1 ? this.from >= t : this.from > t) || (e > -1 ? this.to <= t : this.to < t)) && this.parent(); )
      ;
    for (; this.enterChild(1, t, e); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let t = this.bufferNode, e = null, i = 0;
    if (t && t.context == this.buffer)
      t: for (let s = this.index, a = this.stack.length; a >= 0; ) {
        for (let o = t; o; o = o._parent)
          if (o.index == s) {
            if (s == this.index)
              return o;
            e = o, i = a + 1;
            break t;
          }
        s = this.stack[--a];
      }
    for (let s = i; s < this.stack.length; s++)
      e = new Gi(this.buffer, e, this.stack[s]);
    return this.bufferNode = new Gi(this.buffer, e, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(t, e) {
    for (let i = 0; ; ) {
      let s = !1;
      if (this.type.isAnonymous || t(this) !== !1) {
        if (this.firstChild()) {
          i++;
          continue;
        }
        this.type.isAnonymous || (s = !0);
      }
      for (; ; ) {
        if (s && e && e(this), s = this.type.isAnonymous, !i)
          return;
        if (this.nextSibling())
          break;
        this.parent(), i--, s = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(t) {
    if (!this.buffer)
      return Bd(this.node.parent, t);
    let { buffer: e } = this.buffer, { types: i } = e.set;
    for (let s = t.length - 1, a = this.stack.length - 1; s >= 0; a--) {
      if (a < 0)
        return Bd(this._tree, t, s);
      let o = i[e.buffer[this.stack[a]]];
      if (!o.isAnonymous) {
        if (t[s] && t[s] != o.name)
          return !1;
        s--;
      }
    }
    return !0;
  }
}
function Mp(n) {
  return n.children.some((t) => t instanceof hl || !t.type.isAnonymous || Mp(t));
}
function jR(n) {
  var t;
  let { buffer: e, nodeSet: i, maxBufferLength: s = qb, reused: a = [], minRepeatType: o = i.types.length } = n, u = Array.isArray(e) ? new Ap(e, e.length) : e, h = i.types, d = 0, p = 0;
  function g(_, W, q, J, N, I) {
    let { id: K, start: Y, end: ot, size: at } = u, ht = p, E = d;
    for (; at < 0; )
      if (u.next(), at == -1) {
        let L = a[K];
        q.push(L), J.push(Y - _);
        return;
      } else if (at == -3) {
        d = K;
        return;
      } else if (at == -4) {
        p = K;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${at}`);
    let z = h[K], nt, Ot, T = Y - _;
    if (ot - Y <= s && (Ot = P(u.pos - W, N))) {
      let L = new Uint16Array(Ot.size - Ot.skip), tt = u.pos - Ot.size, F = L.length;
      for (; u.pos > tt; )
        F = A(Ot.start, L, F);
      nt = new hl(L, ot - Ot.start, i), T = Ot.start - _;
    } else {
      let L = u.pos - at;
      u.next();
      let tt = [], F = [], ct = K >= o ? K : -1, vt = 0, mt = ot;
      for (; u.pos > L; )
        ct >= 0 && u.id == ct && u.size >= 0 ? (u.end <= mt - s && (b(tt, F, Y, vt, u.end, mt, ct, ht, E), vt = tt.length, mt = u.end), u.next()) : I > 2500 ? y(Y, L, tt, F) : g(Y, L, tt, F, ct, I + 1);
      if (ct >= 0 && vt > 0 && vt < tt.length && b(tt, F, Y, vt, Y, mt, ct, ht, E), tt.reverse(), F.reverse(), ct > -1 && vt > 0) {
        let $e = Q(z, E);
        nt = qp(z, tt, F, 0, tt.length, 0, ot - Y, $e, $e);
      } else
        nt = x(z, tt, F, ot - Y, ht - ot, E);
    }
    q.push(nt), J.push(T);
  }
  function y(_, W, q, J) {
    let N = [], I = 0, K = -1;
    for (; u.pos > W; ) {
      let { id: Y, start: ot, end: at, size: ht } = u;
      if (ht > 4)
        u.next();
      else {
        if (K > -1 && ot < K)
          break;
        K < 0 && (K = at - s), N.push(Y, ot, at), I++, u.next();
      }
    }
    if (I) {
      let Y = new Uint16Array(I * 4), ot = N[N.length - 2];
      for (let at = N.length - 3, ht = 0; at >= 0; at -= 3)
        Y[ht++] = N[at], Y[ht++] = N[at + 1] - ot, Y[ht++] = N[at + 2] - ot, Y[ht++] = ht;
      q.push(new hl(Y, N[2] - ot, i)), J.push(ot - _);
    }
  }
  function Q(_, W) {
    return (q, J, N) => {
      let I = 0, K = q.length - 1, Y, ot;
      if (K >= 0 && (Y = q[K]) instanceof ce) {
        if (!K && Y.type == _ && Y.length == N)
          return Y;
        (ot = Y.prop(kt.lookAhead)) && (I = J[K] + Y.length + ot);
      }
      return x(_, q, J, N, I, W);
    };
  }
  function b(_, W, q, J, N, I, K, Y, ot) {
    let at = [], ht = [];
    for (; _.length > J; )
      at.push(_.pop()), ht.push(W.pop() + q - N);
    _.push(x(i.types[K], at, ht, I - N, Y - I, ot)), W.push(N - q);
  }
  function x(_, W, q, J, N, I, K) {
    if (I) {
      let Y = [kt.contextHash, I];
      K = K ? [Y].concat(K) : [Y];
    }
    if (N > 25) {
      let Y = [kt.lookAhead, N];
      K = K ? [Y].concat(K) : [Y];
    }
    return new ce(_, W, q, J, K);
  }
  function P(_, W) {
    let q = u.fork(), J = 0, N = 0, I = 0, K = q.end - s, Y = { size: 0, start: 0, skip: 0 };
    t: for (let ot = q.pos - _; q.pos > ot; ) {
      let at = q.size;
      if (q.id == W && at >= 0) {
        Y.size = J, Y.start = N, Y.skip = I, I += 4, J += 4, q.next();
        continue;
      }
      let ht = q.pos - at;
      if (at < 0 || ht < ot || q.start < K)
        break;
      let E = q.id >= o ? 4 : 0, z = q.start;
      for (q.next(); q.pos > ht; ) {
        if (q.size < 0)
          if (q.size == -3)
            E += 4;
          else
            break t;
        else q.id >= o && (E += 4);
        q.next();
      }
      N = z, J += at, I += E;
    }
    return (W < 0 || J == _) && (Y.size = J, Y.start = N, Y.skip = I), Y.size > 4 ? Y : void 0;
  }
  function A(_, W, q) {
    let { id: J, start: N, end: I, size: K } = u;
    if (u.next(), K >= 0 && J < o) {
      let Y = q;
      if (K > 4) {
        let ot = u.pos - (K - 4);
        for (; u.pos > ot; )
          q = A(_, W, q);
      }
      W[--q] = Y, W[--q] = I - _, W[--q] = N - _, W[--q] = J;
    } else K == -3 ? d = J : K == -4 && (p = J);
    return q;
  }
  let V = [], G = [];
  for (; u.pos > 0; )
    g(n.start || 0, n.bufferStart || 0, V, G, -1, 0);
  let H = (t = n.length) !== null && t !== void 0 ? t : V.length ? G[0] + V[0].length : 0;
  return new ce(h[n.topID], V.reverse(), G.reverse(), H);
}
const y1 = /* @__PURE__ */ new WeakMap();
function nu(n, t) {
  if (!n.isAnonymous || t instanceof hl || t.type != n)
    return 1;
  let e = y1.get(t);
  if (e == null) {
    e = 1;
    for (let i of t.children) {
      if (i.type != n || !(i instanceof ce)) {
        e = 1;
        break;
      }
      e += nu(n, i);
    }
    y1.set(t, e);
  }
  return e;
}
function qp(n, t, e, i, s, a, o, u, h) {
  let d = 0;
  for (let b = i; b < s; b++)
    d += nu(n, t[b]);
  let p = Math.ceil(
    d * 1.5 / 8
    /* Balance.BranchFactor */
  ), g = [], y = [];
  function Q(b, x, P, A, V) {
    for (let G = P; G < A; ) {
      let H = G, _ = x[G], W = nu(n, b[G]);
      for (G++; G < A; G++) {
        let q = nu(n, b[G]);
        if (W + q >= p)
          break;
        W += q;
      }
      if (G == H + 1) {
        if (W > p) {
          let q = b[H];
          Q(q.children, q.positions, 0, q.children.length, x[H] + V);
          continue;
        }
        g.push(b[H]);
      } else {
        let q = x[G - 1] + b[G - 1].length - _;
        g.push(qp(n, b, x, H, G, _, q, null, h));
      }
      y.push(_ + V - a);
    }
  }
  return Q(t, e, i, s, 0), (u || h)(g, y, o);
}
class Xb {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(t, e, i) {
    let s = this.map.get(t);
    s || this.map.set(t, s = /* @__PURE__ */ new Map()), s.set(e, i);
  }
  getBuffer(t, e) {
    let i = this.map.get(t);
    return i && i.get(e);
  }
  /**
  Set the value for this syntax node.
  */
  set(t, e) {
    t instanceof Gi ? this.setBuffer(t.context.buffer, t.index, e) : t instanceof Ne && this.map.set(t.tree, e);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(t) {
    return t instanceof Gi ? this.getBuffer(t.context.buffer, t.index) : t instanceof Ne ? this.map.get(t.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(t, e) {
    t.buffer ? this.setBuffer(t.buffer.buffer, t.index, e) : this.map.set(t.tree, e);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(t) {
    return t.buffer ? this.getBuffer(t.buffer.buffer, t.index) : this.map.get(t.tree);
  }
}
class Ul {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(t, e, i, s, a = !1, o = !1) {
    this.from = t, this.to = e, this.tree = i, this.offset = s, this.open = (a ? 1 : 0) | (o ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(t, e = [], i = !1) {
    let s = [new Ul(0, t.length, t, 0, !1, i)];
    for (let a of e)
      a.to > t.length && s.push(a);
    return s;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(t, e, i = 128) {
    if (!e.length)
      return t;
    let s = [], a = 1, o = t.length ? t[0] : null;
    for (let u = 0, h = 0, d = 0; ; u++) {
      let p = u < e.length ? e[u] : null, g = p ? p.fromA : 1e9;
      if (g - h >= i)
        for (; o && o.from < g; ) {
          let y = o;
          if (h >= y.from || g <= y.to || d) {
            let Q = Math.max(y.from, h) - d, b = Math.min(y.to, g) - d;
            y = Q >= b ? null : new Ul(Q, b, y.tree, y.offset + d, u > 0, !!p);
          }
          if (y && s.push(y), o.to > g)
            break;
          o = a < t.length ? t[a++] : null;
        }
      if (!p)
        break;
      h = p.toA, d = p.toA - p.toB;
    }
    return s;
  }
}
class _b {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(t, e, i) {
    return typeof t == "string" && (t = new LR(t)), i = i ? i.length ? i.map((s) => new EO(s.from, s.to)) : [new EO(0, 0)] : [new EO(0, t.length)], this.createParse(t, e || [], i);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(t, e, i) {
    let s = this.startParse(t, e, i);
    for (; ; ) {
      let a = s.advance();
      if (a)
        return a;
    }
  }
}
class LR {
  constructor(t) {
    this.string = t;
  }
  get length() {
    return this.string.length;
  }
  chunk(t) {
    return this.string.slice(t);
  }
  get lineChunks() {
    return !1;
  }
  read(t, e) {
    return this.string.slice(t, e);
  }
}
new kt({ perNode: !0 });
let BR = 0;
class yi {
  /**
  @internal
  */
  constructor(t, e, i, s) {
    this.name = t, this.set = e, this.base = i, this.modified = s, this.id = BR++;
  }
  toString() {
    let { name: t } = this;
    for (let e of this.modified)
      e.name && (t = `${e.name}(${t})`);
    return t;
  }
  static define(t, e) {
    let i = typeof t == "string" ? t : "?";
    if (t instanceof yi && (e = t), e != null && e.base)
      throw new Error("Can not derive from a modified tag");
    let s = new yi(i, [], null, []);
    if (s.set.push(s), e)
      for (let a of e.set)
        s.set.push(a);
    return s;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(t) {
    let e = new vu(t);
    return (i) => i.modified.indexOf(e) > -1 ? i : vu.get(i.base || i, i.modified.concat(e).sort((s, a) => s.id - a.id));
  }
}
let GR = 0;
class vu {
  constructor(t) {
    this.name = t, this.instances = [], this.id = GR++;
  }
  static get(t, e) {
    if (!e.length)
      return t;
    let i = e[0].instances.find((u) => u.base == t && NR(e, u.modified));
    if (i)
      return i;
    let s = [], a = new yi(t.name, s, t, e);
    for (let u of e)
      u.instances.push(a);
    let o = WR(e);
    for (let u of t.set)
      if (!u.modified.length)
        for (let h of o)
          s.push(vu.get(u, h));
    return a;
  }
}
function NR(n, t) {
  return n.length == t.length && n.every((e, i) => e == t[i]);
}
function WR(n) {
  let t = [[]];
  for (let e = 0; e < n.length; e++)
    for (let i = 0, s = t.length; i < s; i++)
      t.push(t[i].concat(n[e]));
  return t.sort((e, i) => i.length - e.length);
}
function Cp(n) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let e in n) {
    let i = n[e];
    Array.isArray(i) || (i = [i]);
    for (let s of e.split(" "))
      if (s) {
        let a = [], o = 2, u = s;
        for (let g = 0; ; ) {
          if (u == "..." && g > 0 && g + 3 == s.length) {
            o = 1;
            break;
          }
          let y = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(u);
          if (!y)
            throw new RangeError("Invalid path: " + s);
          if (a.push(y[0] == "*" ? "" : y[0][0] == '"' ? JSON.parse(y[0]) : y[0]), g += y[0].length, g == s.length)
            break;
          let Q = s[g++];
          if (g == s.length && Q == "!") {
            o = 0;
            break;
          }
          if (Q != "/")
            throw new RangeError("Invalid path: " + s);
          u = s.slice(g);
        }
        let h = a.length - 1, d = a[h];
        if (!d)
          throw new RangeError("Invalid path: " + s);
        let p = new bu(i, o, h > 0 ? a.slice(0, h) : null);
        t[d] = p.sort(t[d]);
      }
  }
  return zb.add(t);
}
const zb = new kt();
class bu {
  constructor(t, e, i, s) {
    this.tags = t, this.mode = e, this.context = i, this.next = s;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(t) {
    return !t || t.depth < this.depth ? (this.next = t, this) : (t.next = this.sort(t.next), t);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
bu.empty = new bu([], 2, null);
function Db(n, t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let a of n)
    if (!Array.isArray(a.tag))
      e[a.tag.id] = a.class;
    else
      for (let o of a.tag)
        e[o.id] = a.class;
  let { scope: i, all: s = null } = t || {};
  return {
    style: (a) => {
      let o = s;
      for (let u of a)
        for (let h of u.set) {
          let d = e[h.id];
          if (d) {
            o = o ? o + " " + d : d;
            break;
          }
        }
      return o;
    },
    scope: i
  };
}
function HR(n, t) {
  let e = null;
  for (let i of n) {
    let s = i.style(t);
    s && (e = e ? e + " " + s : s);
  }
  return e;
}
function KR(n, t, e, i = 0, s = n.length) {
  let a = new JR(i, Array.isArray(t) ? t : [t], e);
  a.highlightRange(n.cursor(), i, s, "", a.highlighters), a.flush(s);
}
class JR {
  constructor(t, e, i) {
    this.at = t, this.highlighters = e, this.span = i, this.class = "";
  }
  startSpan(t, e) {
    e != this.class && (this.flush(t), t > this.at && (this.at = t), this.class = e);
  }
  flush(t) {
    t > this.at && this.class && this.span(this.at, t, this.class);
  }
  highlightRange(t, e, i, s, a) {
    let { type: o, from: u, to: h } = t;
    if (u >= i || h <= e)
      return;
    o.isTop && (a = this.highlighters.filter((Q) => !Q.scope || Q.scope(o)));
    let d = s, p = IR(t) || bu.empty, g = HR(a, p.tags);
    if (g && (d && (d += " "), d += g, p.mode == 1 && (s += (s ? " " : "") + g)), this.startSpan(Math.max(e, u), d), p.opaque)
      return;
    let y = t.tree && t.tree.prop(kt.mounted);
    if (y && y.overlay) {
      let Q = t.node.enter(y.overlay[0].from + u, 1), b = this.highlighters.filter((P) => !P.scope || P.scope(y.tree.type)), x = t.firstChild();
      for (let P = 0, A = u; ; P++) {
        let V = P < y.overlay.length ? y.overlay[P] : null, G = V ? V.from + u : h, H = Math.max(e, A), _ = Math.min(i, G);
        if (H < _ && x)
          for (; t.from < _ && (this.highlightRange(t, H, _, s, a), this.startSpan(Math.min(_, t.to), d), !(t.to >= G || !t.nextSibling())); )
            ;
        if (!V || G > i)
          break;
        A = V.to + u, A > e && (this.highlightRange(Q.cursor(), Math.max(e, V.from + u), Math.min(i, A), "", b), this.startSpan(Math.min(i, A), d));
      }
      x && t.parent();
    } else if (t.firstChild()) {
      y && (s = "");
      do
        if (!(t.to <= e)) {
          if (t.from >= i)
            break;
          this.highlightRange(t, e, i, s, a), this.startSpan(Math.min(i, t.to), d);
        }
      while (t.nextSibling());
      t.parent();
    }
  }
}
function IR(n) {
  let t = n.type.prop(zb);
  for (; t && t.context && !n.matchContext(t.context); )
    t = t.next;
  return t || null;
}
const et = yi.define, zc = et(), el = et(), S1 = et(el), Q1 = et(el), il = et(), Dc = et(il), XO = et(il), Vi = et(), _l = et(Vi), zi = et(), Di = et(), Nd = et(), ha = et(Nd), Vc = et(), w = {
  /**
  A comment.
  */
  comment: zc,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: et(zc),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: et(zc),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: et(zc),
  /**
  Any kind of identifier.
  */
  name: el,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: et(el),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: S1,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: et(S1),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: Q1,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: et(Q1),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: et(el),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: et(el),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: et(el),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: et(el),
  /**
  A literal value.
  */
  literal: il,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: Dc,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: et(Dc),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: et(Dc),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: et(Dc),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: XO,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: et(XO),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: et(XO),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: et(il),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: et(il),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: et(il),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: et(il),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: et(il),
  /**
  A language keyword.
  */
  keyword: zi,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: et(zi),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: et(zi),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: et(zi),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: et(zi),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: et(zi),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: et(zi),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: et(zi),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: et(zi),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: et(zi),
  /**
  An operator.
  */
  operator: Di,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: et(Di),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: et(Di),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: et(Di),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: et(Di),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: et(Di),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: et(Di),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: et(Di),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: et(Di),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: et(Di),
  /**
  Program or markup punctuation.
  */
  punctuation: Nd,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: et(Nd),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: ha,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: et(ha),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: et(ha),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: et(ha),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: et(ha),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: Vi,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: _l,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: et(_l),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: et(_l),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: et(_l),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: et(_l),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: et(_l),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: et(_l),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: et(Vi),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: et(Vi),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: et(Vi),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: et(Vi),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: et(Vi),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: et(Vi),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: et(Vi),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: et(Vi),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: et(),
  /**
  Deleted text.
  */
  deleted: et(),
  /**
  Changed text.
  */
  changed: et(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: et(),
  /**
  Metadata or meta-instruction.
  */
  meta: Vc,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: et(Vc),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: et(Vc),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: et(Vc),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: yi.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: yi.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: yi.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: yi.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: yi.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: yi.defineModifier("special")
};
for (let n in w) {
  let t = w[n];
  t instanceof yi && (t.name = n);
}
Db([
  { tag: w.link, class: "tok-link" },
  { tag: w.heading, class: "tok-heading" },
  { tag: w.emphasis, class: "tok-emphasis" },
  { tag: w.strong, class: "tok-strong" },
  { tag: w.keyword, class: "tok-keyword" },
  { tag: w.atom, class: "tok-atom" },
  { tag: w.bool, class: "tok-bool" },
  { tag: w.url, class: "tok-url" },
  { tag: w.labelName, class: "tok-labelName" },
  { tag: w.inserted, class: "tok-inserted" },
  { tag: w.deleted, class: "tok-deleted" },
  { tag: w.literal, class: "tok-literal" },
  { tag: w.string, class: "tok-string" },
  { tag: w.number, class: "tok-number" },
  { tag: [w.regexp, w.escape, w.special(w.string)], class: "tok-string2" },
  { tag: w.variableName, class: "tok-variableName" },
  { tag: w.local(w.variableName), class: "tok-variableName tok-local" },
  { tag: w.definition(w.variableName), class: "tok-variableName tok-definition" },
  { tag: w.special(w.variableName), class: "tok-variableName2" },
  { tag: w.definition(w.propertyName), class: "tok-propertyName tok-definition" },
  { tag: w.typeName, class: "tok-typeName" },
  { tag: w.namespace, class: "tok-namespace" },
  { tag: w.className, class: "tok-className" },
  { tag: w.macroName, class: "tok-macroName" },
  { tag: w.propertyName, class: "tok-propertyName" },
  { tag: w.operator, class: "tok-operator" },
  { tag: w.comment, class: "tok-comment" },
  { tag: w.meta, class: "tok-meta" },
  { tag: w.invalid, class: "tok-invalid" },
  { tag: w.punctuation, class: "tok-punctuation" }
]);
var _O;
const Ls = /* @__PURE__ */ new kt();
function Vb(n) {
  return lt.define({
    combine: n ? (t) => t.concat(n) : void 0
  });
}
const Zp = /* @__PURE__ */ new kt();
class $i {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(t, e, i = [], s = "") {
    this.data = t, this.name = s, $t.prototype.hasOwnProperty("tree") || Object.defineProperty($t.prototype, "tree", { get() {
      return ue(this);
    } }), this.parser = e, this.extension = [
      Ol.of(this),
      $t.languageData.of((a, o, u) => {
        let h = v1(a, o, u), d = h.type.prop(Ls);
        if (!d)
          return [];
        let p = a.facet(d), g = h.type.prop(Zp);
        if (g) {
          let y = h.resolve(o - h.from, u);
          for (let Q of g)
            if (Q.test(y, a)) {
              let b = a.facet(Q.facet);
              return Q.type == "replace" ? b : b.concat(p);
            }
        }
        return p;
      })
    ].concat(i);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(t, e, i = -1) {
    return v1(t, e, i).type.prop(Ls) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(t) {
    let e = t.facet(Ol);
    if ((e == null ? void 0 : e.data) == this.data)
      return [{ from: 0, to: t.doc.length }];
    if (!e || !e.allowsNesting)
      return [];
    let i = [], s = (a, o) => {
      if (a.prop(Ls) == this.data) {
        i.push({ from: o, to: o + a.length });
        return;
      }
      let u = a.prop(kt.mounted);
      if (u) {
        if (u.tree.prop(Ls) == this.data) {
          if (u.overlay)
            for (let h of u.overlay)
              i.push({ from: h.from + o, to: h.to + o });
          else
            i.push({ from: o, to: o + a.length });
          return;
        } else if (u.overlay) {
          let h = i.length;
          if (s(u.tree, u.overlay[0].from + o), i.length > h)
            return;
        }
      }
      for (let h = 0; h < a.children.length; h++) {
        let d = a.children[h];
        d instanceof ce && s(d, a.positions[h] + o);
      }
    };
    return s(ue(t), 0), i;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
$i.setState = /* @__PURE__ */ yt.define();
function v1(n, t, e) {
  let i = n.facet(Ol), s = ue(n).topNode;
  if (!i || i.allowsNesting)
    for (let a = s; a; a = a.enter(t, e, ae.ExcludeBuffers))
      a.type.isTop && (s = a);
  return s;
}
class Da extends $i {
  constructor(t, e, i) {
    super(t, e, [], i), this.parser = e;
  }
  /**
  Define a language from a parser.
  */
  static define(t) {
    let e = Vb(t.languageData);
    return new Da(e, t.parser.configure({
      props: [Ls.add((i) => i.isTop ? e : void 0)]
    }), t.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(t, e) {
    return new Da(this.data, this.parser.configure(t), e || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function ue(n) {
  let t = n.field($i.state, !1);
  return t ? t.tree : ce.empty;
}
class FR {
  /**
  Create an input object for the given document.
  */
  constructor(t) {
    this.doc = t, this.cursorPos = 0, this.string = "", this.cursor = t.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(t) {
    return this.string = this.cursor.next(t - this.cursorPos).value, this.cursorPos = t + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(t) {
    return this.syncTo(t), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(t, e) {
    let i = this.cursorPos - this.string.length;
    return t < i || e >= this.cursorPos ? this.doc.sliceString(t, e) : this.string.slice(t - i, e - i);
  }
}
let Oa = null;
class xu {
  constructor(t, e, i = [], s, a, o, u, h) {
    this.parser = t, this.state = e, this.fragments = i, this.tree = s, this.treeLen = a, this.viewport = o, this.skipped = u, this.scheduleOn = h, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new xu(t, e, [], ce.empty, 0, i, [], null);
  }
  startParse() {
    return this.parser.startParse(new FR(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(t, e) {
    return e != null && e >= this.state.doc.length && (e = void 0), this.tree != ce.empty && this.isDone(e ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var i;
      if (typeof t == "number") {
        let s = Date.now() + t;
        t = () => Date.now() > s;
      }
      for (this.parse || (this.parse = this.startParse()), e != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > e) && e < this.state.doc.length && this.parse.stopAt(e); ; ) {
        let s = this.parse.advance();
        if (s)
          if (this.fragments = this.withoutTempSkipped(Ul.addTree(s, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (i = this.parse.stoppedAt) !== null && i !== void 0 ? i : this.state.doc.length, this.tree = s, this.parse = null, this.treeLen < (e ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (t())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let t, e;
    this.parse && (t = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > t) && this.parse.stopAt(t), this.withContext(() => {
      for (; !(e = this.parse.advance()); )
        ;
    }), this.treeLen = t, this.tree = e, this.fragments = this.withoutTempSkipped(Ul.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(t) {
    let e = Oa;
    Oa = this;
    try {
      return t();
    } finally {
      Oa = e;
    }
  }
  withoutTempSkipped(t) {
    for (let e; e = this.tempSkipped.pop(); )
      t = b1(t, e.from, e.to);
    return t;
  }
  /**
  @internal
  */
  changes(t, e) {
    let { fragments: i, tree: s, treeLen: a, viewport: o, skipped: u } = this;
    if (this.takeTree(), !t.empty) {
      let h = [];
      if (t.iterChangedRanges((d, p, g, y) => h.push({ fromA: d, toA: p, fromB: g, toB: y })), i = Ul.applyChanges(i, h), s = ce.empty, a = 0, o = { from: t.mapPos(o.from, -1), to: t.mapPos(o.to, 1) }, this.skipped.length) {
        u = [];
        for (let d of this.skipped) {
          let p = t.mapPos(d.from, 1), g = t.mapPos(d.to, -1);
          p < g && u.push({ from: p, to: g });
        }
      }
    }
    return new xu(this.parser, e, i, s, a, o, u, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(t) {
    if (this.viewport.from == t.from && this.viewport.to == t.to)
      return !1;
    this.viewport = t;
    let e = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from: s, to: a } = this.skipped[i];
      s < t.to && a > t.from && (this.fragments = b1(this.fragments, s, a), this.skipped.splice(i--, 1));
    }
    return this.skipped.length >= e ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(t, e) {
    this.skipped.push({ from: t, to: e });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(t) {
    return new class extends _b {
      createParse(e, i, s) {
        let a = s[0].from, o = s[s.length - 1].to;
        return {
          parsedPos: a,
          advance() {
            let h = Oa;
            if (h) {
              for (let d of s)
                h.tempSkipped.push(d);
              t && (h.scheduleOn = h.scheduleOn ? Promise.all([h.scheduleOn, t]) : t);
            }
            return this.parsedPos = o, new ce(We.none, [], [], o - a);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(t) {
    t = Math.min(t, this.state.doc.length);
    let e = this.fragments;
    return this.treeLen >= t && e.length && e[0].from == 0 && e[0].to >= t;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return Oa;
  }
}
function b1(n, t, e) {
  return Ul.applyChanges(n, [{ fromA: t, toA: e, fromB: t, toB: e }]);
}
class nr {
  constructor(t) {
    this.context = t, this.tree = t.tree;
  }
  apply(t) {
    if (!t.docChanged && this.tree == this.context.tree)
      return this;
    let e = this.context.changes(t.changes, t.state), i = this.context.treeLen == t.startState.doc.length ? void 0 : Math.max(t.changes.mapPos(this.context.treeLen), e.viewport.to);
    return e.work(20, i) || e.takeTree(), new nr(e);
  }
  static init(t) {
    let e = Math.min(3e3, t.doc.length), i = xu.create(t.facet(Ol).parser, t, { from: 0, to: e });
    return i.work(20, e) || i.takeTree(), new nr(i);
  }
}
$i.state = /* @__PURE__ */ Se.define({
  create: nr.init,
  update(n, t) {
    for (let e of t.effects)
      if (e.is($i.setState))
        return e.value;
    return t.startState.facet(Ol) != t.state.facet(Ol) ? nr.init(t.state) : n.apply(t);
  }
});
let Yb = (n) => {
  let t = setTimeout(
    () => n(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(t);
};
typeof requestIdleCallback < "u" && (Yb = (n) => {
  let t = -1, e = setTimeout(
    () => {
      t = requestIdleCallback(n, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => t < 0 ? clearTimeout(e) : cancelIdleCallback(t);
});
const zO = typeof navigator < "u" && (!((_O = navigator.scheduling) === null || _O === void 0) && _O.isInputPending) ? () => navigator.scheduling.isInputPending() : null, tA = /* @__PURE__ */ ne.fromClass(class {
  constructor(t) {
    this.view = t, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(t) {
    let e = this.view.state.field($i.state).context;
    (e.updateViewport(t.view.viewport) || this.view.viewport.to > e.treeLen) && this.scheduleWork(), (t.docChanged || t.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(e);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: t } = this.view, e = t.field($i.state);
    (e.tree != e.context.tree || !e.context.isDone(t.doc.length)) && (this.working = Yb(this.work));
  }
  work(t) {
    this.working = null;
    let e = Date.now();
    if (this.chunkEnd < e && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = e + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: i, viewport: { to: s } } = this.view, a = i.field($i.state);
    if (a.tree == a.context.tree && a.context.isDone(
      s + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let o = Date.now() + Math.min(this.chunkBudget, 100, t && !zO ? Math.max(25, t.timeRemaining() - 5) : 1e9), u = a.context.treeLen < s && i.doc.length > s + 1e3, h = a.context.work(() => zO && zO() || Date.now() > o, s + (u ? 0 : 1e5));
    this.chunkBudget -= Date.now() - e, (h || this.chunkBudget <= 0) && (a.context.takeTree(), this.view.dispatch({ effects: $i.setState.of(new nr(a.context)) })), this.chunkBudget > 0 && !(h && !u) && this.scheduleWork(), this.checkAsyncSchedule(a.context);
  }
  checkAsyncSchedule(t) {
    t.scheduleOn && (this.workScheduled++, t.scheduleOn.then(() => this.scheduleWork()).catch((e) => Be(this.view.state, e)).then(() => this.workScheduled--), t.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), Ol = /* @__PURE__ */ lt.define({
  combine(n) {
    return n.length ? n[0] : null;
  },
  enables: (n) => [
    $i.state,
    tA,
    it.contentAttributes.compute([n], (t) => {
      let e = t.facet(n);
      return e && e.name ? { "data-language": e.name } : {};
    })
  ]
});
class Ub {
  /**
  Create a language support object.
  */
  constructor(t, e = []) {
    this.language = t, this.support = e, this.extension = [t, e];
  }
}
const eA = /* @__PURE__ */ lt.define(), Fa = /* @__PURE__ */ lt.define({
  combine: (n) => {
    if (!n.length)
      return "  ";
    let t = n[0];
    if (!t || /\S/.test(t) || Array.from(t).some((e) => e != t[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(n[0]));
    return t;
  }
});
function ku(n) {
  let t = n.facet(Fa);
  return t.charCodeAt(0) == 9 ? n.tabSize * t.length : t.length;
}
function Va(n, t) {
  let e = "", i = n.tabSize, s = n.facet(Fa)[0];
  if (s == "	") {
    for (; t >= i; )
      e += "	", t -= i;
    s = " ";
  }
  for (let a = 0; a < t; a++)
    e += s;
  return e;
}
function Ep(n, t) {
  n instanceof $t && (n = new Uu(n));
  for (let i of n.state.facet(eA)) {
    let s = i(n, t);
    if (s !== void 0)
      return s;
  }
  let e = ue(n.state);
  return e.length >= t ? iA(n, e, t) : null;
}
class Uu {
  /**
  Create an indent context.
  */
  constructor(t, e = {}) {
    this.state = t, this.options = e, this.unit = ku(t);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(t, e = 1) {
    let i = this.state.doc.lineAt(t), { simulateBreak: s, simulateDoubleBreak: a } = this.options;
    return s != null && s >= i.from && s <= i.to ? a && s == t ? { text: "", from: t } : (e < 0 ? s < t : s <= t) ? { text: i.text.slice(s - i.from), from: s } : { text: i.text.slice(0, s - i.from), from: i.from } : i;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(t, e = 1) {
    if (this.options.simulateDoubleBreak && t == this.options.simulateBreak)
      return "";
    let { text: i, from: s } = this.lineAt(t, e);
    return i.slice(t - s, Math.min(i.length, t + 100 - s));
  }
  /**
  Find the column for the given position.
  */
  column(t, e = 1) {
    let { text: i, from: s } = this.lineAt(t, e), a = this.countColumn(i, t - s), o = this.options.overrideIndentation ? this.options.overrideIndentation(s) : -1;
    return o > -1 && (a += o - this.countColumn(i, i.search(/\S|$/))), a;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(t, e = t.length) {
    return rr(t, this.state.tabSize, e);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(t, e = 1) {
    let { text: i, from: s } = this.lineAt(t, e), a = this.options.overrideIndentation;
    if (a) {
      let o = a(s);
      if (o > -1)
        return o;
    }
    return this.countColumn(i, i.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const Xp = /* @__PURE__ */ new kt();
function iA(n, t, e) {
  let i = t.resolveStack(e), s = t.resolveInner(e, -1).resolve(e, 0).enterUnfinishedNodesBefore(e);
  if (s != i.node) {
    let a = [];
    for (let o = s; o && !(o.from == i.node.from && o.type == i.node.type); o = o.parent)
      a.push(o);
    for (let o = a.length - 1; o >= 0; o--)
      i = { node: a[o], next: i };
  }
  return jb(i, n, e);
}
function jb(n, t, e) {
  for (let i = n; i; i = i.next) {
    let s = lA(i.node);
    if (s)
      return s(_p.create(t, e, i));
  }
  return 0;
}
function nA(n) {
  return n.pos == n.options.simulateBreak && n.options.simulateDoubleBreak;
}
function lA(n) {
  let t = n.type.prop(Xp);
  if (t)
    return t;
  let e = n.firstChild, i;
  if (e && (i = e.type.prop(kt.closedBy))) {
    let s = n.lastChild, a = s && i.indexOf(s.name) > -1;
    return (o) => Lb(o, !0, 1, void 0, a && !nA(o) ? s.from : void 0);
  }
  return n.parent == null ? sA : null;
}
function sA() {
  return 0;
}
class _p extends Uu {
  constructor(t, e, i) {
    super(t.state, t.options), this.base = t, this.pos = e, this.context = i;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new _p(t, e, i);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(t) {
    let e = this.state.doc.lineAt(t.from);
    for (; ; ) {
      let i = t.resolve(e.from);
      for (; i.parent && i.parent.from == i.from; )
        i = i.parent;
      if (rA(i, t))
        break;
      e = this.state.doc.lineAt(i.from);
    }
    return this.lineIndent(e.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return jb(this.context.next, this.base, this.pos);
  }
}
function rA(n, t) {
  for (let e = t; e; e = e.parent)
    if (n == e)
      return !0;
  return !1;
}
function aA(n) {
  let t = n.node, e = t.childAfter(t.from), i = t.lastChild;
  if (!e)
    return null;
  let s = n.options.simulateBreak, a = n.state.doc.lineAt(e.from), o = s == null || s <= a.from ? a.to : Math.min(a.to, s);
  for (let u = e.to; ; ) {
    let h = t.childAfter(u);
    if (!h || h == i)
      return null;
    if (!h.type.isSkipped) {
      if (h.from >= o)
        return null;
      let d = /^ */.exec(a.text.slice(e.to - a.from))[0].length;
      return { from: e.from, to: e.to + d };
    }
    u = h.to;
  }
}
function lu({ closing: n, align: t = !0, units: e = 1 }) {
  return (i) => Lb(i, t, e, n);
}
function Lb(n, t, e, i, s) {
  let a = n.textAfter, o = a.match(/^\s*/)[0].length, u = i && a.slice(o, o + i.length) == i || s == n.pos + o, h = t ? aA(n) : null;
  return h ? u ? n.column(h.from) : n.column(h.to) : n.baseIndent + (u ? 0 : n.unit * e);
}
const oA = (n) => n.baseIndent;
function DO({ except: n, units: t = 1 } = {}) {
  return (e) => {
    let i = n && n.test(e.textAfter);
    return e.baseIndent + (i ? 0 : t * e.unit);
  };
}
const cA = 200;
function uA() {
  return $t.transactionFilter.of((n) => {
    if (!n.docChanged || !n.isUserEvent("input.type") && !n.isUserEvent("input.complete"))
      return n;
    let t = n.startState.languageDataAt("indentOnInput", n.startState.selection.main.head);
    if (!t.length)
      return n;
    let e = n.newDoc, { head: i } = n.newSelection.main, s = e.lineAt(i);
    if (i > s.from + cA)
      return n;
    let a = e.sliceString(s.from, i);
    if (!t.some((d) => d.test(a)))
      return n;
    let { state: o } = n, u = -1, h = [];
    for (let { head: d } of o.selection.ranges) {
      let p = o.doc.lineAt(d);
      if (p.from == u)
        continue;
      u = p.from;
      let g = Ep(o, p.from);
      if (g == null)
        continue;
      let y = /^\s*/.exec(p.text)[0], Q = Va(o, g);
      y != Q && h.push({ from: p.from, to: p.from + y.length, insert: Q });
    }
    return h.length ? [n, { changes: h, sequential: !0 }] : n;
  });
}
const fA = /* @__PURE__ */ lt.define(), zp = /* @__PURE__ */ new kt();
function Bb(n) {
  let t = n.firstChild, e = n.lastChild;
  return t && t.to < e.from ? { from: t.to, to: e.type.isError ? n.to : e.from } : null;
}
function hA(n, t, e) {
  let i = ue(n);
  if (i.length < e)
    return null;
  let s = i.resolveStack(e, 1), a = null;
  for (let o = s; o; o = o.next) {
    let u = o.node;
    if (u.to <= e || u.from > e)
      continue;
    if (a && u.from < t)
      break;
    let h = u.type.prop(zp);
    if (h && (u.to < i.length - 50 || i.length == n.doc.length || !OA(u))) {
      let d = h(u, n);
      d && d.from <= e && d.from >= t && d.to > e && (a = d);
    }
  }
  return a;
}
function OA(n) {
  let t = n.lastChild;
  return t && t.to == n.to && t.type.isError;
}
function wu(n, t, e) {
  for (let i of n.facet(fA)) {
    let s = i(n, t, e);
    if (s)
      return s;
  }
  return hA(n, t, e);
}
function Gb(n, t) {
  let e = t.mapPos(n.from, 1), i = t.mapPos(n.to, -1);
  return e >= i ? void 0 : { from: e, to: i };
}
const ju = /* @__PURE__ */ yt.define({ map: Gb }), to = /* @__PURE__ */ yt.define({ map: Gb });
function Nb(n) {
  let t = [];
  for (let { head: e } of n.state.selection.ranges)
    t.some((i) => i.from <= e && i.to >= e) || t.push(n.lineBlockAt(e));
  return t;
}
const Hl = /* @__PURE__ */ Se.define({
  create() {
    return ft.none;
  },
  update(n, t) {
    n = n.map(t.changes);
    for (let e of t.effects)
      if (e.is(ju) && !dA(n, e.value.from, e.value.to)) {
        let { preparePlaceholder: i } = t.state.facet(Kb), s = i ? ft.replace({ widget: new vA(i(t.state, e.value)) }) : x1;
        n = n.update({ add: [s.range(e.value.from, e.value.to)] });
      } else e.is(to) && (n = n.update({
        filter: (i, s) => e.value.from != i || e.value.to != s,
        filterFrom: e.value.from,
        filterTo: e.value.to
      }));
    if (t.selection) {
      let e = !1, { head: i } = t.selection.main;
      n.between(i, i, (s, a) => {
        s < i && a > i && (e = !0);
      }), e && (n = n.update({
        filterFrom: i,
        filterTo: i,
        filter: (s, a) => a <= i || s >= i
      }));
    }
    return n;
  },
  provide: (n) => it.decorations.from(n),
  toJSON(n, t) {
    let e = [];
    return n.between(0, t.doc.length, (i, s) => {
      e.push(i, s);
    }), e;
  },
  fromJSON(n) {
    if (!Array.isArray(n) || n.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let t = [];
    for (let e = 0; e < n.length; ) {
      let i = n[e++], s = n[e++];
      if (typeof i != "number" || typeof s != "number")
        throw new RangeError("Invalid JSON for fold state");
      t.push(x1.range(i, s));
    }
    return ft.set(t, !0);
  }
});
function Tu(n, t, e) {
  var i;
  let s = null;
  return (i = n.field(Hl, !1)) === null || i === void 0 || i.between(t, e, (a, o) => {
    (!s || s.from > a) && (s = { from: a, to: o });
  }), s;
}
function dA(n, t, e) {
  let i = !1;
  return n.between(t, t, (s, a) => {
    s == t && a == e && (i = !0);
  }), i;
}
function Wb(n, t) {
  return n.field(Hl, !1) ? t : t.concat(yt.appendConfig.of(Jb()));
}
const pA = (n) => {
  for (let t of Nb(n)) {
    let e = wu(n.state, t.from, t.to);
    if (e)
      return n.dispatch({ effects: Wb(n.state, [ju.of(e), Hb(n, e)]) }), !0;
  }
  return !1;
}, mA = (n) => {
  if (!n.state.field(Hl, !1))
    return !1;
  let t = [];
  for (let e of Nb(n)) {
    let i = Tu(n.state, e.from, e.to);
    i && t.push(to.of(i), Hb(n, i, !1));
  }
  return t.length && n.dispatch({ effects: t }), t.length > 0;
};
function Hb(n, t, e = !0) {
  let i = n.state.doc.lineAt(t.from).number, s = n.state.doc.lineAt(t.to).number;
  return it.announce.of(`${n.state.phrase(e ? "Folded lines" : "Unfolded lines")} ${i} ${n.state.phrase("to")} ${s}.`);
}
const gA = (n) => {
  let { state: t } = n, e = [];
  for (let i = 0; i < t.doc.length; ) {
    let s = n.lineBlockAt(i), a = wu(t, s.from, s.to);
    a && e.push(ju.of(a)), i = (a ? n.lineBlockAt(a.to) : s).to + 1;
  }
  return e.length && n.dispatch({ effects: Wb(n.state, e) }), !!e.length;
}, yA = (n) => {
  let t = n.state.field(Hl, !1);
  if (!t || !t.size)
    return !1;
  let e = [];
  return t.between(0, n.state.doc.length, (i, s) => {
    e.push(to.of({ from: i, to: s }));
  }), n.dispatch({ effects: e }), !0;
}, SA = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: pA },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: mA },
  { key: "Ctrl-Alt-[", run: gA },
  { key: "Ctrl-Alt-]", run: yA }
], QA = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "…"
}, Kb = /* @__PURE__ */ lt.define({
  combine(n) {
    return Fi(n, QA);
  }
});
function Jb(n) {
  return [Hl, kA];
}
function Ib(n, t) {
  let { state: e } = n, i = e.facet(Kb), s = (o) => {
    let u = n.lineBlockAt(n.posAtDOM(o.target)), h = Tu(n.state, u.from, u.to);
    h && n.dispatch({ effects: to.of(h) }), o.preventDefault();
  };
  if (i.placeholderDOM)
    return i.placeholderDOM(n, s, t);
  let a = document.createElement("span");
  return a.textContent = i.placeholderText, a.setAttribute("aria-label", e.phrase("folded code")), a.title = e.phrase("unfold"), a.className = "cm-foldPlaceholder", a.onclick = s, a;
}
const x1 = /* @__PURE__ */ ft.replace({ widget: /* @__PURE__ */ new class extends tn {
  toDOM(n) {
    return Ib(n, null);
  }
}() });
class vA extends tn {
  constructor(t) {
    super(), this.value = t;
  }
  eq(t) {
    return this.value == t.value;
  }
  toDOM(t) {
    return Ib(t, this.value);
  }
}
const bA = {
  openText: "⌄",
  closedText: "›",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class VO extends Pn {
  constructor(t, e) {
    super(), this.config = t, this.open = e;
  }
  eq(t) {
    return this.config == t.config && this.open == t.open;
  }
  toDOM(t) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let e = document.createElement("span");
    return e.textContent = this.open ? this.config.openText : this.config.closedText, e.title = t.state.phrase(this.open ? "Fold line" : "Unfold line"), e;
  }
}
function xA(n = {}) {
  let t = Object.assign(Object.assign({}, bA), n), e = new VO(t, !0), i = new VO(t, !1), s = ne.fromClass(class {
    constructor(o) {
      this.from = o.viewport.from, this.markers = this.buildMarkers(o);
    }
    update(o) {
      (o.docChanged || o.viewportChanged || o.startState.facet(Ol) != o.state.facet(Ol) || o.startState.field(Hl, !1) != o.state.field(Hl, !1) || ue(o.startState) != ue(o.state) || t.foldingChanged(o)) && (this.markers = this.buildMarkers(o.view));
    }
    buildMarkers(o) {
      let u = new Tn();
      for (let h of o.viewportLineBlocks) {
        let d = Tu(o.state, h.from, h.to) ? i : wu(o.state, h.from, h.to) ? e : null;
        d && u.add(h.from, h.from, d);
      }
      return u.finish();
    }
  }), { domEventHandlers: a } = t;
  return [
    s,
    $R({
      class: "cm-foldGutter",
      markers(o) {
        var u;
        return ((u = o.plugin(s)) === null || u === void 0 ? void 0 : u.markers) || Mt.empty;
      },
      initialSpacer() {
        return new VO(t, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, a), { click: (o, u, h) => {
        if (a.click && a.click(o, u, h))
          return !0;
        let d = Tu(o.state, u.from, u.to);
        if (d)
          return o.dispatch({ effects: to.of(d) }), !0;
        let p = wu(o.state, u.from, u.to);
        return p ? (o.dispatch({ effects: ju.of(p) }), !0) : !1;
      } })
    }),
    Jb()
  ];
}
const kA = /* @__PURE__ */ it.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class eo {
  constructor(t, e) {
    this.specs = t;
    let i;
    function s(u) {
      let h = cl.newName();
      return (i || (i = /* @__PURE__ */ Object.create(null)))["." + h] = u, h;
    }
    const a = typeof e.all == "string" ? e.all : e.all ? s(e.all) : void 0, o = e.scope;
    this.scope = o instanceof $i ? (u) => u.prop(Ls) == o.data : o ? (u) => u == o : void 0, this.style = Db(t.map((u) => ({
      tag: u.tag,
      class: u.class || s(Object.assign({}, u, { tag: null }))
    })), {
      all: a
    }).style, this.module = i ? new cl(i) : null, this.themeType = e.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(t, e) {
    return new eo(t, e || {});
  }
}
const Wd = /* @__PURE__ */ lt.define(), Fb = /* @__PURE__ */ lt.define({
  combine(n) {
    return n.length ? [n[0]] : null;
  }
});
function YO(n) {
  let t = n.facet(Wd);
  return t.length ? t : n.facet(Fb);
}
function tx(n, t) {
  let e = [TA], i;
  return n instanceof eo && (n.module && e.push(it.styleModule.of(n.module)), i = n.themeType), t != null && t.fallback ? e.push(Fb.of(n)) : i ? e.push(Wd.computeN([it.darkTheme], (s) => s.facet(it.darkTheme) == (i == "dark") ? [n] : [])) : e.push(Wd.of(n)), e;
}
class wA {
  constructor(t) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = ue(t.state), this.decorations = this.buildDeco(t, YO(t.state)), this.decoratedTo = t.viewport.to;
  }
  update(t) {
    let e = ue(t.state), i = YO(t.state), s = i != YO(t.startState), { viewport: a } = t.view, o = t.changes.mapPos(this.decoratedTo, 1);
    e.length < a.to && !s && e.type == this.tree.type && o >= a.to ? (this.decorations = this.decorations.map(t.changes), this.decoratedTo = o) : (e != this.tree || t.viewportChanged || s) && (this.tree = e, this.decorations = this.buildDeco(t.view, i), this.decoratedTo = a.to);
  }
  buildDeco(t, e) {
    if (!e || !this.tree.length)
      return ft.none;
    let i = new Tn();
    for (let { from: s, to: a } of t.visibleRanges)
      KR(this.tree, e, (o, u, h) => {
        i.add(o, u, this.markCache[h] || (this.markCache[h] = ft.mark({ class: h })));
      }, s, a);
    return i.finish();
  }
}
const TA = /* @__PURE__ */ dl.high(/* @__PURE__ */ ne.fromClass(wA, {
  decorations: (n) => n.decorations
})), $A = /* @__PURE__ */ eo.define([
  {
    tag: w.meta,
    color: "#404740"
  },
  {
    tag: w.link,
    textDecoration: "underline"
  },
  {
    tag: w.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: w.emphasis,
    fontStyle: "italic"
  },
  {
    tag: w.strong,
    fontWeight: "bold"
  },
  {
    tag: w.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: w.keyword,
    color: "#708"
  },
  {
    tag: [w.atom, w.bool, w.url, w.contentSeparator, w.labelName],
    color: "#219"
  },
  {
    tag: [w.literal, w.inserted],
    color: "#164"
  },
  {
    tag: [w.string, w.deleted],
    color: "#a11"
  },
  {
    tag: [w.regexp, w.escape, /* @__PURE__ */ w.special(w.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ w.definition(w.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ w.local(w.variableName),
    color: "#30a"
  },
  {
    tag: [w.typeName, w.namespace],
    color: "#085"
  },
  {
    tag: w.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ w.special(w.variableName), w.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ w.definition(w.propertyName),
    color: "#00c"
  },
  {
    tag: w.comment,
    color: "#940"
  },
  {
    tag: w.invalid,
    color: "#f00"
  }
]), PA = /* @__PURE__ */ it.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), ex = 1e4, ix = "()[]{}", nx = /* @__PURE__ */ lt.define({
  combine(n) {
    return Fi(n, {
      afterCursor: !0,
      brackets: ix,
      maxScanDistance: ex,
      renderMatch: MA
    });
  }
}), RA = /* @__PURE__ */ ft.mark({ class: "cm-matchingBracket" }), AA = /* @__PURE__ */ ft.mark({ class: "cm-nonmatchingBracket" });
function MA(n) {
  let t = [], e = n.matched ? RA : AA;
  return t.push(e.range(n.start.from, n.start.to)), n.end && t.push(e.range(n.end.from, n.end.to)), t;
}
const qA = /* @__PURE__ */ Se.define({
  create() {
    return ft.none;
  },
  update(n, t) {
    if (!t.docChanged && !t.selection)
      return n;
    let e = [], i = t.state.facet(nx);
    for (let s of t.state.selection.ranges) {
      if (!s.empty)
        continue;
      let a = Ni(t.state, s.head, -1, i) || s.head > 0 && Ni(t.state, s.head - 1, 1, i) || i.afterCursor && (Ni(t.state, s.head, 1, i) || s.head < t.state.doc.length && Ni(t.state, s.head + 1, -1, i));
      a && (e = e.concat(i.renderMatch(a, t.state)));
    }
    return ft.set(e, !0);
  },
  provide: (n) => it.decorations.from(n)
}), CA = [
  qA,
  PA
];
function ZA(n = {}) {
  return [nx.of(n), CA];
}
const EA = /* @__PURE__ */ new kt();
function Hd(n, t, e) {
  let i = n.prop(t < 0 ? kt.openedBy : kt.closedBy);
  if (i)
    return i;
  if (n.name.length == 1) {
    let s = e.indexOf(n.name);
    if (s > -1 && s % 2 == (t < 0 ? 1 : 0))
      return [e[s + t]];
  }
  return null;
}
function Kd(n) {
  let t = n.type.prop(EA);
  return t ? t(n.node) : n;
}
function Ni(n, t, e, i = {}) {
  let s = i.maxScanDistance || ex, a = i.brackets || ix, o = ue(n), u = o.resolveInner(t, e);
  for (let h = u; h; h = h.parent) {
    let d = Hd(h.type, e, a);
    if (d && h.from < h.to) {
      let p = Kd(h);
      if (p && (e > 0 ? t >= p.from && t < p.to : t > p.from && t <= p.to))
        return XA(n, t, e, h, p, d, a);
    }
  }
  return _A(n, t, e, o, u.type, s, a);
}
function XA(n, t, e, i, s, a, o) {
  let u = i.parent, h = { from: s.from, to: s.to }, d = 0, p = u == null ? void 0 : u.cursor();
  if (p && (e < 0 ? p.childBefore(i.from) : p.childAfter(i.to)))
    do
      if (e < 0 ? p.to <= i.from : p.from >= i.to) {
        if (d == 0 && a.indexOf(p.type.name) > -1 && p.from < p.to) {
          let g = Kd(p);
          return { start: h, end: g ? { from: g.from, to: g.to } : void 0, matched: !0 };
        } else if (Hd(p.type, e, o))
          d++;
        else if (Hd(p.type, -e, o)) {
          if (d == 0) {
            let g = Kd(p);
            return {
              start: h,
              end: g && g.from < g.to ? { from: g.from, to: g.to } : void 0,
              matched: !1
            };
          }
          d--;
        }
      }
    while (e < 0 ? p.prevSibling() : p.nextSibling());
  return { start: h, matched: !1 };
}
function _A(n, t, e, i, s, a, o) {
  let u = e < 0 ? n.sliceDoc(t - 1, t) : n.sliceDoc(t, t + 1), h = o.indexOf(u);
  if (h < 0 || h % 2 == 0 != e > 0)
    return null;
  let d = { from: e < 0 ? t - 1 : t, to: e > 0 ? t + 1 : t }, p = n.doc.iterRange(t, e > 0 ? n.doc.length : 0), g = 0;
  for (let y = 0; !p.next().done && y <= a; ) {
    let Q = p.value;
    e < 0 && (y += Q.length);
    let b = t + y * e;
    for (let x = e > 0 ? 0 : Q.length - 1, P = e > 0 ? Q.length : -1; x != P; x += e) {
      let A = o.indexOf(Q[x]);
      if (!(A < 0 || i.resolveInner(b + x, 1).type != s))
        if (A % 2 == 0 == e > 0)
          g++;
        else {
          if (g == 1)
            return { start: d, end: { from: b + x, to: b + x + 1 }, matched: A >> 1 == h >> 1 };
          g--;
        }
    }
    e > 0 && (y += Q.length);
  }
  return p.done ? { start: d, matched: !1 } : null;
}
const zA = /* @__PURE__ */ Object.create(null), k1 = [We.none], w1 = [], T1 = /* @__PURE__ */ Object.create(null), DA = /* @__PURE__ */ Object.create(null);
for (let [n, t] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  DA[n] = /* @__PURE__ */ VA(zA, t);
function UO(n, t) {
  w1.indexOf(n) > -1 || (w1.push(n), console.warn(t));
}
function VA(n, t) {
  let e = [];
  for (let u of t.split(" ")) {
    let h = [];
    for (let d of u.split(".")) {
      let p = n[d] || w[d];
      p ? typeof p == "function" ? h.length ? h = h.map(p) : UO(d, `Modifier ${d} used at start of tag`) : h.length ? UO(d, `Tag ${d} used as modifier`) : h = Array.isArray(p) ? p : [p] : UO(d, `Unknown highlighting tag ${d}`);
    }
    for (let d of h)
      e.push(d);
  }
  if (!e.length)
    return 0;
  let i = t.replace(/ /g, "_"), s = i + " " + e.map((u) => u.id), a = T1[s];
  if (a)
    return a.id;
  let o = T1[s] = We.define({
    id: k1.length,
    name: i,
    props: [Cp({ [i]: e })]
  });
  return k1.push(o), o.id;
}
Bt.RTL, Bt.LTR;
const YA = (n) => {
  let { state: t } = n, e = t.doc.lineAt(t.selection.main.from), i = Vp(n.state, e.from);
  return i.line ? UA(n) : i.block ? LA(n) : !1;
};
function Dp(n, t) {
  return ({ state: e, dispatch: i }) => {
    if (e.readOnly)
      return !1;
    let s = n(t, e);
    return s ? (i(e.update(s)), !0) : !1;
  };
}
const UA = /* @__PURE__ */ Dp(
  NA,
  0
  /* CommentOption.Toggle */
), jA = /* @__PURE__ */ Dp(
  lx,
  0
  /* CommentOption.Toggle */
), LA = /* @__PURE__ */ Dp(
  (n, t) => lx(n, t, GA(t)),
  0
  /* CommentOption.Toggle */
);
function Vp(n, t) {
  let e = n.languageDataAt("commentTokens", t, 1);
  return e.length ? e[0] : {};
}
const da = 50;
function BA(n, { open: t, close: e }, i, s) {
  let a = n.sliceDoc(i - da, i), o = n.sliceDoc(s, s + da), u = /\s*$/.exec(a)[0].length, h = /^\s*/.exec(o)[0].length, d = a.length - u;
  if (a.slice(d - t.length, d) == t && o.slice(h, h + e.length) == e)
    return {
      open: { pos: i - u, margin: u && 1 },
      close: { pos: s + h, margin: h && 1 }
    };
  let p, g;
  s - i <= 2 * da ? p = g = n.sliceDoc(i, s) : (p = n.sliceDoc(i, i + da), g = n.sliceDoc(s - da, s));
  let y = /^\s*/.exec(p)[0].length, Q = /\s*$/.exec(g)[0].length, b = g.length - Q - e.length;
  return p.slice(y, y + t.length) == t && g.slice(b, b + e.length) == e ? {
    open: {
      pos: i + y + t.length,
      margin: /\s/.test(p.charAt(y + t.length)) ? 1 : 0
    },
    close: {
      pos: s - Q - e.length,
      margin: /\s/.test(g.charAt(b - 1)) ? 1 : 0
    }
  } : null;
}
function GA(n) {
  let t = [];
  for (let e of n.selection.ranges) {
    let i = n.doc.lineAt(e.from), s = e.to <= i.to ? i : n.doc.lineAt(e.to);
    s.from > i.from && s.from == e.to && (s = e.to == i.to + 1 ? i : n.doc.lineAt(e.to - 1));
    let a = t.length - 1;
    a >= 0 && t[a].to > i.from ? t[a].to = s.to : t.push({ from: i.from + /^\s*/.exec(i.text)[0].length, to: s.to });
  }
  return t;
}
function lx(n, t, e = t.selection.ranges) {
  let i = e.map((a) => Vp(t, a.from).block);
  if (!i.every((a) => a))
    return null;
  let s = e.map((a, o) => BA(t, i[o], a.from, a.to));
  if (n != 2 && !s.every((a) => a))
    return { changes: t.changes(e.map((a, o) => s[o] ? [] : [{ from: a.from, insert: i[o].open + " " }, { from: a.to, insert: " " + i[o].close }])) };
  if (n != 1 && s.some((a) => a)) {
    let a = [];
    for (let o = 0, u; o < s.length; o++)
      if (u = s[o]) {
        let h = i[o], { open: d, close: p } = u;
        a.push({ from: d.pos - h.open.length, to: d.pos + d.margin }, { from: p.pos - p.margin, to: p.pos + h.close.length });
      }
    return { changes: a };
  }
  return null;
}
function NA(n, t, e = t.selection.ranges) {
  let i = [], s = -1;
  for (let { from: a, to: o } of e) {
    let u = i.length, h = 1e9, d = Vp(t, a).line;
    if (d) {
      for (let p = a; p <= o; ) {
        let g = t.doc.lineAt(p);
        if (g.from > s && (a == o || o > g.from)) {
          s = g.from;
          let y = /^\s*/.exec(g.text)[0].length, Q = y == g.length, b = g.text.slice(y, y + d.length) == d ? y : -1;
          y < g.text.length && y < h && (h = y), i.push({ line: g, comment: b, token: d, indent: y, empty: Q, single: !1 });
        }
        p = g.to + 1;
      }
      if (h < 1e9)
        for (let p = u; p < i.length; p++)
          i[p].indent < i[p].line.text.length && (i[p].indent = h);
      i.length == u + 1 && (i[u].single = !0);
    }
  }
  if (n != 2 && i.some((a) => a.comment < 0 && (!a.empty || a.single))) {
    let a = [];
    for (let { line: u, token: h, indent: d, empty: p, single: g } of i)
      (g || !p) && a.push({ from: u.from + d, insert: h + " " });
    let o = t.changes(a);
    return { changes: o, selection: t.selection.map(o, 1) };
  } else if (n != 1 && i.some((a) => a.comment >= 0)) {
    let a = [];
    for (let { line: o, comment: u, token: h } of i)
      if (u >= 0) {
        let d = o.from + u, p = d + h.length;
        o.text[p - o.from] == " " && p++, a.push({ from: d, to: p });
      }
    return { changes: a };
  }
  return null;
}
const Jd = /* @__PURE__ */ Ii.define(), WA = /* @__PURE__ */ Ii.define(), HA = /* @__PURE__ */ lt.define(), sx = /* @__PURE__ */ lt.define({
  combine(n) {
    return Fi(n, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (t, e) => e
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (t, e) => (i, s) => t(i, s) || e(i, s)
    });
  }
}), rx = /* @__PURE__ */ Se.define({
  create() {
    return Wi.empty;
  },
  update(n, t) {
    let e = t.state.facet(sx), i = t.annotation(Jd);
    if (i) {
      let h = Ge.fromTransaction(t, i.selection), d = i.side, p = d == 0 ? n.undone : n.done;
      return h ? p = $u(p, p.length, e.minDepth, h) : p = cx(p, t.startState.selection), new Wi(d == 0 ? i.rest : p, d == 0 ? p : i.rest);
    }
    let s = t.annotation(WA);
    if ((s == "full" || s == "before") && (n = n.isolate()), t.annotation(oe.addToHistory) === !1)
      return t.changes.empty ? n : n.addMapping(t.changes.desc);
    let a = Ge.fromTransaction(t), o = t.annotation(oe.time), u = t.annotation(oe.userEvent);
    return a ? n = n.addChanges(a, o, u, e, t) : t.selection && (n = n.addSelection(t.startState.selection, o, u, e.newGroupDelay)), (s == "full" || s == "after") && (n = n.isolate()), n;
  },
  toJSON(n) {
    return { done: n.done.map((t) => t.toJSON()), undone: n.undone.map((t) => t.toJSON()) };
  },
  fromJSON(n) {
    return new Wi(n.done.map(Ge.fromJSON), n.undone.map(Ge.fromJSON));
  }
});
function KA(n = {}) {
  return [
    rx,
    sx.of(n),
    it.domEventHandlers({
      beforeinput(t, e) {
        let i = t.inputType == "historyUndo" ? ax : t.inputType == "historyRedo" ? Id : null;
        return i ? (t.preventDefault(), i(e)) : !1;
      }
    })
  ];
}
function Lu(n, t) {
  return function({ state: e, dispatch: i }) {
    if (!t && e.readOnly)
      return !1;
    let s = e.field(rx, !1);
    if (!s)
      return !1;
    let a = s.pop(n, e, t);
    return a ? (i(a), !0) : !1;
  };
}
const ax = /* @__PURE__ */ Lu(0, !1), Id = /* @__PURE__ */ Lu(1, !1), JA = /* @__PURE__ */ Lu(0, !0), IA = /* @__PURE__ */ Lu(1, !0);
class Ge {
  constructor(t, e, i, s, a) {
    this.changes = t, this.effects = e, this.mapped = i, this.startSelection = s, this.selectionsAfter = a;
  }
  setSelAfter(t) {
    return new Ge(this.changes, this.effects, this.mapped, this.startSelection, t);
  }
  toJSON() {
    var t, e, i;
    return {
      changes: (t = this.changes) === null || t === void 0 ? void 0 : t.toJSON(),
      mapped: (e = this.mapped) === null || e === void 0 ? void 0 : e.toJSON(),
      startSelection: (i = this.startSelection) === null || i === void 0 ? void 0 : i.toJSON(),
      selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
    };
  }
  static fromJSON(t) {
    return new Ge(t.changes && Oe.fromJSON(t.changes), [], t.mapped && Hi.fromJSON(t.mapped), t.startSelection && j.fromJSON(t.startSelection), t.selectionsAfter.map(j.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(t, e) {
    let i = Si;
    for (let s of t.startState.facet(HA)) {
      let a = s(t);
      a.length && (i = i.concat(a));
    }
    return !i.length && t.changes.empty ? null : new Ge(t.changes.invert(t.startState.doc), i, void 0, e || t.startState.selection, Si);
  }
  static selection(t) {
    return new Ge(void 0, Si, void 0, void 0, t);
  }
}
function $u(n, t, e, i) {
  let s = t + 1 > e + 20 ? t - e - 1 : 0, a = n.slice(s, t);
  return a.push(i), a;
}
function FA(n, t) {
  let e = [], i = !1;
  return n.iterChangedRanges((s, a) => e.push(s, a)), t.iterChangedRanges((s, a, o, u) => {
    for (let h = 0; h < e.length; ) {
      let d = e[h++], p = e[h++];
      u >= d && o <= p && (i = !0);
    }
  }), i;
}
function t5(n, t) {
  return n.ranges.length == t.ranges.length && n.ranges.filter((e, i) => e.empty != t.ranges[i].empty).length === 0;
}
function ox(n, t) {
  return n.length ? t.length ? n.concat(t) : n : t;
}
const Si = [], e5 = 200;
function cx(n, t) {
  if (n.length) {
    let e = n[n.length - 1], i = e.selectionsAfter.slice(Math.max(0, e.selectionsAfter.length - e5));
    return i.length && i[i.length - 1].eq(t) ? n : (i.push(t), $u(n, n.length - 1, 1e9, e.setSelAfter(i)));
  } else
    return [Ge.selection([t])];
}
function i5(n) {
  let t = n[n.length - 1], e = n.slice();
  return e[n.length - 1] = t.setSelAfter(t.selectionsAfter.slice(0, t.selectionsAfter.length - 1)), e;
}
function jO(n, t) {
  if (!n.length)
    return n;
  let e = n.length, i = Si;
  for (; e; ) {
    let s = n5(n[e - 1], t, i);
    if (s.changes && !s.changes.empty || s.effects.length) {
      let a = n.slice(0, e);
      return a[e - 1] = s, a;
    } else
      t = s.mapped, e--, i = s.selectionsAfter;
  }
  return i.length ? [Ge.selection(i)] : Si;
}
function n5(n, t, e) {
  let i = ox(n.selectionsAfter.length ? n.selectionsAfter.map((u) => u.map(t)) : Si, e);
  if (!n.changes)
    return Ge.selection(i);
  let s = n.changes.map(t), a = t.mapDesc(n.changes, !0), o = n.mapped ? n.mapped.composeDesc(a) : a;
  return new Ge(s, yt.mapEffects(n.effects, t), o, n.startSelection.map(a), i);
}
const l5 = /^(input\.type|delete)($|\.)/;
class Wi {
  constructor(t, e, i = 0, s = void 0) {
    this.done = t, this.undone = e, this.prevTime = i, this.prevUserEvent = s;
  }
  isolate() {
    return this.prevTime ? new Wi(this.done, this.undone) : this;
  }
  addChanges(t, e, i, s, a) {
    let o = this.done, u = o[o.length - 1];
    return u && u.changes && !u.changes.empty && t.changes && (!i || l5.test(i)) && (!u.selectionsAfter.length && e - this.prevTime < s.newGroupDelay && s.joinToEvent(a, FA(u.changes, t.changes)) || // For compose (but not compose.start) events, always join with previous event
    i == "input.type.compose") ? o = $u(o, o.length - 1, s.minDepth, new Ge(t.changes.compose(u.changes), ox(yt.mapEffects(t.effects, u.changes), u.effects), u.mapped, u.startSelection, Si)) : o = $u(o, o.length, s.minDepth, t), new Wi(o, Si, e, i);
  }
  addSelection(t, e, i, s) {
    let a = this.done.length ? this.done[this.done.length - 1].selectionsAfter : Si;
    return a.length > 0 && e - this.prevTime < s && i == this.prevUserEvent && i && /^select($|\.)/.test(i) && t5(a[a.length - 1], t) ? this : new Wi(cx(this.done, t), this.undone, e, i);
  }
  addMapping(t) {
    return new Wi(jO(this.done, t), jO(this.undone, t), this.prevTime, this.prevUserEvent);
  }
  pop(t, e, i) {
    let s = t == 0 ? this.done : this.undone;
    if (s.length == 0)
      return null;
    let a = s[s.length - 1], o = a.selectionsAfter[0] || e.selection;
    if (i && a.selectionsAfter.length)
      return e.update({
        selection: a.selectionsAfter[a.selectionsAfter.length - 1],
        annotations: Jd.of({ side: t, rest: i5(s), selection: o }),
        userEvent: t == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (a.changes) {
      let u = s.length == 1 ? Si : s.slice(0, s.length - 1);
      return a.mapped && (u = jO(u, a.mapped)), e.update({
        changes: a.changes,
        selection: a.startSelection,
        effects: a.effects,
        annotations: Jd.of({ side: t, rest: u, selection: o }),
        filter: !1,
        userEvent: t == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
Wi.empty = /* @__PURE__ */ new Wi(Si, Si);
const s5 = [
  { key: "Mod-z", run: ax, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: Id, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: Id, preventDefault: !0 },
  { key: "Mod-u", run: JA, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: IA, preventDefault: !0 }
];
function ar(n, t) {
  return j.create(n.ranges.map(t), n.mainIndex);
}
function en(n, t) {
  return n.update({ selection: t, scrollIntoView: !0, userEvent: "select" });
}
function Ai({ state: n, dispatch: t }, e) {
  let i = ar(n.selection, e);
  return i.eq(n.selection, !0) ? !1 : (t(en(n, i)), !0);
}
function Bu(n, t) {
  return j.cursor(t ? n.to : n.from);
}
function ux(n, t) {
  return Ai(n, (e) => e.empty ? n.moveByChar(e, t) : Bu(e, t));
}
function Ce(n) {
  return n.textDirectionAt(n.state.selection.main.head) == Bt.LTR;
}
const fx = (n) => ux(n, !Ce(n)), hx = (n) => ux(n, Ce(n));
function Ox(n, t) {
  return Ai(n, (e) => e.empty ? n.moveByGroup(e, t) : Bu(e, t));
}
const r5 = (n) => Ox(n, !Ce(n)), a5 = (n) => Ox(n, Ce(n));
function o5(n, t, e) {
  if (t.type.prop(e))
    return !0;
  let i = t.to - t.from;
  return i && (i > 2 || /[^\s,.;:]/.test(n.sliceDoc(t.from, t.to))) || t.firstChild;
}
function Gu(n, t, e) {
  let i = ue(n).resolveInner(t.head), s = e ? kt.closedBy : kt.openedBy;
  for (let h = t.head; ; ) {
    let d = e ? i.childAfter(h) : i.childBefore(h);
    if (!d)
      break;
    o5(n, d, s) ? i = d : h = e ? d.to : d.from;
  }
  let a = i.type.prop(s), o, u;
  return a && (o = e ? Ni(n, i.from, 1) : Ni(n, i.to, -1)) && o.matched ? u = e ? o.end.to : o.end.from : u = e ? i.to : i.from, j.cursor(u, e ? -1 : 1);
}
const c5 = (n) => Ai(n, (t) => Gu(n.state, t, !Ce(n))), u5 = (n) => Ai(n, (t) => Gu(n.state, t, Ce(n)));
function dx(n, t) {
  return Ai(n, (e) => {
    if (!e.empty)
      return Bu(e, t);
    let i = n.moveVertically(e, t);
    return i.head != e.head ? i : n.moveToLineBoundary(e, t);
  });
}
const px = (n) => dx(n, !1), mx = (n) => dx(n, !0);
function gx(n) {
  let t = n.scrollDOM.clientHeight < n.scrollDOM.scrollHeight - 2, e = 0, i = 0, s;
  if (t) {
    for (let a of n.state.facet(it.scrollMargins)) {
      let o = a(n);
      o != null && o.top && (e = Math.max(o == null ? void 0 : o.top, e)), o != null && o.bottom && (i = Math.max(o == null ? void 0 : o.bottom, i));
    }
    s = n.scrollDOM.clientHeight - e - i;
  } else
    s = (n.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: e,
    marginBottom: i,
    selfScroll: t,
    height: Math.max(n.defaultLineHeight, s - 5)
  };
}
function yx(n, t) {
  let e = gx(n), { state: i } = n, s = ar(i.selection, (o) => o.empty ? n.moveVertically(o, t, e.height) : Bu(o, t));
  if (s.eq(i.selection))
    return !1;
  let a;
  if (e.selfScroll) {
    let o = n.coordsAtPos(i.selection.main.head), u = n.scrollDOM.getBoundingClientRect(), h = u.top + e.marginTop, d = u.bottom - e.marginBottom;
    o && o.top > h && o.bottom < d && (a = it.scrollIntoView(s.main.head, { y: "start", yMargin: o.top - h }));
  }
  return n.dispatch(en(i, s), { effects: a }), !0;
}
const $1 = (n) => yx(n, !1), Fd = (n) => yx(n, !0);
function pl(n, t, e) {
  let i = n.lineBlockAt(t.head), s = n.moveToLineBoundary(t, e);
  if (s.head == t.head && s.head != (e ? i.to : i.from) && (s = n.moveToLineBoundary(t, e, !1)), !e && s.head == i.from && i.length) {
    let a = /^\s*/.exec(n.state.sliceDoc(i.from, Math.min(i.from + 100, i.to)))[0].length;
    a && t.head != i.from + a && (s = j.cursor(i.from + a));
  }
  return s;
}
const f5 = (n) => Ai(n, (t) => pl(n, t, !0)), h5 = (n) => Ai(n, (t) => pl(n, t, !1)), O5 = (n) => Ai(n, (t) => pl(n, t, !Ce(n))), d5 = (n) => Ai(n, (t) => pl(n, t, Ce(n))), p5 = (n) => Ai(n, (t) => j.cursor(n.lineBlockAt(t.head).from, 1)), m5 = (n) => Ai(n, (t) => j.cursor(n.lineBlockAt(t.head).to, -1));
function g5(n, t, e) {
  let i = !1, s = ar(n.selection, (a) => {
    let o = Ni(n, a.head, -1) || Ni(n, a.head, 1) || a.head > 0 && Ni(n, a.head - 1, 1) || a.head < n.doc.length && Ni(n, a.head + 1, -1);
    if (!o || !o.end)
      return a;
    i = !0;
    let u = o.start.from == a.head ? o.end.to : o.end.from;
    return j.cursor(u);
  });
  return i ? (t(en(n, s)), !0) : !1;
}
const y5 = ({ state: n, dispatch: t }) => g5(n, t);
function xi(n, t) {
  let e = ar(n.state.selection, (i) => {
    let s = t(i);
    return j.range(i.anchor, s.head, s.goalColumn, s.bidiLevel || void 0);
  });
  return e.eq(n.state.selection) ? !1 : (n.dispatch(en(n.state, e)), !0);
}
function Sx(n, t) {
  return xi(n, (e) => n.moveByChar(e, t));
}
const Qx = (n) => Sx(n, !Ce(n)), vx = (n) => Sx(n, Ce(n));
function bx(n, t) {
  return xi(n, (e) => n.moveByGroup(e, t));
}
const S5 = (n) => bx(n, !Ce(n)), Q5 = (n) => bx(n, Ce(n)), v5 = (n) => xi(n, (t) => Gu(n.state, t, !Ce(n))), b5 = (n) => xi(n, (t) => Gu(n.state, t, Ce(n)));
function xx(n, t) {
  return xi(n, (e) => n.moveVertically(e, t));
}
const kx = (n) => xx(n, !1), wx = (n) => xx(n, !0);
function Tx(n, t) {
  return xi(n, (e) => n.moveVertically(e, t, gx(n).height));
}
const P1 = (n) => Tx(n, !1), R1 = (n) => Tx(n, !0), x5 = (n) => xi(n, (t) => pl(n, t, !0)), k5 = (n) => xi(n, (t) => pl(n, t, !1)), w5 = (n) => xi(n, (t) => pl(n, t, !Ce(n))), T5 = (n) => xi(n, (t) => pl(n, t, Ce(n))), $5 = (n) => xi(n, (t) => j.cursor(n.lineBlockAt(t.head).from)), P5 = (n) => xi(n, (t) => j.cursor(n.lineBlockAt(t.head).to)), A1 = ({ state: n, dispatch: t }) => (t(en(n, { anchor: 0 })), !0), M1 = ({ state: n, dispatch: t }) => (t(en(n, { anchor: n.doc.length })), !0), q1 = ({ state: n, dispatch: t }) => (t(en(n, { anchor: n.selection.main.anchor, head: 0 })), !0), C1 = ({ state: n, dispatch: t }) => (t(en(n, { anchor: n.selection.main.anchor, head: n.doc.length })), !0), R5 = ({ state: n, dispatch: t }) => (t(n.update({ selection: { anchor: 0, head: n.doc.length }, userEvent: "select" })), !0), A5 = ({ state: n, dispatch: t }) => {
  let e = Nu(n).map(({ from: i, to: s }) => j.range(i, Math.min(s + 1, n.doc.length)));
  return t(n.update({ selection: j.create(e), userEvent: "select" })), !0;
}, M5 = ({ state: n, dispatch: t }) => {
  let e = ar(n.selection, (i) => {
    let s = ue(n), a = s.resolveStack(i.from, 1);
    if (i.empty) {
      let o = s.resolveStack(i.from, -1);
      o.node.from >= a.node.from && o.node.to <= a.node.to && (a = o);
    }
    for (let o = a; o; o = o.next) {
      let { node: u } = o;
      if ((u.from < i.from && u.to >= i.to || u.to > i.to && u.from <= i.from) && o.next)
        return j.range(u.to, u.from);
    }
    return i;
  });
  return e.eq(n.selection) ? !1 : (t(en(n, e)), !0);
}, q5 = ({ state: n, dispatch: t }) => {
  let e = n.selection, i = null;
  return e.ranges.length > 1 ? i = j.create([e.main]) : e.main.empty || (i = j.create([j.cursor(e.main.head)])), i ? (t(en(n, i)), !0) : !1;
};
function io(n, t) {
  if (n.state.readOnly)
    return !1;
  let e = "delete.selection", { state: i } = n, s = i.changeByRange((a) => {
    let { from: o, to: u } = a;
    if (o == u) {
      let h = t(a);
      h < o ? (e = "delete.backward", h = Yc(n, h, !1)) : h > o && (e = "delete.forward", h = Yc(n, h, !0)), o = Math.min(o, h), u = Math.max(u, h);
    } else
      o = Yc(n, o, !1), u = Yc(n, u, !0);
    return o == u ? { range: a } : { changes: { from: o, to: u }, range: j.cursor(o, o < a.head ? -1 : 1) };
  });
  return s.changes.empty ? !1 : (n.dispatch(i.update(s, {
    scrollIntoView: !0,
    userEvent: e,
    effects: e == "delete.selection" ? it.announce.of(i.phrase("Selection deleted")) : void 0
  })), !0);
}
function Yc(n, t, e) {
  if (n instanceof it)
    for (let i of n.state.facet(it.atomicRanges).map((s) => s(n)))
      i.between(t, t, (s, a) => {
        s < t && a > t && (t = e ? a : s);
      });
  return t;
}
const $x = (n, t, e) => io(n, (i) => {
  let s = i.from, { state: a } = n, o = a.doc.lineAt(s), u, h;
  if (e && !t && s > o.from && s < o.from + 200 && !/[^ \t]/.test(u = o.text.slice(0, s - o.from))) {
    if (u[u.length - 1] == "	")
      return s - 1;
    let d = rr(u, a.tabSize), p = d % ku(a) || ku(a);
    for (let g = 0; g < p && u[u.length - 1 - g] == " "; g++)
      s--;
    h = s;
  } else
    h = Te(o.text, s - o.from, t, t) + o.from, h == s && o.number != (t ? a.doc.lines : 1) ? h += t ? 1 : -1 : !t && /[\ufe00-\ufe0f]/.test(o.text.slice(h - o.from, s - o.from)) && (h = Te(o.text, h - o.from, !1, !1) + o.from);
  return h;
}), tp = (n) => $x(n, !1, !0), Px = (n) => $x(n, !0, !1), Rx = (n, t) => io(n, (e) => {
  let i = e.head, { state: s } = n, a = s.doc.lineAt(i), o = s.charCategorizer(i);
  for (let u = null; ; ) {
    if (i == (t ? a.to : a.from)) {
      i == e.head && a.number != (t ? s.doc.lines : 1) && (i += t ? 1 : -1);
      break;
    }
    let h = Te(a.text, i - a.from, t) + a.from, d = a.text.slice(Math.min(i, h) - a.from, Math.max(i, h) - a.from), p = o(d);
    if (u != null && p != u)
      break;
    (d != " " || i != e.head) && (u = p), i = h;
  }
  return i;
}), Ax = (n) => Rx(n, !1), C5 = (n) => Rx(n, !0), Z5 = (n) => io(n, (t) => {
  let e = n.lineBlockAt(t.head).to;
  return t.head < e ? e : Math.min(n.state.doc.length, t.head + 1);
}), E5 = (n) => io(n, (t) => {
  let e = n.moveToLineBoundary(t, !1).head;
  return t.head > e ? e : Math.max(0, t.head - 1);
}), X5 = (n) => io(n, (t) => {
  let e = n.moveToLineBoundary(t, !0).head;
  return t.head < e ? e : Math.min(n.state.doc.length, t.head + 1);
}), _5 = ({ state: n, dispatch: t }) => {
  if (n.readOnly)
    return !1;
  let e = n.changeByRange((i) => ({
    changes: { from: i.from, to: i.to, insert: Rt.of(["", ""]) },
    range: j.cursor(i.from)
  }));
  return t(n.update(e, { scrollIntoView: !0, userEvent: "input" })), !0;
}, z5 = ({ state: n, dispatch: t }) => {
  if (n.readOnly)
    return !1;
  let e = n.changeByRange((i) => {
    if (!i.empty || i.from == 0 || i.from == n.doc.length)
      return { range: i };
    let s = i.from, a = n.doc.lineAt(s), o = s == a.from ? s - 1 : Te(a.text, s - a.from, !1) + a.from, u = s == a.to ? s + 1 : Te(a.text, s - a.from, !0) + a.from;
    return {
      changes: { from: o, to: u, insert: n.doc.slice(s, u).append(n.doc.slice(o, s)) },
      range: j.cursor(u)
    };
  });
  return e.changes.empty ? !1 : (t(n.update(e, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function Nu(n) {
  let t = [], e = -1;
  for (let i of n.selection.ranges) {
    let s = n.doc.lineAt(i.from), a = n.doc.lineAt(i.to);
    if (!i.empty && i.to == a.from && (a = n.doc.lineAt(i.to - 1)), e >= s.number) {
      let o = t[t.length - 1];
      o.to = a.to, o.ranges.push(i);
    } else
      t.push({ from: s.from, to: a.to, ranges: [i] });
    e = a.number + 1;
  }
  return t;
}
function Mx(n, t, e) {
  if (n.readOnly)
    return !1;
  let i = [], s = [];
  for (let a of Nu(n)) {
    if (e ? a.to == n.doc.length : a.from == 0)
      continue;
    let o = n.doc.lineAt(e ? a.to + 1 : a.from - 1), u = o.length + 1;
    if (e) {
      i.push({ from: a.to, to: o.to }, { from: a.from, insert: o.text + n.lineBreak });
      for (let h of a.ranges)
        s.push(j.range(Math.min(n.doc.length, h.anchor + u), Math.min(n.doc.length, h.head + u)));
    } else {
      i.push({ from: o.from, to: a.from }, { from: a.to, insert: n.lineBreak + o.text });
      for (let h of a.ranges)
        s.push(j.range(h.anchor - u, h.head - u));
    }
  }
  return i.length ? (t(n.update({
    changes: i,
    scrollIntoView: !0,
    selection: j.create(s, n.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const D5 = ({ state: n, dispatch: t }) => Mx(n, t, !1), V5 = ({ state: n, dispatch: t }) => Mx(n, t, !0);
function qx(n, t, e) {
  if (n.readOnly)
    return !1;
  let i = [];
  for (let s of Nu(n))
    e ? i.push({ from: s.from, insert: n.doc.slice(s.from, s.to) + n.lineBreak }) : i.push({ from: s.to, insert: n.lineBreak + n.doc.slice(s.from, s.to) });
  return t(n.update({ changes: i, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const Y5 = ({ state: n, dispatch: t }) => qx(n, t, !1), U5 = ({ state: n, dispatch: t }) => qx(n, t, !0), j5 = (n) => {
  if (n.state.readOnly)
    return !1;
  let { state: t } = n, e = t.changes(Nu(t).map(({ from: s, to: a }) => (s > 0 ? s-- : a < t.doc.length && a++, { from: s, to: a }))), i = ar(t.selection, (s) => {
    let a;
    if (n.lineWrapping) {
      let o = n.lineBlockAt(s.head), u = n.coordsAtPos(s.head, s.assoc || 1);
      u && (a = o.bottom + n.documentTop - u.bottom + n.defaultLineHeight / 2);
    }
    return n.moveVertically(s, !0, a);
  }).map(e);
  return n.dispatch({ changes: e, selection: i, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function L5(n, t) {
  if (/\(\)|\[\]|\{\}/.test(n.sliceDoc(t - 1, t + 1)))
    return { from: t, to: t };
  let e = ue(n).resolveInner(t), i = e.childBefore(t), s = e.childAfter(t), a;
  return i && s && i.to <= t && s.from >= t && (a = i.type.prop(kt.closedBy)) && a.indexOf(s.name) > -1 && n.doc.lineAt(i.to).from == n.doc.lineAt(s.from).from && !/\S/.test(n.sliceDoc(i.to, s.from)) ? { from: i.to, to: s.from } : null;
}
const Z1 = /* @__PURE__ */ Cx(!1), B5 = /* @__PURE__ */ Cx(!0);
function Cx(n) {
  return ({ state: t, dispatch: e }) => {
    if (t.readOnly)
      return !1;
    let i = t.changeByRange((s) => {
      let { from: a, to: o } = s, u = t.doc.lineAt(a), h = !n && a == o && L5(t, a);
      n && (a = o = (o <= u.to ? u : t.doc.lineAt(o)).to);
      let d = new Uu(t, { simulateBreak: a, simulateDoubleBreak: !!h }), p = Ep(d, a);
      for (p == null && (p = rr(/^\s*/.exec(t.doc.lineAt(a).text)[0], t.tabSize)); o < u.to && /\s/.test(u.text[o - u.from]); )
        o++;
      h ? { from: a, to: o } = h : a > u.from && a < u.from + 100 && !/\S/.test(u.text.slice(0, a)) && (a = u.from);
      let g = ["", Va(t, p)];
      return h && g.push(Va(t, d.lineIndent(u.from, -1))), {
        changes: { from: a, to: o, insert: Rt.of(g) },
        range: j.cursor(a + 1 + g[1].length)
      };
    });
    return e(t.update(i, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function Yp(n, t) {
  let e = -1;
  return n.changeByRange((i) => {
    let s = [];
    for (let o = i.from; o <= i.to; ) {
      let u = n.doc.lineAt(o);
      u.number > e && (i.empty || i.to > u.from) && (t(u, s, i), e = u.number), o = u.to + 1;
    }
    let a = n.changes(s);
    return {
      changes: s,
      range: j.range(a.mapPos(i.anchor, 1), a.mapPos(i.head, 1))
    };
  });
}
const G5 = ({ state: n, dispatch: t }) => {
  if (n.readOnly)
    return !1;
  let e = /* @__PURE__ */ Object.create(null), i = new Uu(n, { overrideIndentation: (a) => {
    let o = e[a];
    return o ?? -1;
  } }), s = Yp(n, (a, o, u) => {
    let h = Ep(i, a.from);
    if (h == null)
      return;
    /\S/.test(a.text) || (h = 0);
    let d = /^\s*/.exec(a.text)[0], p = Va(n, h);
    (d != p || u.from < a.from + d.length) && (e[a.from] = h, o.push({ from: a.from, to: a.from + d.length, insert: p }));
  });
  return s.changes.empty || t(n.update(s, { userEvent: "indent" })), !0;
}, Zx = ({ state: n, dispatch: t }) => n.readOnly ? !1 : (t(n.update(Yp(n, (e, i) => {
  i.push({ from: e.from, insert: n.facet(Fa) });
}), { userEvent: "input.indent" })), !0), Ex = ({ state: n, dispatch: t }) => n.readOnly ? !1 : (t(n.update(Yp(n, (e, i) => {
  let s = /^\s*/.exec(e.text)[0];
  if (!s)
    return;
  let a = rr(s, n.tabSize), o = 0, u = Va(n, Math.max(0, a - ku(n)));
  for (; o < s.length && o < u.length && s.charCodeAt(o) == u.charCodeAt(o); )
    o++;
  i.push({ from: e.from + o, to: e.from + s.length, insert: u.slice(o) });
}), { userEvent: "delete.dedent" })), !0), N5 = (n) => (n.setTabFocusMode(), !0), W5 = [
  { key: "Ctrl-b", run: fx, shift: Qx, preventDefault: !0 },
  { key: "Ctrl-f", run: hx, shift: vx },
  { key: "Ctrl-p", run: px, shift: kx },
  { key: "Ctrl-n", run: mx, shift: wx },
  { key: "Ctrl-a", run: p5, shift: $5 },
  { key: "Ctrl-e", run: m5, shift: P5 },
  { key: "Ctrl-d", run: Px },
  { key: "Ctrl-h", run: tp },
  { key: "Ctrl-k", run: Z5 },
  { key: "Ctrl-Alt-h", run: Ax },
  { key: "Ctrl-o", run: _5 },
  { key: "Ctrl-t", run: z5 },
  { key: "Ctrl-v", run: Fd }
], H5 = /* @__PURE__ */ [
  { key: "ArrowLeft", run: fx, shift: Qx, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: r5, shift: S5, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: O5, shift: w5, preventDefault: !0 },
  { key: "ArrowRight", run: hx, shift: vx, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: a5, shift: Q5, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: d5, shift: T5, preventDefault: !0 },
  { key: "ArrowUp", run: px, shift: kx, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: A1, shift: q1 },
  { mac: "Ctrl-ArrowUp", run: $1, shift: P1 },
  { key: "ArrowDown", run: mx, shift: wx, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: M1, shift: C1 },
  { mac: "Ctrl-ArrowDown", run: Fd, shift: R1 },
  { key: "PageUp", run: $1, shift: P1 },
  { key: "PageDown", run: Fd, shift: R1 },
  { key: "Home", run: h5, shift: k5, preventDefault: !0 },
  { key: "Mod-Home", run: A1, shift: q1 },
  { key: "End", run: f5, shift: x5, preventDefault: !0 },
  { key: "Mod-End", run: M1, shift: C1 },
  { key: "Enter", run: Z1, shift: Z1 },
  { key: "Mod-a", run: R5 },
  { key: "Backspace", run: tp, shift: tp },
  { key: "Delete", run: Px },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: Ax },
  { key: "Mod-Delete", mac: "Alt-Delete", run: C5 },
  { mac: "Mod-Backspace", run: E5 },
  { mac: "Mod-Delete", run: X5 }
].concat(/* @__PURE__ */ W5.map((n) => ({ mac: n.key, run: n.run, shift: n.shift }))), K5 = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: c5, shift: v5 },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: u5, shift: b5 },
  { key: "Alt-ArrowUp", run: D5 },
  { key: "Shift-Alt-ArrowUp", run: Y5 },
  { key: "Alt-ArrowDown", run: V5 },
  { key: "Shift-Alt-ArrowDown", run: U5 },
  { key: "Escape", run: q5 },
  { key: "Mod-Enter", run: B5 },
  { key: "Alt-l", mac: "Ctrl-l", run: A5 },
  { key: "Mod-i", run: M5, preventDefault: !0 },
  { key: "Mod-[", run: Ex },
  { key: "Mod-]", run: Zx },
  { key: "Mod-Alt-\\", run: G5 },
  { key: "Shift-Mod-k", run: j5 },
  { key: "Shift-Mod-\\", run: y5 },
  { key: "Mod-/", run: YA },
  { key: "Alt-A", run: jA },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: N5 }
].concat(H5), J5 = { key: "Tab", run: Zx, shift: Ex };
function Vt() {
  var n = arguments[0];
  typeof n == "string" && (n = document.createElement(n));
  var t = 1, e = arguments[1];
  if (e && typeof e == "object" && e.nodeType == null && !Array.isArray(e)) {
    for (var i in e) if (Object.prototype.hasOwnProperty.call(e, i)) {
      var s = e[i];
      typeof s == "string" ? n.setAttribute(i, s) : s != null && (n[i] = s);
    }
    t++;
  }
  for (; t < arguments.length; t++) Xx(n, arguments[t]);
  return n;
}
function Xx(n, t) {
  if (typeof t == "string")
    n.appendChild(document.createTextNode(t));
  else if (t != null) if (t.nodeType != null)
    n.appendChild(t);
  else if (Array.isArray(t))
    for (var e = 0; e < t.length; e++) Xx(n, t[e]);
  else
    throw new RangeError("Unsupported child node: " + t);
}
const E1 = typeof String.prototype.normalize == "function" ? (n) => n.normalize("NFKD") : (n) => n;
class lr {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(t, e, i = 0, s = t.length, a, o) {
    this.test = o, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = t.iterRange(i, s), this.bufferStart = i, this.normalize = a ? (u) => a(E1(u)) : E1, this.query = this.normalize(e);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return Ue(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let t = this.peek();
      if (t < 0)
        return this.done = !0, this;
      let e = Op(t), i = this.bufferStart + this.bufferPos;
      this.bufferPos += Li(t);
      let s = this.normalize(e);
      if (s.length)
        for (let a = 0, o = i; ; a++) {
          let u = s.charCodeAt(a), h = this.match(u, o, this.bufferPos + this.bufferStart);
          if (a == s.length - 1) {
            if (h)
              return this.value = h, this;
            break;
          }
          o == i && a < e.length && e.charCodeAt(a) == u && o++;
        }
    }
  }
  match(t, e, i) {
    let s = null;
    for (let a = 0; a < this.matches.length; a += 2) {
      let o = this.matches[a], u = !1;
      this.query.charCodeAt(o) == t && (o == this.query.length - 1 ? s = { from: this.matches[a + 1], to: i } : (this.matches[a]++, u = !0)), u || (this.matches.splice(a, 2), a -= 2);
    }
    return this.query.charCodeAt(0) == t && (this.query.length == 1 ? s = { from: e, to: i } : this.matches.push(1, e)), s && this.test && !this.test(s.from, s.to, this.buffer, this.bufferStart) && (s = null), s;
  }
}
typeof Symbol < "u" && (lr.prototype[Symbol.iterator] = function() {
  return this;
});
const _x = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, Up = "gm" + (/x/.unicode == null ? "" : "u");
class zx {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(t, e, i, s = 0, a = t.length) {
    if (this.text = t, this.to = a, this.curLine = "", this.done = !1, this.value = _x, /\\[sWDnr]|\n|\r|\[\^/.test(e))
      return new Dx(t, e, i, s, a);
    this.re = new RegExp(e, Up + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.iter = t.iter();
    let o = t.lineAt(s);
    this.curLineStart = o.from, this.matchPos = Pu(t, s), this.getLine(this.curLineStart);
  }
  getLine(t) {
    this.iter.next(t), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let t = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = t;
      let e = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (e) {
        let i = this.curLineStart + e.index, s = i + e[0].length;
        if (this.matchPos = Pu(this.text, s + (i == s ? 1 : 0)), i == this.curLineStart + this.curLine.length && this.nextLine(), (i < s || i > this.value.to) && (!this.test || this.test(i, s, e)))
          return this.value = { from: i, to: s, match: e }, this;
        t = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), t = 0;
      else
        return this.done = !0, this;
    }
  }
}
const LO = /* @__PURE__ */ new WeakMap();
class Hs {
  constructor(t, e) {
    this.from = t, this.text = e;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(t, e, i) {
    let s = LO.get(t);
    if (!s || s.from >= i || s.to <= e) {
      let u = new Hs(e, t.sliceString(e, i));
      return LO.set(t, u), u;
    }
    if (s.from == e && s.to == i)
      return s;
    let { text: a, from: o } = s;
    return o > e && (a = t.sliceString(e, o) + a, o = e), s.to < i && (a += t.sliceString(s.to, i)), LO.set(t, new Hs(o, a)), new Hs(e, a.slice(e - o, i - o));
  }
}
class Dx {
  constructor(t, e, i, s, a) {
    this.text = t, this.to = a, this.done = !1, this.value = _x, this.matchPos = Pu(t, s), this.re = new RegExp(e, Up + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.flat = Hs.get(t, s, this.chunkEnd(
      s + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(t) {
    return t >= this.to ? this.to : this.text.lineAt(t).to;
  }
  next() {
    for (; ; ) {
      let t = this.re.lastIndex = this.matchPos - this.flat.from, e = this.re.exec(this.flat.text);
      if (e && !e[0] && e.index == t && (this.re.lastIndex = t + 1, e = this.re.exec(this.flat.text)), e) {
        let i = this.flat.from + e.index, s = i + e[0].length;
        if ((this.flat.to >= this.to || e.index + e[0].length <= this.flat.text.length - 10) && (!this.test || this.test(i, s, e)))
          return this.value = { from: i, to: s, match: e }, this.matchPos = Pu(this.text, s + (i == s ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = Hs.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (zx.prototype[Symbol.iterator] = Dx.prototype[Symbol.iterator] = function() {
  return this;
});
function I5(n) {
  try {
    return new RegExp(n, Up), !0;
  } catch {
    return !1;
  }
}
function Pu(n, t) {
  if (t >= n.length)
    return t;
  let e = n.lineAt(t), i;
  for (; t < e.to && (i = e.text.charCodeAt(t - e.from)) >= 56320 && i < 57344; )
    t++;
  return t;
}
function ep(n) {
  let t = String(n.state.doc.lineAt(n.state.selection.main.head).number), e = Vt("input", { class: "cm-textfield", name: "line", value: t }), i = Vt("form", {
    class: "cm-gotoLine",
    onkeydown: (a) => {
      a.keyCode == 27 ? (a.preventDefault(), n.dispatch({ effects: Ra.of(!1) }), n.focus()) : a.keyCode == 13 && (a.preventDefault(), s());
    },
    onsubmit: (a) => {
      a.preventDefault(), s();
    }
  }, Vt("label", n.state.phrase("Go to line"), ": ", e), " ", Vt("button", { class: "cm-button", type: "submit" }, n.state.phrase("go")), Vt("button", {
    name: "close",
    onclick: () => {
      n.dispatch({ effects: Ra.of(!1) }), n.focus();
    },
    "aria-label": n.state.phrase("close"),
    type: "button"
  }, ["×"]));
  function s() {
    let a = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(e.value);
    if (!a)
      return;
    let { state: o } = n, u = o.doc.lineAt(o.selection.main.head), [, h, d, p, g] = a, y = p ? +p.slice(1) : 0, Q = d ? +d : u.number;
    if (d && g) {
      let P = Q / 100;
      h && (P = P * (h == "-" ? -1 : 1) + u.number / o.doc.lines), Q = Math.round(o.doc.lines * P);
    } else d && h && (Q = Q * (h == "-" ? -1 : 1) + u.number);
    let b = o.doc.line(Math.max(1, Math.min(o.doc.lines, Q))), x = j.cursor(b.from + Math.max(0, Math.min(y, b.length)));
    n.dispatch({
      effects: [Ra.of(!1), it.scrollIntoView(x.from, { y: "center" })],
      selection: x
    }), n.focus();
  }
  return { dom: i };
}
const Ra = /* @__PURE__ */ yt.define(), X1 = /* @__PURE__ */ Se.define({
  create() {
    return !0;
  },
  update(n, t) {
    for (let e of t.effects)
      e.is(Ra) && (n = e.value);
    return n;
  },
  provide: (n) => _a.from(n, (t) => t ? ep : null)
}), F5 = (n) => {
  let t = Xa(n, ep);
  if (!t) {
    let e = [Ra.of(!0)];
    n.state.field(X1, !1) == null && e.push(yt.appendConfig.of([X1, tM])), n.dispatch({ effects: e }), t = Xa(n, ep);
  }
  return t && t.dom.querySelector("input").select(), !0;
}, tM = /* @__PURE__ */ it.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    position: "relative",
    "& label": { fontSize: "80%" },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      bottom: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: "0"
    }
  }
}), eM = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, iM = /* @__PURE__ */ lt.define({
  combine(n) {
    return Fi(n, eM, {
      highlightWordAroundCursor: (t, e) => t || e,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function nM(n) {
  return [oM, aM];
}
const lM = /* @__PURE__ */ ft.mark({ class: "cm-selectionMatch" }), sM = /* @__PURE__ */ ft.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function _1(n, t, e, i) {
  return (e == 0 || n(t.sliceDoc(e - 1, e)) != Wt.Word) && (i == t.doc.length || n(t.sliceDoc(i, i + 1)) != Wt.Word);
}
function rM(n, t, e, i) {
  return n(t.sliceDoc(e, e + 1)) == Wt.Word && n(t.sliceDoc(i - 1, i)) == Wt.Word;
}
const aM = /* @__PURE__ */ ne.fromClass(class {
  constructor(n) {
    this.decorations = this.getDeco(n);
  }
  update(n) {
    (n.selectionSet || n.docChanged || n.viewportChanged) && (this.decorations = this.getDeco(n.view));
  }
  getDeco(n) {
    let t = n.state.facet(iM), { state: e } = n, i = e.selection;
    if (i.ranges.length > 1)
      return ft.none;
    let s = i.main, a, o = null;
    if (s.empty) {
      if (!t.highlightWordAroundCursor)
        return ft.none;
      let h = e.wordAt(s.head);
      if (!h)
        return ft.none;
      o = e.charCategorizer(s.head), a = e.sliceDoc(h.from, h.to);
    } else {
      let h = s.to - s.from;
      if (h < t.minSelectionLength || h > 200)
        return ft.none;
      if (t.wholeWords) {
        if (a = e.sliceDoc(s.from, s.to), o = e.charCategorizer(s.head), !(_1(o, e, s.from, s.to) && rM(o, e, s.from, s.to)))
          return ft.none;
      } else if (a = e.sliceDoc(s.from, s.to), !a)
        return ft.none;
    }
    let u = [];
    for (let h of n.visibleRanges) {
      let d = new lr(e.doc, a, h.from, h.to);
      for (; !d.next().done; ) {
        let { from: p, to: g } = d.value;
        if ((!o || _1(o, e, p, g)) && (s.empty && p <= s.from && g >= s.to ? u.push(sM.range(p, g)) : (p >= s.to || g <= s.from) && u.push(lM.range(p, g)), u.length > t.maxMatches))
          return ft.none;
      }
    }
    return ft.set(u);
  }
}, {
  decorations: (n) => n.decorations
}), oM = /* @__PURE__ */ it.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), cM = ({ state: n, dispatch: t }) => {
  let { selection: e } = n, i = j.create(e.ranges.map((s) => n.wordAt(s.head) || j.cursor(s.head)), e.mainIndex);
  return i.eq(e) ? !1 : (t(n.update({ selection: i })), !0);
};
function uM(n, t) {
  let { main: e, ranges: i } = n.selection, s = n.wordAt(e.head), a = s && s.from == e.from && s.to == e.to;
  for (let o = !1, u = new lr(n.doc, t, i[i.length - 1].to); ; )
    if (u.next(), u.done) {
      if (o)
        return null;
      u = new lr(n.doc, t, 0, Math.max(0, i[i.length - 1].from - 1)), o = !0;
    } else {
      if (o && i.some((h) => h.from == u.value.from))
        continue;
      if (a) {
        let h = n.wordAt(u.value.from);
        if (!h || h.from != u.value.from || h.to != u.value.to)
          continue;
      }
      return u.value;
    }
}
const fM = ({ state: n, dispatch: t }) => {
  let { ranges: e } = n.selection;
  if (e.some((a) => a.from === a.to))
    return cM({ state: n, dispatch: t });
  let i = n.sliceDoc(e[0].from, e[0].to);
  if (n.selection.ranges.some((a) => n.sliceDoc(a.from, a.to) != i))
    return !1;
  let s = uM(n, i);
  return s ? (t(n.update({
    selection: n.selection.addRange(j.range(s.from, s.to), !1),
    effects: it.scrollIntoView(s.to)
  })), !0) : !1;
}, or = /* @__PURE__ */ lt.define({
  combine(n) {
    return Fi(n, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (t) => new xM(t),
      scrollToMatch: (t) => it.scrollIntoView(t)
    });
  }
});
class Vx {
  /**
  Create a query object.
  */
  constructor(t) {
    this.search = t.search, this.caseSensitive = !!t.caseSensitive, this.literal = !!t.literal, this.regexp = !!t.regexp, this.replace = t.replace || "", this.valid = !!this.search && (!this.regexp || I5(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!t.wholeWord;
  }
  /**
  @internal
  */
  unquote(t) {
    return this.literal ? t : t.replace(/\\([nrt\\])/g, (e, i) => i == "n" ? `
` : i == "r" ? "\r" : i == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(t) {
    return this.search == t.search && this.replace == t.replace && this.caseSensitive == t.caseSensitive && this.regexp == t.regexp && this.wholeWord == t.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new pM(this) : new OM(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(t, e = 0, i) {
    let s = t.doc ? t : $t.create({ doc: t });
    return i == null && (i = s.doc.length), this.regexp ? Us(this, s, e, i) : Ys(this, s, e, i);
  }
}
class Yx {
  constructor(t) {
    this.spec = t;
  }
}
function Ys(n, t, e, i) {
  return new lr(t.doc, n.unquoted, e, i, n.caseSensitive ? void 0 : (s) => s.toLowerCase(), n.wholeWord ? hM(t.doc, t.charCategorizer(t.selection.main.head)) : void 0);
}
function hM(n, t) {
  return (e, i, s, a) => ((a > e || a + s.length < i) && (a = Math.max(0, e - 2), s = n.sliceString(a, Math.min(n.length, i + 2))), (t(Ru(s, e - a)) != Wt.Word || t(Au(s, e - a)) != Wt.Word) && (t(Au(s, i - a)) != Wt.Word || t(Ru(s, i - a)) != Wt.Word));
}
class OM extends Yx {
  constructor(t) {
    super(t);
  }
  nextMatch(t, e, i) {
    let s = Ys(this.spec, t, i, t.doc.length).nextOverlapping();
    if (s.done) {
      let a = Math.min(t.doc.length, e + this.spec.unquoted.length);
      s = Ys(this.spec, t, 0, a).nextOverlapping();
    }
    return s.done || s.value.from == e && s.value.to == i ? null : s.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(t, e, i) {
    for (let s = i; ; ) {
      let a = Math.max(e, s - 1e4 - this.spec.unquoted.length), o = Ys(this.spec, t, a, s), u = null;
      for (; !o.nextOverlapping().done; )
        u = o.value;
      if (u)
        return u;
      if (a == e)
        return null;
      s -= 1e4;
    }
  }
  prevMatch(t, e, i) {
    let s = this.prevMatchInRange(t, 0, e);
    return s || (s = this.prevMatchInRange(t, Math.max(0, i - this.spec.unquoted.length), t.doc.length)), s && (s.from != e || s.to != i) ? s : null;
  }
  getReplacement(t) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(t, e) {
    let i = Ys(this.spec, t, 0, t.doc.length), s = [];
    for (; !i.next().done; ) {
      if (s.length >= e)
        return null;
      s.push(i.value);
    }
    return s;
  }
  highlight(t, e, i, s) {
    let a = Ys(this.spec, t, Math.max(0, e - this.spec.unquoted.length), Math.min(i + this.spec.unquoted.length, t.doc.length));
    for (; !a.next().done; )
      s(a.value.from, a.value.to);
  }
}
function Us(n, t, e, i) {
  return new zx(t.doc, n.search, {
    ignoreCase: !n.caseSensitive,
    test: n.wholeWord ? dM(t.charCategorizer(t.selection.main.head)) : void 0
  }, e, i);
}
function Ru(n, t) {
  return n.slice(Te(n, t, !1), t);
}
function Au(n, t) {
  return n.slice(t, Te(n, t));
}
function dM(n) {
  return (t, e, i) => !i[0].length || (n(Ru(i.input, i.index)) != Wt.Word || n(Au(i.input, i.index)) != Wt.Word) && (n(Au(i.input, i.index + i[0].length)) != Wt.Word || n(Ru(i.input, i.index + i[0].length)) != Wt.Word);
}
class pM extends Yx {
  nextMatch(t, e, i) {
    let s = Us(this.spec, t, i, t.doc.length).next();
    return s.done && (s = Us(this.spec, t, 0, e).next()), s.done ? null : s.value;
  }
  prevMatchInRange(t, e, i) {
    for (let s = 1; ; s++) {
      let a = Math.max(
        e,
        i - s * 1e4
        /* FindPrev.ChunkSize */
      ), o = Us(this.spec, t, a, i), u = null;
      for (; !o.next().done; )
        u = o.value;
      if (u && (a == e || u.from > a + 10))
        return u;
      if (a == e)
        return null;
    }
  }
  prevMatch(t, e, i) {
    return this.prevMatchInRange(t, 0, e) || this.prevMatchInRange(t, i, t.doc.length);
  }
  getReplacement(t) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (e, i) => {
      if (i == "&")
        return t.match[0];
      if (i == "$")
        return "$";
      for (let s = i.length; s > 0; s--) {
        let a = +i.slice(0, s);
        if (a > 0 && a < t.match.length)
          return t.match[a] + i.slice(s);
      }
      return e;
    });
  }
  matchAll(t, e) {
    let i = Us(this.spec, t, 0, t.doc.length), s = [];
    for (; !i.next().done; ) {
      if (s.length >= e)
        return null;
      s.push(i.value);
    }
    return s;
  }
  highlight(t, e, i, s) {
    let a = Us(this.spec, t, Math.max(
      0,
      e - 250
      /* RegExp.HighlightMargin */
    ), Math.min(i + 250, t.doc.length));
    for (; !a.next().done; )
      s(a.value.from, a.value.to);
  }
}
const Ya = /* @__PURE__ */ yt.define(), jp = /* @__PURE__ */ yt.define(), al = /* @__PURE__ */ Se.define({
  create(n) {
    return new BO(ip(n).create(), null);
  },
  update(n, t) {
    for (let e of t.effects)
      e.is(Ya) ? n = new BO(e.value.create(), n.panel) : e.is(jp) && (n = new BO(n.query, e.value ? Lp : null));
    return n;
  },
  provide: (n) => _a.from(n, (t) => t.panel)
});
class BO {
  constructor(t, e) {
    this.query = t, this.panel = e;
  }
}
const mM = /* @__PURE__ */ ft.mark({ class: "cm-searchMatch" }), gM = /* @__PURE__ */ ft.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), yM = /* @__PURE__ */ ne.fromClass(class {
  constructor(n) {
    this.view = n, this.decorations = this.highlight(n.state.field(al));
  }
  update(n) {
    let t = n.state.field(al);
    (t != n.startState.field(al) || n.docChanged || n.selectionSet || n.viewportChanged) && (this.decorations = this.highlight(t));
  }
  highlight({ query: n, panel: t }) {
    if (!t || !n.spec.valid)
      return ft.none;
    let { view: e } = this, i = new Tn();
    for (let s = 0, a = e.visibleRanges, o = a.length; s < o; s++) {
      let { from: u, to: h } = a[s];
      for (; s < o - 1 && h > a[s + 1].from - 2 * 250; )
        h = a[++s].to;
      n.highlight(e.state, u, h, (d, p) => {
        let g = e.state.selection.ranges.some((y) => y.from == d && y.to == p);
        i.add(d, p, g ? gM : mM);
      });
    }
    return i.finish();
  }
}, {
  decorations: (n) => n.decorations
});
function no(n) {
  return (t) => {
    let e = t.state.field(al, !1);
    return e && e.query.spec.valid ? n(t, e) : Lx(t);
  };
}
const Mu = /* @__PURE__ */ no((n, { query: t }) => {
  let { to: e } = n.state.selection.main, i = t.nextMatch(n.state, e, e);
  if (!i)
    return !1;
  let s = j.single(i.from, i.to), a = n.state.facet(or);
  return n.dispatch({
    selection: s,
    effects: [Bp(n, i), a.scrollToMatch(s.main, n)],
    userEvent: "select.search"
  }), jx(n), !0;
}), qu = /* @__PURE__ */ no((n, { query: t }) => {
  let { state: e } = n, { from: i } = e.selection.main, s = t.prevMatch(e, i, i);
  if (!s)
    return !1;
  let a = j.single(s.from, s.to), o = n.state.facet(or);
  return n.dispatch({
    selection: a,
    effects: [Bp(n, s), o.scrollToMatch(a.main, n)],
    userEvent: "select.search"
  }), jx(n), !0;
}), SM = /* @__PURE__ */ no((n, { query: t }) => {
  let e = t.matchAll(n.state, 1e3);
  return !e || !e.length ? !1 : (n.dispatch({
    selection: j.create(e.map((i) => j.range(i.from, i.to))),
    userEvent: "select.search.matches"
  }), !0);
}), QM = ({ state: n, dispatch: t }) => {
  let e = n.selection;
  if (e.ranges.length > 1 || e.main.empty)
    return !1;
  let { from: i, to: s } = e.main, a = [], o = 0;
  for (let u = new lr(n.doc, n.sliceDoc(i, s)); !u.next().done; ) {
    if (a.length > 1e3)
      return !1;
    u.value.from == i && (o = a.length), a.push(j.range(u.value.from, u.value.to));
  }
  return t(n.update({
    selection: j.create(a, o),
    userEvent: "select.search.matches"
  })), !0;
}, z1 = /* @__PURE__ */ no((n, { query: t }) => {
  let { state: e } = n, { from: i, to: s } = e.selection.main;
  if (e.readOnly)
    return !1;
  let a = t.nextMatch(e, i, i);
  if (!a)
    return !1;
  let o = a, u = [], h, d, p = [];
  o.from == i && o.to == s && (d = e.toText(t.getReplacement(o)), u.push({ from: o.from, to: o.to, insert: d }), o = t.nextMatch(e, o.from, o.to), p.push(it.announce.of(e.phrase("replaced match on line $", e.doc.lineAt(i).number) + ".")));
  let g = n.state.changes(u);
  return o && (h = j.single(o.from, o.to).map(g), p.push(Bp(n, o)), p.push(e.facet(or).scrollToMatch(h.main, n))), n.dispatch({
    changes: g,
    selection: h,
    effects: p,
    userEvent: "input.replace"
  }), !0;
}), vM = /* @__PURE__ */ no((n, { query: t }) => {
  if (n.state.readOnly)
    return !1;
  let e = t.matchAll(n.state, 1e9).map((s) => {
    let { from: a, to: o } = s;
    return { from: a, to: o, insert: t.getReplacement(s) };
  });
  if (!e.length)
    return !1;
  let i = n.state.phrase("replaced $ matches", e.length) + ".";
  return n.dispatch({
    changes: e,
    effects: it.announce.of(i),
    userEvent: "input.replace.all"
  }), !0;
});
function Lp(n) {
  return n.state.facet(or).createPanel(n);
}
function ip(n, t) {
  var e, i, s, a, o;
  let u = n.selection.main, h = u.empty || u.to > u.from + 100 ? "" : n.sliceDoc(u.from, u.to);
  if (t && !h)
    return t;
  let d = n.facet(or);
  return new Vx({
    search: ((e = t == null ? void 0 : t.literal) !== null && e !== void 0 ? e : d.literal) ? h : h.replace(/\n/g, "\\n"),
    caseSensitive: (i = t == null ? void 0 : t.caseSensitive) !== null && i !== void 0 ? i : d.caseSensitive,
    literal: (s = t == null ? void 0 : t.literal) !== null && s !== void 0 ? s : d.literal,
    regexp: (a = t == null ? void 0 : t.regexp) !== null && a !== void 0 ? a : d.regexp,
    wholeWord: (o = t == null ? void 0 : t.wholeWord) !== null && o !== void 0 ? o : d.wholeWord
  });
}
function Ux(n) {
  let t = Xa(n, Lp);
  return t && t.dom.querySelector("[main-field]");
}
function jx(n) {
  let t = Ux(n);
  t && t == n.root.activeElement && t.select();
}
const Lx = (n) => {
  let t = n.state.field(al, !1);
  if (t && t.panel) {
    let e = Ux(n);
    if (e && e != n.root.activeElement) {
      let i = ip(n.state, t.query.spec);
      i.valid && n.dispatch({ effects: Ya.of(i) }), e.focus(), e.select();
    }
  } else
    n.dispatch({ effects: [
      jp.of(!0),
      t ? Ya.of(ip(n.state, t.query.spec)) : yt.appendConfig.of(wM)
    ] });
  return !0;
}, Bx = (n) => {
  let t = n.state.field(al, !1);
  if (!t || !t.panel)
    return !1;
  let e = Xa(n, Lp);
  return e && e.dom.contains(n.root.activeElement) && n.focus(), n.dispatch({ effects: jp.of(!1) }), !0;
}, bM = [
  { key: "Mod-f", run: Lx, scope: "editor search-panel" },
  { key: "F3", run: Mu, shift: qu, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: Mu, shift: qu, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: Bx, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: QM },
  { key: "Mod-Alt-g", run: F5 },
  { key: "Mod-d", run: fM, preventDefault: !0 }
];
class xM {
  constructor(t) {
    this.view = t;
    let e = this.query = t.state.field(al).query.spec;
    this.commit = this.commit.bind(this), this.searchField = Vt("input", {
      value: e.search,
      placeholder: li(t, "Find"),
      "aria-label": li(t, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = Vt("input", {
      value: e.replace,
      placeholder: li(t, "Replace"),
      "aria-label": li(t, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = Vt("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: e.caseSensitive,
      onchange: this.commit
    }), this.reField = Vt("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: e.regexp,
      onchange: this.commit
    }), this.wordField = Vt("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: e.wholeWord,
      onchange: this.commit
    });
    function i(s, a, o) {
      return Vt("button", { class: "cm-button", name: s, onclick: a, type: "button" }, o);
    }
    this.dom = Vt("div", { onkeydown: (s) => this.keydown(s), class: "cm-search" }, [
      this.searchField,
      i("next", () => Mu(t), [li(t, "next")]),
      i("prev", () => qu(t), [li(t, "previous")]),
      i("select", () => SM(t), [li(t, "all")]),
      Vt("label", null, [this.caseField, li(t, "match case")]),
      Vt("label", null, [this.reField, li(t, "regexp")]),
      Vt("label", null, [this.wordField, li(t, "by word")]),
      ...t.state.readOnly ? [] : [
        Vt("br"),
        this.replaceField,
        i("replace", () => z1(t), [li(t, "replace")]),
        i("replaceAll", () => vM(t), [li(t, "replace all")])
      ],
      Vt("button", {
        name: "close",
        onclick: () => Bx(t),
        "aria-label": li(t, "close"),
        type: "button"
      }, ["×"])
    ]);
  }
  commit() {
    let t = new Vx({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    t.eq(this.query) || (this.query = t, this.view.dispatch({ effects: Ya.of(t) }));
  }
  keydown(t) {
    EP(this.view, t, "search-panel") ? t.preventDefault() : t.keyCode == 13 && t.target == this.searchField ? (t.preventDefault(), (t.shiftKey ? qu : Mu)(this.view)) : t.keyCode == 13 && t.target == this.replaceField && (t.preventDefault(), z1(this.view));
  }
  update(t) {
    for (let e of t.transactions)
      for (let i of e.effects)
        i.is(Ya) && !i.value.eq(this.query) && this.setQuery(i.value);
  }
  setQuery(t) {
    this.query = t, this.searchField.value = t.search, this.replaceField.value = t.replace, this.caseField.checked = t.caseSensitive, this.reField.checked = t.regexp, this.wordField.checked = t.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(or).top;
  }
}
function li(n, t) {
  return n.state.phrase(t);
}
const Uc = 30, jc = /[\s\.,:;?!]/;
function Bp(n, { from: t, to: e }) {
  let i = n.state.doc.lineAt(t), s = n.state.doc.lineAt(e).to, a = Math.max(i.from, t - Uc), o = Math.min(s, e + Uc), u = n.state.sliceDoc(a, o);
  if (a != i.from) {
    for (let h = 0; h < Uc; h++)
      if (!jc.test(u[h + 1]) && jc.test(u[h])) {
        u = u.slice(h);
        break;
      }
  }
  if (o != s) {
    for (let h = u.length - 1; h > u.length - Uc; h--)
      if (!jc.test(u[h - 1]) && jc.test(u[h])) {
        u = u.slice(0, h);
        break;
      }
  }
  return it.announce.of(`${n.state.phrase("current match")}. ${u} ${n.state.phrase("on line")} ${i.number}.`);
}
const kM = /* @__PURE__ */ it.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), wM = [
  al,
  /* @__PURE__ */ dl.low(yM),
  kM
];
class Gx {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(t, e, i, s) {
    this.state = t, this.pos = e, this.explicit = i, this.view = s, this.abortListeners = [], this.abortOnDocChange = !1;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(t) {
    let e = ue(this.state).resolveInner(this.pos, -1);
    for (; e && t.indexOf(e.name) < 0; )
      e = e.parent;
    return e ? {
      from: e.from,
      to: this.pos,
      text: this.state.sliceDoc(e.from, this.pos),
      type: e.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(t) {
    let e = this.state.doc.lineAt(this.pos), i = Math.max(e.from, this.pos - 250), s = e.text.slice(i - e.from, this.pos - e.from), a = s.search(Wx(t, !1));
    return a < 0 ? null : { from: i + a, to: this.pos, text: s.slice(a) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(t, e, i) {
    t == "abort" && this.abortListeners && (this.abortListeners.push(e), i && i.onDocChange && (this.abortOnDocChange = !0));
  }
}
function D1(n) {
  let t = Object.keys(n).join(""), e = /\w/.test(t);
  return e && (t = t.replace(/\w/g, "")), `[${e ? "\\w" : ""}${t.replace(/[^\w\s]/g, "\\$&")}]`;
}
function TM(n) {
  let t = /* @__PURE__ */ Object.create(null), e = /* @__PURE__ */ Object.create(null);
  for (let { label: s } of n) {
    t[s[0]] = !0;
    for (let a = 1; a < s.length; a++)
      e[s[a]] = !0;
  }
  let i = D1(t) + D1(e) + "*$";
  return [new RegExp("^" + i), new RegExp(i)];
}
function Gp(n) {
  let t = n.map((s) => typeof s == "string" ? { label: s } : s), [e, i] = t.every((s) => /^\w+$/.test(s.label)) ? [/\w*$/, /\w+$/] : TM(t);
  return (s) => {
    let a = s.matchBefore(i);
    return a || s.explicit ? { from: a ? a.from : s.pos, options: t, validFor: e } : null;
  };
}
function Nx(n, t) {
  return (e) => {
    for (let i = ue(e.state).resolveInner(e.pos, -1); i; i = i.parent) {
      if (n.indexOf(i.name) > -1)
        return null;
      if (i.type.isTop)
        break;
    }
    return t(e);
  };
}
class V1 {
  constructor(t, e, i, s) {
    this.completion = t, this.source = e, this.match = i, this.score = s;
  }
}
function jl(n) {
  return n.selection.main.from;
}
function Wx(n, t) {
  var e;
  let { source: i } = n, s = t && i[0] != "^", a = i[i.length - 1] != "$";
  return !s && !a ? n : new RegExp(`${s ? "^" : ""}(?:${i})${a ? "$" : ""}`, (e = n.flags) !== null && e !== void 0 ? e : n.ignoreCase ? "i" : "");
}
const Np = /* @__PURE__ */ Ii.define();
function $M(n, t, e, i) {
  let { main: s } = n.selection, a = e - s.from, o = i - s.from;
  return Object.assign(Object.assign({}, n.changeByRange((u) => {
    if (u != s && e != i && n.sliceDoc(u.from + a, u.from + o) != n.sliceDoc(e, i))
      return { range: u };
    let h = n.toText(t);
    return {
      changes: { from: u.from + a, to: i == s.from ? u.to : u.from + o, insert: h },
      range: j.cursor(u.from + a + h.length)
    };
  })), { scrollIntoView: !0, userEvent: "input.complete" });
}
const Y1 = /* @__PURE__ */ new WeakMap();
function PM(n) {
  if (!Array.isArray(n))
    return n;
  let t = Y1.get(n);
  return t || Y1.set(n, t = Gp(n)), t;
}
const Cu = /* @__PURE__ */ yt.define(), Ua = /* @__PURE__ */ yt.define();
class RM {
  constructor(t) {
    this.pattern = t, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let e = 0; e < t.length; ) {
      let i = Ue(t, e), s = Li(i);
      this.chars.push(i);
      let a = t.slice(e, e + s), o = a.toUpperCase();
      this.folded.push(Ue(o == a ? a.toLowerCase() : o, 0)), e += s;
    }
    this.astral = t.length != this.chars.length;
  }
  ret(t, e) {
    return this.score = t, this.matched = e, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(t) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (t.length < this.pattern.length)
      return null;
    let { chars: e, folded: i, any: s, precise: a, byWord: o } = this;
    if (e.length == 1) {
      let V = Ue(t, 0), G = Li(V), H = G == t.length ? 0 : -100;
      if (V != e[0]) if (V == i[0])
        H += -200;
      else
        return null;
      return this.ret(H, [0, G]);
    }
    let u = t.indexOf(this.pattern);
    if (u == 0)
      return this.ret(t.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let h = e.length, d = 0;
    if (u < 0) {
      for (let V = 0, G = Math.min(t.length, 200); V < G && d < h; ) {
        let H = Ue(t, V);
        (H == e[d] || H == i[d]) && (s[d++] = V), V += Li(H);
      }
      if (d < h)
        return null;
    }
    let p = 0, g = 0, y = !1, Q = 0, b = -1, x = -1, P = /[a-z]/.test(t), A = !0;
    for (let V = 0, G = Math.min(t.length, 200), H = 0; V < G && g < h; ) {
      let _ = Ue(t, V);
      u < 0 && (p < h && _ == e[p] && (a[p++] = V), Q < h && (_ == e[Q] || _ == i[Q] ? (Q == 0 && (b = V), x = V + 1, Q++) : Q = 0));
      let W, q = _ < 255 ? _ >= 48 && _ <= 57 || _ >= 97 && _ <= 122 ? 2 : _ >= 65 && _ <= 90 ? 1 : 0 : (W = Op(_)) != W.toLowerCase() ? 1 : W != W.toUpperCase() ? 2 : 0;
      (!V || q == 1 && P || H == 0 && q != 0) && (e[g] == _ || i[g] == _ && (y = !0) ? o[g++] = V : o.length && (A = !1)), H = q, V += Li(_);
    }
    return g == h && o[0] == 0 && A ? this.result(-100 + (y ? -200 : 0), o, t) : Q == h && b == 0 ? this.ret(-200 - t.length + (x == t.length ? 0 : -100), [0, x]) : u > -1 ? this.ret(-700 - t.length, [u, u + this.pattern.length]) : Q == h ? this.ret(-900 - t.length, [b, x]) : g == h ? this.result(-100 + (y ? -200 : 0) + -700 + (A ? 0 : -1100), o, t) : e.length == 2 ? null : this.result((s[0] ? -700 : 0) + -200 + -1100, s, t);
  }
  result(t, e, i) {
    let s = [], a = 0;
    for (let o of e) {
      let u = o + (this.astral ? Li(Ue(i, o)) : 1);
      a && s[a - 1] == o ? s[a - 1] = u : (s[a++] = o, s[a++] = u);
    }
    return this.ret(t - i.length, s);
  }
}
class AM {
  constructor(t) {
    this.pattern = t, this.matched = [], this.score = 0, this.folded = t.toLowerCase();
  }
  match(t) {
    if (t.length < this.pattern.length)
      return null;
    let e = t.slice(0, this.pattern.length), i = e == this.pattern ? 0 : e.toLowerCase() == this.folded ? -200 : null;
    return i == null ? null : (this.matched = [0, e.length], this.score = i + (t.length == this.pattern.length ? 0 : -100), this);
  }
}
const ye = /* @__PURE__ */ lt.define({
  combine(n) {
    return Fi(n, {
      activateOnTyping: !0,
      activateOnCompletion: () => !1,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: MM,
      filterStrict: !1,
      compareCompletions: (t, e) => t.label.localeCompare(e.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (t, e) => t && e,
      closeOnBlur: (t, e) => t && e,
      icons: (t, e) => t && e,
      tooltipClass: (t, e) => (i) => U1(t(i), e(i)),
      optionClass: (t, e) => (i) => U1(t(i), e(i)),
      addToOptions: (t, e) => t.concat(e),
      filterStrict: (t, e) => t || e
    });
  }
});
function U1(n, t) {
  return n ? t ? n + " " + t : n : t;
}
function MM(n, t, e, i, s, a) {
  let o = n.textDirection == Bt.RTL, u = o, h = !1, d = "top", p, g, y = t.left - s.left, Q = s.right - t.right, b = i.right - i.left, x = i.bottom - i.top;
  if (u && y < Math.min(b, Q) ? u = !1 : !u && Q < Math.min(b, y) && (u = !0), b <= (u ? y : Q))
    p = Math.max(s.top, Math.min(e.top, s.bottom - x)) - t.top, g = Math.min(400, u ? y : Q);
  else {
    h = !0, g = Math.min(
      400,
      (o ? t.right : s.right - t.left) - 30
      /* Info.Margin */
    );
    let V = s.bottom - t.bottom;
    V >= x || V > t.top ? p = e.bottom - t.top : (d = "bottom", p = t.bottom - e.top);
  }
  let P = (t.bottom - t.top) / a.offsetHeight, A = (t.right - t.left) / a.offsetWidth;
  return {
    style: `${d}: ${p / P}px; max-width: ${g / A}px`,
    class: "cm-completionInfo-" + (h ? o ? "left-narrow" : "right-narrow" : u ? "left" : "right")
  };
}
function qM(n) {
  let t = n.addToOptions.slice();
  return n.icons && t.push({
    render(e) {
      let i = document.createElement("div");
      return i.classList.add("cm-completionIcon"), e.type && i.classList.add(...e.type.split(/\s+/g).map((s) => "cm-completionIcon-" + s)), i.setAttribute("aria-hidden", "true"), i;
    },
    position: 20
  }), t.push({
    render(e, i, s, a) {
      let o = document.createElement("span");
      o.className = "cm-completionLabel";
      let u = e.displayLabel || e.label, h = 0;
      for (let d = 0; d < a.length; ) {
        let p = a[d++], g = a[d++];
        p > h && o.appendChild(document.createTextNode(u.slice(h, p)));
        let y = o.appendChild(document.createElement("span"));
        y.appendChild(document.createTextNode(u.slice(p, g))), y.className = "cm-completionMatchedText", h = g;
      }
      return h < u.length && o.appendChild(document.createTextNode(u.slice(h))), o;
    },
    position: 50
  }, {
    render(e) {
      if (!e.detail)
        return null;
      let i = document.createElement("span");
      return i.className = "cm-completionDetail", i.textContent = e.detail, i;
    },
    position: 80
  }), t.sort((e, i) => e.position - i.position).map((e) => e.render);
}
function GO(n, t, e) {
  if (n <= e)
    return { from: 0, to: n };
  if (t < 0 && (t = 0), t <= n >> 1) {
    let s = Math.floor(t / e);
    return { from: s * e, to: (s + 1) * e };
  }
  let i = Math.floor((n - t) / e);
  return { from: n - (i + 1) * e, to: n - i * e };
}
class CM {
  constructor(t, e, i) {
    this.view = t, this.stateField = e, this.applyCompletion = i, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (h) => this.placeInfo(h),
      key: this
    }, this.space = null, this.currentClass = "";
    let s = t.state.field(e), { options: a, selected: o } = s.open, u = t.state.facet(ye);
    this.optionContent = qM(u), this.optionClass = u.optionClass, this.tooltipClass = u.tooltipClass, this.range = GO(a.length, o, u.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(t.state), this.dom.addEventListener("mousedown", (h) => {
      let { options: d } = t.state.field(e).open;
      for (let p = h.target, g; p && p != this.dom; p = p.parentNode)
        if (p.nodeName == "LI" && (g = /-(\d+)$/.exec(p.id)) && +g[1] < d.length) {
          this.applyCompletion(t, d[+g[1]]), h.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (h) => {
      let d = t.state.field(this.stateField, !1);
      d && d.tooltip && t.state.facet(ye).closeOnBlur && h.relatedTarget != t.contentDOM && t.dispatch({ effects: Ua.of(null) });
    }), this.showOptions(a, s.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(t, e) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(t, e, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(t) {
    var e;
    let i = t.state.field(this.stateField), s = t.startState.field(this.stateField);
    if (this.updateTooltipClass(t.state), i != s) {
      let { options: a, selected: o, disabled: u } = i.open;
      (!s.open || s.open.options != a) && (this.range = GO(a.length, o, t.state.facet(ye).maxRenderedOptions), this.showOptions(a, i.id)), this.updateSel(), u != ((e = s.open) === null || e === void 0 ? void 0 : e.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!u);
    }
  }
  updateTooltipClass(t) {
    let e = this.tooltipClass(t);
    if (e != this.currentClass) {
      for (let i of this.currentClass.split(" "))
        i && this.dom.classList.remove(i);
      for (let i of e.split(" "))
        i && this.dom.classList.add(i);
      this.currentClass = e;
    }
  }
  positioned(t) {
    this.space = t, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let t = this.view.state.field(this.stateField), e = t.open;
    if ((e.selected > -1 && e.selected < this.range.from || e.selected >= this.range.to) && (this.range = GO(e.options.length, e.selected, this.view.state.facet(ye).maxRenderedOptions), this.showOptions(e.options, t.id)), this.updateSelectedOption(e.selected)) {
      this.destroyInfo();
      let { completion: i } = e.options[e.selected], { info: s } = i;
      if (!s)
        return;
      let a = typeof s == "string" ? document.createTextNode(s) : s(i);
      if (!a)
        return;
      "then" in a ? a.then((o) => {
        o && this.view.state.field(this.stateField, !1) == t && this.addInfoPane(o, i);
      }).catch((o) => Be(this.view.state, o, "completion info")) : this.addInfoPane(a, i);
    }
  }
  addInfoPane(t, e) {
    this.destroyInfo();
    let i = this.info = document.createElement("div");
    if (i.className = "cm-tooltip cm-completionInfo", t.nodeType != null)
      i.appendChild(t), this.infoDestroy = null;
    else {
      let { dom: s, destroy: a } = t;
      i.appendChild(s), this.infoDestroy = a || null;
    }
    this.dom.appendChild(i), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(t) {
    let e = null;
    for (let i = this.list.firstChild, s = this.range.from; i; i = i.nextSibling, s++)
      i.nodeName != "LI" || !i.id ? s-- : s == t ? i.hasAttribute("aria-selected") || (i.setAttribute("aria-selected", "true"), e = i) : i.hasAttribute("aria-selected") && i.removeAttribute("aria-selected");
    return e && EM(this.list, e), e;
  }
  measureInfo() {
    let t = this.dom.querySelector("[aria-selected]");
    if (!t || !this.info)
      return null;
    let e = this.dom.getBoundingClientRect(), i = this.info.getBoundingClientRect(), s = t.getBoundingClientRect(), a = this.space;
    if (!a) {
      let o = this.dom.ownerDocument.documentElement;
      a = { left: 0, top: 0, right: o.clientWidth, bottom: o.clientHeight };
    }
    return s.top > Math.min(a.bottom, e.bottom) - 10 || s.bottom < Math.max(a.top, e.top) + 10 ? null : this.view.state.facet(ye).positionInfo(this.view, e, s, i, a, this.dom);
  }
  placeInfo(t) {
    this.info && (t ? (t.style && (this.info.style.cssText = t.style), this.info.className = "cm-tooltip cm-completionInfo " + (t.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(t, e, i) {
    const s = document.createElement("ul");
    s.id = e, s.setAttribute("role", "listbox"), s.setAttribute("aria-expanded", "true"), s.setAttribute("aria-label", this.view.state.phrase("Completions")), s.addEventListener("mousedown", (o) => {
      o.target == s && o.preventDefault();
    });
    let a = null;
    for (let o = i.from; o < i.to; o++) {
      let { completion: u, match: h } = t[o], { section: d } = u;
      if (d) {
        let y = typeof d == "string" ? d : d.name;
        if (y != a && (o > i.from || i.from == 0))
          if (a = y, typeof d != "string" && d.header)
            s.appendChild(d.header(d));
          else {
            let Q = s.appendChild(document.createElement("completion-section"));
            Q.textContent = y;
          }
      }
      const p = s.appendChild(document.createElement("li"));
      p.id = e + "-" + o, p.setAttribute("role", "option");
      let g = this.optionClass(u);
      g && (p.className = g);
      for (let y of this.optionContent) {
        let Q = y(u, this.view.state, this.view, h);
        Q && p.appendChild(Q);
      }
    }
    return i.from && s.classList.add("cm-completionListIncompleteTop"), i.to < t.length && s.classList.add("cm-completionListIncompleteBottom"), s;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function ZM(n, t) {
  return (e) => new CM(e, n, t);
}
function EM(n, t) {
  let e = n.getBoundingClientRect(), i = t.getBoundingClientRect(), s = e.height / n.offsetHeight;
  i.top < e.top ? n.scrollTop -= (e.top - i.top) / s : i.bottom > e.bottom && (n.scrollTop += (i.bottom - e.bottom) / s);
}
function j1(n) {
  return (n.boost || 0) * 100 + (n.apply ? 10 : 0) + (n.info ? 5 : 0) + (n.type ? 1 : 0);
}
function XM(n, t) {
  let e = [], i = null, s = (d) => {
    e.push(d);
    let { section: p } = d.completion;
    if (p) {
      i || (i = []);
      let g = typeof p == "string" ? p : p.name;
      i.some((y) => y.name == g) || i.push(typeof p == "string" ? { name: g } : p);
    }
  }, a = t.facet(ye);
  for (let d of n)
    if (d.hasResult()) {
      let p = d.result.getMatch;
      if (d.result.filter === !1)
        for (let g of d.result.options)
          s(new V1(g, d.source, p ? p(g) : [], 1e9 - e.length));
      else {
        let g = t.sliceDoc(d.from, d.to), y, Q = a.filterStrict ? new AM(g) : new RM(g);
        for (let b of d.result.options)
          if (y = Q.match(b.label)) {
            let x = b.displayLabel ? p ? p(b, y.matched) : [] : y.matched;
            s(new V1(b, d.source, x, y.score + (b.boost || 0)));
          }
      }
    }
  if (i) {
    let d = /* @__PURE__ */ Object.create(null), p = 0, g = (y, Q) => {
      var b, x;
      return ((b = y.rank) !== null && b !== void 0 ? b : 1e9) - ((x = Q.rank) !== null && x !== void 0 ? x : 1e9) || (y.name < Q.name ? -1 : 1);
    };
    for (let y of i.sort(g))
      p -= 1e5, d[y.name] = p;
    for (let y of e) {
      let { section: Q } = y.completion;
      Q && (y.score += d[typeof Q == "string" ? Q : Q.name]);
    }
  }
  let o = [], u = null, h = a.compareCompletions;
  for (let d of e.sort((p, g) => g.score - p.score || h(p.completion, g.completion))) {
    let p = d.completion;
    !u || u.label != p.label || u.detail != p.detail || u.type != null && p.type != null && u.type != p.type || u.apply != p.apply || u.boost != p.boost ? o.push(d) : j1(d.completion) > j1(u) && (o[o.length - 1] = d), u = d.completion;
  }
  return o;
}
class Bs {
  constructor(t, e, i, s, a, o) {
    this.options = t, this.attrs = e, this.tooltip = i, this.timestamp = s, this.selected = a, this.disabled = o;
  }
  setSelected(t, e) {
    return t == this.selected || t >= this.options.length ? this : new Bs(this.options, L1(e, t), this.tooltip, this.timestamp, t, this.disabled);
  }
  static build(t, e, i, s, a, o) {
    if (s && !o && t.some((d) => d.isPending))
      return s.setDisabled();
    let u = XM(t, e);
    if (!u.length)
      return s && t.some((d) => d.isPending) ? s.setDisabled() : null;
    let h = e.facet(ye).selectOnOpen ? 0 : -1;
    if (s && s.selected != h && s.selected != -1) {
      let d = s.options[s.selected].completion;
      for (let p = 0; p < u.length; p++)
        if (u[p].completion == d) {
          h = p;
          break;
        }
    }
    return new Bs(u, L1(i, h), {
      pos: t.reduce((d, p) => p.hasResult() ? Math.min(d, p.from) : d, 1e8),
      create: UM,
      above: a.aboveCursor
    }, s ? s.timestamp : Date.now(), h, !1);
  }
  map(t) {
    return new Bs(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: t.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new Bs(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, !0);
  }
}
class Zu {
  constructor(t, e, i) {
    this.active = t, this.id = e, this.open = i;
  }
  static start() {
    return new Zu(VM, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(t) {
    let { state: e } = t, i = e.facet(ye), a = (i.override || e.languageDataAt("autocomplete", jl(e)).map(PM)).map((h) => (this.active.find((p) => p.source == h) || new Qi(
      h,
      this.active.some(
        (p) => p.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(t, i));
    a.length == this.active.length && a.every((h, d) => h == this.active[d]) && (a = this.active);
    let o = this.open, u = t.effects.some((h) => h.is(Wp));
    o && t.docChanged && (o = o.map(t.changes)), t.selection || a.some((h) => h.hasResult() && t.changes.touchesRange(h.from, h.to)) || !_M(a, this.active) || u ? o = Bs.build(a, e, this.id, o, i, u) : o && o.disabled && !a.some((h) => h.isPending) && (o = null), !o && a.every((h) => !h.isPending) && a.some((h) => h.hasResult()) && (a = a.map((h) => h.hasResult() ? new Qi(
      h.source,
      0
      /* State.Inactive */
    ) : h));
    for (let h of t.effects)
      h.is(Kx) && (o = o && o.setSelected(h.value, this.id));
    return a == this.active && o == this.open ? this : new Zu(a, this.id, o);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? zM : DM;
  }
}
function _M(n, t) {
  if (n == t)
    return !0;
  for (let e = 0, i = 0; ; ) {
    for (; e < n.length && !n[e].hasResult(); )
      e++;
    for (; i < t.length && !t[i].hasResult(); )
      i++;
    let s = e == n.length, a = i == t.length;
    if (s || a)
      return s == a;
    if (n[e++].result != t[i++].result)
      return !1;
  }
}
const zM = {
  "aria-autocomplete": "list"
}, DM = {};
function L1(n, t) {
  let e = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": n
  };
  return t > -1 && (e["aria-activedescendant"] = n + "-" + t), e;
}
const VM = [];
function Hx(n, t) {
  if (n.isUserEvent("input.complete")) {
    let i = n.annotation(Np);
    if (i && t.activateOnCompletion(i))
      return 12;
  }
  let e = n.isUserEvent("input.type");
  return e && t.activateOnTyping ? 5 : e ? 1 : n.isUserEvent("delete.backward") ? 2 : n.selection ? 8 : n.docChanged ? 16 : 0;
}
class Qi {
  constructor(t, e, i = !1) {
    this.source = t, this.state = e, this.explicit = i;
  }
  hasResult() {
    return !1;
  }
  get isPending() {
    return this.state == 1;
  }
  update(t, e) {
    let i = Hx(t, e), s = this;
    (i & 8 || i & 16 && this.touches(t)) && (s = new Qi(
      s.source,
      0
      /* State.Inactive */
    )), i & 4 && s.state == 0 && (s = new Qi(
      this.source,
      1
      /* State.Pending */
    )), s = s.updateFor(t, i);
    for (let a of t.effects)
      if (a.is(Cu))
        s = new Qi(s.source, 1, a.value);
      else if (a.is(Ua))
        s = new Qi(
          s.source,
          0
          /* State.Inactive */
        );
      else if (a.is(Wp))
        for (let o of a.value)
          o.source == s.source && (s = o);
    return s;
  }
  updateFor(t, e) {
    return this.map(t.changes);
  }
  map(t) {
    return this;
  }
  touches(t) {
    return t.changes.touchesRange(jl(t.state));
  }
}
class Ks extends Qi {
  constructor(t, e, i, s, a, o) {
    super(t, 3, e), this.limit = i, this.result = s, this.from = a, this.to = o;
  }
  hasResult() {
    return !0;
  }
  updateFor(t, e) {
    var i;
    if (!(e & 3))
      return this.map(t.changes);
    let s = this.result;
    s.map && !t.changes.empty && (s = s.map(s, t.changes));
    let a = t.changes.mapPos(this.from), o = t.changes.mapPos(this.to, 1), u = jl(t.state);
    if (u > o || !s || e & 2 && (jl(t.startState) == this.from || u < this.limit))
      return new Qi(
        this.source,
        e & 4 ? 1 : 0
        /* State.Inactive */
      );
    let h = t.changes.mapPos(this.limit);
    return YM(s.validFor, t.state, a, o) ? new Ks(this.source, this.explicit, h, s, a, o) : s.update && (s = s.update(s, a, o, new Gx(t.state, u, !1))) ? new Ks(this.source, this.explicit, h, s, s.from, (i = s.to) !== null && i !== void 0 ? i : jl(t.state)) : new Qi(this.source, 1, this.explicit);
  }
  map(t) {
    return t.empty ? this : (this.result.map ? this.result.map(this.result, t) : this.result) ? new Ks(this.source, this.explicit, t.mapPos(this.limit), this.result, t.mapPos(this.from), t.mapPos(this.to, 1)) : new Qi(
      this.source,
      0
      /* State.Inactive */
    );
  }
  touches(t) {
    return t.changes.touchesRange(this.from, this.to);
  }
}
function YM(n, t, e, i) {
  if (!n)
    return !1;
  let s = t.sliceDoc(e, i);
  return typeof n == "function" ? n(s, e, i, t) : Wx(n, !0).test(s);
}
const Wp = /* @__PURE__ */ yt.define({
  map(n, t) {
    return n.map((e) => e.map(t));
  }
}), Kx = /* @__PURE__ */ yt.define(), Le = /* @__PURE__ */ Se.define({
  create() {
    return Zu.start();
  },
  update(n, t) {
    return n.update(t);
  },
  provide: (n) => [
    Pp.from(n, (t) => t.tooltip),
    it.contentAttributes.from(n, (t) => t.attrs)
  ]
});
function Hp(n, t) {
  const e = t.completion.apply || t.completion.label;
  let i = n.state.field(Le).active.find((s) => s.source == t.source);
  return i instanceof Ks ? (typeof e == "string" ? n.dispatch(Object.assign(Object.assign({}, $M(n.state, e, i.from, i.to)), { annotations: Np.of(t.completion) })) : e(n, t.completion, i.from, i.to), !0) : !1;
}
const UM = /* @__PURE__ */ ZM(Le, Hp);
function Lc(n, t = "option") {
  return (e) => {
    let i = e.state.field(Le, !1);
    if (!i || !i.open || i.open.disabled || Date.now() - i.open.timestamp < e.state.facet(ye).interactionDelay)
      return !1;
    let s = 1, a;
    t == "page" && (a = Pb(e, i.open.tooltip)) && (s = Math.max(2, Math.floor(a.dom.offsetHeight / a.dom.querySelector("li").offsetHeight) - 1));
    let { length: o } = i.open.options, u = i.open.selected > -1 ? i.open.selected + s * (n ? 1 : -1) : n ? 0 : o - 1;
    return u < 0 ? u = t == "page" ? 0 : o - 1 : u >= o && (u = t == "page" ? o - 1 : 0), e.dispatch({ effects: Kx.of(u) }), !0;
  };
}
const jM = (n) => {
  let t = n.state.field(Le, !1);
  return n.state.readOnly || !t || !t.open || t.open.selected < 0 || t.open.disabled || Date.now() - t.open.timestamp < n.state.facet(ye).interactionDelay ? !1 : Hp(n, t.open.options[t.open.selected]);
}, B1 = (n) => n.state.field(Le, !1) ? (n.dispatch({ effects: Cu.of(!0) }), !0) : !1, LM = (n) => {
  let t = n.state.field(Le, !1);
  return !t || !t.active.some(
    (e) => e.state != 0
    /* State.Inactive */
  ) ? !1 : (n.dispatch({ effects: Ua.of(null) }), !0);
};
class BM {
  constructor(t, e) {
    this.active = t, this.context = e, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const GM = 50, NM = 1e3, WM = /* @__PURE__ */ ne.fromClass(class {
  constructor(n) {
    this.view = n, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let t of n.state.field(Le).active)
      t.isPending && this.startQuery(t);
  }
  update(n) {
    let t = n.state.field(Le), e = n.state.facet(ye);
    if (!n.selectionSet && !n.docChanged && n.startState.field(Le) == t)
      return;
    let i = n.transactions.some((a) => {
      let o = Hx(a, e);
      return o & 8 || (a.selection || a.docChanged) && !(o & 3);
    });
    for (let a = 0; a < this.running.length; a++) {
      let o = this.running[a];
      if (i || o.context.abortOnDocChange && n.docChanged || o.updates.length + n.transactions.length > GM && Date.now() - o.time > NM) {
        for (let u of o.context.abortListeners)
          try {
            u();
          } catch (h) {
            Be(this.view.state, h);
          }
        o.context.abortListeners = null, this.running.splice(a--, 1);
      } else
        o.updates.push(...n.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), n.transactions.some((a) => a.effects.some((o) => o.is(Cu))) && (this.pendingStart = !0);
    let s = this.pendingStart ? 50 : e.activateOnTypingDelay;
    if (this.debounceUpdate = t.active.some((a) => a.isPending && !this.running.some((o) => o.active.source == a.source)) ? setTimeout(() => this.startUpdate(), s) : -1, this.composing != 0)
      for (let a of n.transactions)
        a.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && a.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: n } = this.view, t = n.field(Le);
    for (let e of t.active)
      e.isPending && !this.running.some((i) => i.active.source == e.source) && this.startQuery(e);
    this.running.length && t.open && t.open.disabled && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(ye).updateSyncTime));
  }
  startQuery(n) {
    let { state: t } = this.view, e = jl(t), i = new Gx(t, e, n.explicit, this.view), s = new BM(n, i);
    this.running.push(s), Promise.resolve(n.source(i)).then((a) => {
      s.context.aborted || (s.done = a || null, this.scheduleAccept());
    }, (a) => {
      this.view.dispatch({ effects: Ua.of(null) }), Be(this.view.state, a);
    });
  }
  scheduleAccept() {
    this.running.every((n) => n.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(ye).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var n;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let t = [], e = this.view.state.facet(ye), i = this.view.state.field(Le);
    for (let s = 0; s < this.running.length; s++) {
      let a = this.running[s];
      if (a.done === void 0)
        continue;
      if (this.running.splice(s--, 1), a.done) {
        let u = jl(a.updates.length ? a.updates[0].startState : this.view.state), h = Math.min(u, a.done.from + (a.active.explicit ? 0 : 1)), d = new Ks(a.active.source, a.active.explicit, h, a.done, a.done.from, (n = a.done.to) !== null && n !== void 0 ? n : u);
        for (let p of a.updates)
          d = d.update(p, e);
        if (d.hasResult()) {
          t.push(d);
          continue;
        }
      }
      let o = i.active.find((u) => u.source == a.active.source);
      if (o && o.isPending)
        if (a.done == null) {
          let u = new Qi(
            a.active.source,
            0
            /* State.Inactive */
          );
          for (let h of a.updates)
            u = u.update(h, e);
          u.isPending || t.push(u);
        } else
          this.startQuery(o);
    }
    (t.length || i.open && i.open.disabled) && this.view.dispatch({ effects: Wp.of(t) });
  }
}, {
  eventHandlers: {
    blur(n) {
      let t = this.view.state.field(Le, !1);
      if (t && t.tooltip && this.view.state.facet(ye).closeOnBlur) {
        let e = t.open && Pb(this.view, t.open.tooltip);
        (!e || !e.dom.contains(n.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: Ua.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: Cu.of(!1) }), 20), this.composing = 0;
    }
  }
}), HM = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform), KM = /* @__PURE__ */ dl.highest(/* @__PURE__ */ it.domEventHandlers({
  keydown(n, t) {
    let e = t.state.field(Le, !1);
    if (!e || !e.open || e.open.disabled || e.open.selected < 0 || n.key.length > 1 || n.ctrlKey && !(HM && n.altKey) || n.metaKey)
      return !1;
    let i = e.open.options[e.open.selected], s = e.active.find((o) => o.source == i.source), a = i.completion.commitCharacters || s.result.commitCharacters;
    return a && a.indexOf(n.key) > -1 && Hp(t, i), !1;
  }
})), Jx = /* @__PURE__ */ it.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class JM {
  constructor(t, e, i, s) {
    this.field = t, this.line = e, this.from = i, this.to = s;
  }
}
class Kp {
  constructor(t, e, i) {
    this.field = t, this.from = e, this.to = i;
  }
  map(t) {
    let e = t.mapPos(this.from, -1, we.TrackDel), i = t.mapPos(this.to, 1, we.TrackDel);
    return e == null || i == null ? null : new Kp(this.field, e, i);
  }
}
class Jp {
  constructor(t, e) {
    this.lines = t, this.fieldPositions = e;
  }
  instantiate(t, e) {
    let i = [], s = [e], a = t.doc.lineAt(e), o = /^\s*/.exec(a.text)[0];
    for (let h of this.lines) {
      if (i.length) {
        let d = o, p = /^\t*/.exec(h)[0].length;
        for (let g = 0; g < p; g++)
          d += t.facet(Fa);
        s.push(e + d.length - p), h = d + h.slice(p);
      }
      i.push(h), e += h.length + 1;
    }
    let u = this.fieldPositions.map((h) => new Kp(h.field, s[h.line] + h.from, s[h.line] + h.to));
    return { text: i, ranges: u };
  }
  static parse(t) {
    let e = [], i = [], s = [], a;
    for (let o of t.split(/\r\n?|\n/)) {
      for (; a = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(o); ) {
        let u = a[1] ? +a[1] : null, h = a[2] || a[3] || "", d = -1, p = h.replace(/\\[{}]/g, (g) => g[1]);
        for (let g = 0; g < e.length; g++)
          (u != null ? e[g].seq == u : p && e[g].name == p) && (d = g);
        if (d < 0) {
          let g = 0;
          for (; g < e.length && (u == null || e[g].seq != null && e[g].seq < u); )
            g++;
          e.splice(g, 0, { seq: u, name: p }), d = g;
          for (let y of s)
            y.field >= d && y.field++;
        }
        s.push(new JM(d, i.length, a.index, a.index + p.length)), o = o.slice(0, a.index) + h + o.slice(a.index + a[0].length);
      }
      o = o.replace(/\\([{}])/g, (u, h, d) => {
        for (let p of s)
          p.line == i.length && p.from > d && (p.from--, p.to--);
        return h;
      }), i.push(o);
    }
    return new Jp(i, s);
  }
}
let IM = /* @__PURE__ */ ft.widget({ widget: /* @__PURE__ */ new class extends tn {
  toDOM() {
    let n = document.createElement("span");
    return n.className = "cm-snippetFieldPosition", n;
  }
  ignoreEvent() {
    return !1;
  }
}() }), FM = /* @__PURE__ */ ft.mark({ class: "cm-snippetField" });
class cr {
  constructor(t, e) {
    this.ranges = t, this.active = e, this.deco = ft.set(t.map((i) => (i.from == i.to ? IM : FM).range(i.from, i.to)));
  }
  map(t) {
    let e = [];
    for (let i of this.ranges) {
      let s = i.map(t);
      if (!s)
        return null;
      e.push(s);
    }
    return new cr(e, this.active);
  }
  selectionInsideField(t) {
    return t.ranges.every((e) => this.ranges.some((i) => i.field == this.active && i.from <= e.from && i.to >= e.to));
  }
}
const lo = /* @__PURE__ */ yt.define({
  map(n, t) {
    return n && n.map(t);
  }
}), tq = /* @__PURE__ */ yt.define(), ja = /* @__PURE__ */ Se.define({
  create() {
    return null;
  },
  update(n, t) {
    for (let e of t.effects) {
      if (e.is(lo))
        return e.value;
      if (e.is(tq) && n)
        return new cr(n.ranges, e.value);
    }
    return n && t.docChanged && (n = n.map(t.changes)), n && t.selection && !n.selectionInsideField(t.selection) && (n = null), n;
  },
  provide: (n) => it.decorations.from(n, (t) => t ? t.deco : ft.none)
});
function Ip(n, t) {
  return j.create(n.filter((e) => e.field == t).map((e) => j.range(e.from, e.to)));
}
function eq(n) {
  let t = Jp.parse(n);
  return (e, i, s, a) => {
    let { text: o, ranges: u } = t.instantiate(e.state, s), { main: h } = e.state.selection, d = {
      changes: { from: s, to: a == h.from ? h.to : a, insert: Rt.of(o) },
      scrollIntoView: !0,
      annotations: i ? [Np.of(i), oe.userEvent.of("input.complete")] : void 0
    };
    if (u.length && (d.selection = Ip(u, 0)), u.some((p) => p.field > 0)) {
      let p = new cr(u, 0), g = d.effects = [lo.of(p)];
      e.state.field(ja, !1) === void 0 && g.push(yt.appendConfig.of([ja, rq, aq, Jx]));
    }
    e.dispatch(e.state.update(d));
  };
}
function Ix(n) {
  return ({ state: t, dispatch: e }) => {
    let i = t.field(ja, !1);
    if (!i || n < 0 && i.active == 0)
      return !1;
    let s = i.active + n, a = n > 0 && !i.ranges.some((o) => o.field == s + n);
    return e(t.update({
      selection: Ip(i.ranges, s),
      effects: lo.of(a ? null : new cr(i.ranges, s)),
      scrollIntoView: !0
    })), !0;
  };
}
const iq = ({ state: n, dispatch: t }) => n.field(ja, !1) ? (t(n.update({ effects: lo.of(null) })), !0) : !1, nq = /* @__PURE__ */ Ix(1), lq = /* @__PURE__ */ Ix(-1), sq = [
  { key: "Tab", run: nq, shift: lq },
  { key: "Escape", run: iq }
], G1 = /* @__PURE__ */ lt.define({
  combine(n) {
    return n.length ? n[0] : sq;
  }
}), rq = /* @__PURE__ */ dl.highest(/* @__PURE__ */ Jl.compute([G1], (n) => n.facet(G1)));
function Kt(n, t) {
  return Object.assign(Object.assign({}, t), { apply: eq(n) });
}
const aq = /* @__PURE__ */ it.domEventHandlers({
  mousedown(n, t) {
    let e = t.state.field(ja, !1), i;
    if (!e || (i = t.posAtCoords({ x: n.clientX, y: n.clientY })) == null)
      return !1;
    let s = e.ranges.find((a) => a.from <= i && a.to >= i);
    return !s || s.field == e.active ? !1 : (t.dispatch({
      selection: Ip(e.ranges, s.field),
      effects: lo.of(e.ranges.some((a) => a.field > s.field) ? new cr(e.ranges, s.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), La = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, Yl = /* @__PURE__ */ yt.define({
  map(n, t) {
    let e = t.mapPos(n, -1, we.TrackAfter);
    return e ?? void 0;
  }
}), Fp = /* @__PURE__ */ new class extends Bl {
}();
Fp.startSide = 1;
Fp.endSide = -1;
const Fx = /* @__PURE__ */ Se.define({
  create() {
    return Mt.empty;
  },
  update(n, t) {
    if (n = n.map(t.changes), t.selection) {
      let e = t.state.doc.lineAt(t.selection.main.head);
      n = n.update({ filter: (i) => i >= e.from && i <= e.to });
    }
    for (let e of t.effects)
      e.is(Yl) && (n = n.update({ add: [Fp.range(e.value, e.value + 1)] }));
    return n;
  }
});
function oq() {
  return [uq, Fx];
}
const NO = "()[]{}<>«»»«［］｛｝";
function tk(n) {
  for (let t = 0; t < NO.length; t += 2)
    if (NO.charCodeAt(t) == n)
      return NO.charAt(t + 1);
  return Op(n < 128 ? n : n + 1);
}
function ek(n, t) {
  return n.languageDataAt("closeBrackets", t)[0] || La;
}
const cq = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), uq = /* @__PURE__ */ it.inputHandler.of((n, t, e, i) => {
  if ((cq ? n.composing : n.compositionStarted) || n.state.readOnly)
    return !1;
  let s = n.state.selection.main;
  if (i.length > 2 || i.length == 2 && Li(Ue(i, 0)) == 1 || t != s.from || e != s.to)
    return !1;
  let a = Oq(n.state, i);
  return a ? (n.dispatch(a), !0) : !1;
}), fq = ({ state: n, dispatch: t }) => {
  if (n.readOnly)
    return !1;
  let i = ek(n, n.selection.main.head).brackets || La.brackets, s = null, a = n.changeByRange((o) => {
    if (o.empty) {
      let u = dq(n.doc, o.head);
      for (let h of i)
        if (h == u && Wu(n.doc, o.head) == tk(Ue(h, 0)))
          return {
            changes: { from: o.head - h.length, to: o.head + h.length },
            range: j.cursor(o.head - h.length)
          };
    }
    return { range: s = o };
  });
  return s || t(n.update(a, { scrollIntoView: !0, userEvent: "delete.backward" })), !s;
}, hq = [
  { key: "Backspace", run: fq }
];
function Oq(n, t) {
  let e = ek(n, n.selection.main.head), i = e.brackets || La.brackets;
  for (let s of i) {
    let a = tk(Ue(s, 0));
    if (t == s)
      return a == s ? gq(n, s, i.indexOf(s + s + s) > -1, e) : pq(n, s, a, e.before || La.before);
    if (t == a && ik(n, n.selection.main.from))
      return mq(n, s, a);
  }
  return null;
}
function ik(n, t) {
  let e = !1;
  return n.field(Fx).between(0, n.doc.length, (i) => {
    i == t && (e = !0);
  }), e;
}
function Wu(n, t) {
  let e = n.sliceString(t, t + 2);
  return e.slice(0, Li(Ue(e, 0)));
}
function dq(n, t) {
  let e = n.sliceString(t - 2, t);
  return Li(Ue(e, 0)) == e.length ? e : e.slice(1);
}
function pq(n, t, e, i) {
  let s = null, a = n.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: t, from: o.from }, { insert: e, from: o.to }],
        effects: Yl.of(o.to + t.length),
        range: j.range(o.anchor + t.length, o.head + t.length)
      };
    let u = Wu(n.doc, o.head);
    return !u || /\s/.test(u) || i.indexOf(u) > -1 ? {
      changes: { insert: t + e, from: o.head },
      effects: Yl.of(o.head + t.length),
      range: j.cursor(o.head + t.length)
    } : { range: s = o };
  });
  return s ? null : n.update(a, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function mq(n, t, e) {
  let i = null, s = n.changeByRange((a) => a.empty && Wu(n.doc, a.head) == e ? {
    changes: { from: a.head, to: a.head + e.length, insert: e },
    range: j.cursor(a.head + e.length)
  } : i = { range: a });
  return i ? null : n.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function gq(n, t, e, i) {
  let s = i.stringPrefixes || La.stringPrefixes, a = null, o = n.changeByRange((u) => {
    if (!u.empty)
      return {
        changes: [{ insert: t, from: u.from }, { insert: t, from: u.to }],
        effects: Yl.of(u.to + t.length),
        range: j.range(u.anchor + t.length, u.head + t.length)
      };
    let h = u.head, d = Wu(n.doc, h), p;
    if (d == t) {
      if (N1(n, h))
        return {
          changes: { insert: t + t, from: h },
          effects: Yl.of(h + t.length),
          range: j.cursor(h + t.length)
        };
      if (ik(n, h)) {
        let y = e && n.sliceDoc(h, h + t.length * 3) == t + t + t ? t + t + t : t;
        return {
          changes: { from: h, to: h + y.length, insert: y },
          range: j.cursor(h + y.length)
        };
      }
    } else {
      if (e && n.sliceDoc(h - 2 * t.length, h) == t + t && (p = W1(n, h - 2 * t.length, s)) > -1 && N1(n, p))
        return {
          changes: { insert: t + t + t + t, from: h },
          effects: Yl.of(h + t.length),
          range: j.cursor(h + t.length)
        };
      if (n.charCategorizer(h)(d) != Wt.Word && W1(n, h, s) > -1 && !yq(n, h, t, s))
        return {
          changes: { insert: t + t, from: h },
          effects: Yl.of(h + t.length),
          range: j.cursor(h + t.length)
        };
    }
    return { range: a = u };
  });
  return a ? null : n.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function N1(n, t) {
  let e = ue(n).resolveInner(t + 1);
  return e.parent && e.from == t;
}
function yq(n, t, e, i) {
  let s = ue(n).resolveInner(t, -1), a = i.reduce((o, u) => Math.max(o, u.length), 0);
  for (let o = 0; o < 5; o++) {
    let u = n.sliceDoc(s.from, Math.min(s.to, s.from + e.length + a)), h = u.indexOf(e);
    if (!h || h > -1 && i.indexOf(u.slice(0, h)) > -1) {
      let p = s.firstChild;
      for (; p && p.from == s.from && p.to - p.from > e.length + h; ) {
        if (n.sliceDoc(p.to - e.length, p.to) == e)
          return !1;
        p = p.firstChild;
      }
      return !0;
    }
    let d = s.to == t && s.parent;
    if (!d)
      break;
    s = d;
  }
  return !1;
}
function W1(n, t, e) {
  let i = n.charCategorizer(t);
  if (i(n.sliceDoc(t - 1, t)) != Wt.Word)
    return t;
  for (let s of e) {
    let a = t - s.length;
    if (n.sliceDoc(a, t) == s && i(n.sliceDoc(a - 1, a)) != Wt.Word)
      return a;
  }
  return -1;
}
function Sq(n = {}) {
  return [
    KM,
    Le,
    ye.of(n),
    WM,
    Qq,
    Jx
  ];
}
const nk = [
  { key: "Ctrl-Space", run: B1 },
  { mac: "Alt-`", run: B1 },
  { key: "Escape", run: LM },
  { key: "ArrowDown", run: /* @__PURE__ */ Lc(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ Lc(!1) },
  { key: "PageDown", run: /* @__PURE__ */ Lc(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ Lc(!1, "page") },
  { key: "Enter", run: jM }
], Qq = /* @__PURE__ */ dl.highest(/* @__PURE__ */ Jl.computeN([ye], (n) => n.facet(ye).defaultKeymap ? [nk] : []));
class H1 {
  constructor(t, e, i) {
    this.from = t, this.to = e, this.diagnostic = i;
  }
}
class Dl {
  constructor(t, e, i) {
    this.diagnostics = t, this.panel = e, this.selected = i;
  }
  static init(t, e, i) {
    let s = i.facet(Ba).markerFilter;
    s && (t = s(t, i));
    let a = t.slice().sort((p, g) => p.from - g.from || p.to - g.to), o = new Tn(), u = [], h = 0;
    for (let p = 0; ; ) {
      let g = p == a.length ? null : a[p];
      if (!g && !u.length)
        break;
      let y, Q;
      for (u.length ? (y = h, Q = u.reduce((x, P) => Math.min(x, P.to), g && g.from > y ? g.from : 1e8)) : (y = g.from, Q = g.to, u.push(g), p++); p < a.length; ) {
        let x = a[p];
        if (x.from == y && (x.to > x.from || x.to == y))
          u.push(x), p++, Q = Math.min(x.to, Q);
        else {
          Q = Math.min(x.from, Q);
          break;
        }
      }
      let b = Cq(u);
      if (u.some((x) => x.from == x.to || x.from == x.to - 1 && i.doc.lineAt(x.from).to == x.from))
        o.add(y, y, ft.widget({
          widget: new Rq(b),
          diagnostics: u.slice()
        }));
      else {
        let x = u.reduce((P, A) => A.markClass ? P + " " + A.markClass : P, "");
        o.add(y, Q, ft.mark({
          class: "cm-lintRange cm-lintRange-" + b + x,
          diagnostics: u.slice(),
          inclusiveEnd: u.some((P) => P.to > Q)
        }));
      }
      h = Q;
      for (let x = 0; x < u.length; x++)
        u[x].to <= h && u.splice(x--, 1);
    }
    let d = o.finish();
    return new Dl(d, e, sr(d));
  }
}
function sr(n, t = null, e = 0) {
  let i = null;
  return n.between(e, 1e9, (s, a, { spec: o }) => {
    if (!(t && o.diagnostics.indexOf(t) < 0))
      if (!i)
        i = new H1(s, a, t || o.diagnostics[0]);
      else {
        if (o.diagnostics.indexOf(i.diagnostic) < 0)
          return !1;
        i = new H1(i.from, a, i.diagnostic);
      }
  }), i;
}
function vq(n, t) {
  let e = t.pos, i = t.end || e, s = n.state.facet(Ba).hideOn(n, e, i);
  if (s != null)
    return s;
  let a = n.startState.doc.lineAt(t.pos);
  return !!(n.effects.some((o) => o.is(lk)) || n.changes.touchesRange(a.from, Math.max(a.to, i)));
}
function bq(n, t) {
  return n.field(ai, !1) ? t : t.concat(yt.appendConfig.of(Zq));
}
const lk = /* @__PURE__ */ yt.define(), tm = /* @__PURE__ */ yt.define(), sk = /* @__PURE__ */ yt.define(), ai = /* @__PURE__ */ Se.define({
  create() {
    return new Dl(ft.none, null, null);
  },
  update(n, t) {
    if (t.docChanged && n.diagnostics.size) {
      let e = n.diagnostics.map(t.changes), i = null, s = n.panel;
      if (n.selected) {
        let a = t.changes.mapPos(n.selected.from, 1);
        i = sr(e, n.selected.diagnostic, a) || sr(e, null, a);
      }
      !e.size && s && t.state.facet(Ba).autoPanel && (s = null), n = new Dl(e, s, i);
    }
    for (let e of t.effects)
      if (e.is(lk)) {
        let i = t.state.facet(Ba).autoPanel ? e.value.length ? Ga.open : null : n.panel;
        n = Dl.init(e.value, i, t.state);
      } else e.is(tm) ? n = new Dl(n.diagnostics, e.value ? Ga.open : null, n.selected) : e.is(sk) && (n = new Dl(n.diagnostics, n.panel, e.value));
    return n;
  },
  provide: (n) => [
    _a.from(n, (t) => t.panel),
    it.decorations.from(n, (t) => t.diagnostics)
  ]
}), xq = /* @__PURE__ */ ft.mark({ class: "cm-lintRange cm-lintRange-active" });
function kq(n, t, e) {
  let { diagnostics: i } = n.state.field(ai), s, a = -1, o = -1;
  i.between(t - (e < 0 ? 1 : 0), t + (e > 0 ? 1 : 0), (h, d, { spec: p }) => {
    if (t >= h && t <= d && (h == d || (t > h || e > 0) && (t < d || e < 0)))
      return s = p.diagnostics, a = h, o = d, !1;
  });
  let u = n.state.facet(Ba).tooltipFilter;
  return s && u && (s = u(s, n.state)), s ? {
    pos: a,
    end: o,
    above: n.state.doc.lineAt(a).to < o,
    create() {
      return { dom: wq(n, s) };
    }
  } : null;
}
function wq(n, t) {
  return Vt("ul", { class: "cm-tooltip-lint" }, t.map((e) => ak(n, e, !1)));
}
const Tq = (n) => {
  let t = n.state.field(ai, !1);
  (!t || !t.panel) && n.dispatch({ effects: bq(n.state, [tm.of(!0)]) });
  let e = Xa(n, Ga.open);
  return e && e.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, K1 = (n) => {
  let t = n.state.field(ai, !1);
  return !t || !t.panel ? !1 : (n.dispatch({ effects: tm.of(!1) }), !0);
}, $q = (n) => {
  let t = n.state.field(ai, !1);
  if (!t)
    return !1;
  let e = n.state.selection.main, i = t.diagnostics.iter(e.to + 1);
  return !i.value && (i = t.diagnostics.iter(0), !i.value || i.from == e.from && i.to == e.to) ? !1 : (n.dispatch({ selection: { anchor: i.from, head: i.to }, scrollIntoView: !0 }), !0);
}, Pq = [
  { key: "Mod-Shift-m", run: Tq, preventDefault: !0 },
  { key: "F8", run: $q }
], Ba = /* @__PURE__ */ lt.define({
  combine(n) {
    return Object.assign({ sources: n.map((t) => t.source).filter((t) => t != null) }, Fi(n.map((t) => t.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null,
      hideOn: () => null
    }, {
      needsRefresh: (t, e) => t ? e ? (i) => t(i) || e(i) : t : e
    }));
  }
});
function rk(n) {
  let t = [];
  if (n)
    t: for (let { name: e } of n) {
      for (let i = 0; i < e.length; i++) {
        let s = e[i];
        if (/[a-zA-Z]/.test(s) && !t.some((a) => a.toLowerCase() == s.toLowerCase())) {
          t.push(s);
          continue t;
        }
      }
      t.push("");
    }
  return t;
}
function ak(n, t, e) {
  var i;
  let s = e ? rk(t.actions) : [];
  return Vt("li", { class: "cm-diagnostic cm-diagnostic-" + t.severity }, Vt("span", { class: "cm-diagnosticText" }, t.renderMessage ? t.renderMessage(n) : t.message), (i = t.actions) === null || i === void 0 ? void 0 : i.map((a, o) => {
    let u = !1, h = (y) => {
      if (y.preventDefault(), u)
        return;
      u = !0;
      let Q = sr(n.state.field(ai).diagnostics, t);
      Q && a.apply(n, Q.from, Q.to);
    }, { name: d } = a, p = s[o] ? d.indexOf(s[o]) : -1, g = p < 0 ? d : [
      d.slice(0, p),
      Vt("u", d.slice(p, p + 1)),
      d.slice(p + 1)
    ];
    return Vt("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: h,
      onmousedown: h,
      "aria-label": ` Action: ${d}${p < 0 ? "" : ` (access key "${s[o]})"`}.`
    }, g);
  }), t.source && Vt("div", { class: "cm-diagnosticSource" }, t.source));
}
class Rq extends tn {
  constructor(t) {
    super(), this.sev = t;
  }
  eq(t) {
    return t.sev == this.sev;
  }
  toDOM() {
    return Vt("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
  }
}
class J1 {
  constructor(t, e) {
    this.diagnostic = e, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = ak(t, e, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class Ga {
  constructor(t) {
    this.view = t, this.items = [];
    let e = (s) => {
      if (s.keyCode == 27)
        K1(this.view), this.view.focus();
      else if (s.keyCode == 38 || s.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (s.keyCode == 40 || s.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (s.keyCode == 36)
        this.moveSelection(0);
      else if (s.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (s.keyCode == 13)
        this.view.focus();
      else if (s.keyCode >= 65 && s.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: a } = this.items[this.selectedIndex], o = rk(a.actions);
        for (let u = 0; u < o.length; u++)
          if (o[u].toUpperCase().charCodeAt(0) == s.keyCode) {
            let h = sr(this.view.state.field(ai).diagnostics, a);
            h && a.actions[u].apply(t, h.from, h.to);
          }
      } else
        return;
      s.preventDefault();
    }, i = (s) => {
      for (let a = 0; a < this.items.length; a++)
        this.items[a].dom.contains(s.target) && this.moveSelection(a);
    };
    this.list = Vt("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: e,
      onclick: i
    }), this.dom = Vt("div", { class: "cm-panel-lint" }, this.list, Vt("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => K1(this.view)
    }, "×")), this.update();
  }
  get selectedIndex() {
    let t = this.view.state.field(ai).selected;
    if (!t)
      return -1;
    for (let e = 0; e < this.items.length; e++)
      if (this.items[e].diagnostic == t.diagnostic)
        return e;
    return -1;
  }
  update() {
    let { diagnostics: t, selected: e } = this.view.state.field(ai), i = 0, s = !1, a = null, o = /* @__PURE__ */ new Set();
    for (t.between(0, this.view.state.doc.length, (u, h, { spec: d }) => {
      for (let p of d.diagnostics) {
        if (o.has(p))
          continue;
        o.add(p);
        let g = -1, y;
        for (let Q = i; Q < this.items.length; Q++)
          if (this.items[Q].diagnostic == p) {
            g = Q;
            break;
          }
        g < 0 ? (y = new J1(this.view, p), this.items.splice(i, 0, y), s = !0) : (y = this.items[g], g > i && (this.items.splice(i, g - i), s = !0)), e && y.diagnostic == e.diagnostic ? y.dom.hasAttribute("aria-selected") || (y.dom.setAttribute("aria-selected", "true"), a = y) : y.dom.hasAttribute("aria-selected") && y.dom.removeAttribute("aria-selected"), i++;
      }
    }); i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      s = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new J1(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), s = !0), a ? (this.list.setAttribute("aria-activedescendant", a.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: a.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: u, panel: h }) => {
        let d = h.height / this.list.offsetHeight;
        u.top < h.top ? this.list.scrollTop -= (h.top - u.top) / d : u.bottom > h.bottom && (this.list.scrollTop += (u.bottom - h.bottom) / d);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), s && this.sync();
  }
  sync() {
    let t = this.list.firstChild;
    function e() {
      let i = t;
      t = i.nextSibling, i.remove();
    }
    for (let i of this.items)
      if (i.dom.parentNode == this.list) {
        for (; t != i.dom; )
          e();
        t = i.dom.nextSibling;
      } else
        this.list.insertBefore(i.dom, t);
    for (; t; )
      e();
  }
  moveSelection(t) {
    if (this.selectedIndex < 0)
      return;
    let e = this.view.state.field(ai), i = sr(e.diagnostics, this.items[t].diagnostic);
    i && this.view.dispatch({
      selection: { anchor: i.from, head: i.to },
      scrollIntoView: !0,
      effects: sk.of(i)
    });
  }
  static open(t) {
    return new Ga(t);
  }
}
function Aq(n, t = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${t}>${encodeURIComponent(n)}</svg>')`;
}
function Bc(n) {
  return Aq(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${n}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const Mq = /* @__PURE__ */ it.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ Bc("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ Bc("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ Bc("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ Bc("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function qq(n) {
  return n == "error" ? 4 : n == "warning" ? 3 : n == "info" ? 2 : 1;
}
function Cq(n) {
  let t = "hint", e = 1;
  for (let i of n) {
    let s = qq(i.severity);
    s > e && (e = s, t = i.severity);
  }
  return t;
}
const Zq = [
  ai,
  /* @__PURE__ */ it.decorations.compute([ai], (n) => {
    let { selected: t, panel: e } = n.field(ai);
    return !t || !e || t.from == t.to ? ft.none : ft.set([
      xq.range(t.from, t.to)
    ]);
  }),
  /* @__PURE__ */ xR(kq, { hideOn: vq }),
  Mq
];
var I1 = function(t) {
  t === void 0 && (t = {});
  var {
    crosshairCursor: e = !1
  } = t, i = [];
  t.closeBracketsKeymap !== !1 && (i = i.concat(hq)), t.defaultKeymap !== !1 && (i = i.concat(K5)), t.searchKeymap !== !1 && (i = i.concat(bM)), t.historyKeymap !== !1 && (i = i.concat(s5)), t.foldKeymap !== !1 && (i = i.concat(SA)), t.completionKeymap !== !1 && (i = i.concat(nk)), t.lintKeymap !== !1 && (i = i.concat(Pq));
  var s = [];
  return t.lineNumbers !== !1 && s.push(ZR()), t.highlightActiveLineGutter !== !1 && s.push(_R()), t.highlightSpecialChars !== !1 && s.push(IP()), t.history !== !1 && s.push(KA()), t.foldGutter !== !1 && s.push(xA()), t.drawSelection !== !1 && s.push(YP()), t.dropCursor !== !1 && s.push(GP()), t.allowMultipleSelections !== !1 && s.push($t.allowMultipleSelections.of(!0)), t.indentOnInput !== !1 && s.push(uA()), t.syntaxHighlighting !== !1 && s.push(tx($A, {
    fallback: !0
  })), t.bracketMatching !== !1 && s.push(ZA()), t.closeBrackets !== !1 && s.push(oq()), t.autocompletion !== !1 && s.push(Sq()), t.rectangularSelection !== !1 && s.push(hR()), e !== !1 && s.push(pR()), t.highlightActiveLine !== !1 && s.push(lR()), t.highlightSelectionMatches !== !1 && s.push(nM()), t.tabSize && typeof t.tabSize == "number" && s.push(Fa.of(" ".repeat(t.tabSize))), s.concat([Jl.of(i.flat())]).filter(Boolean);
};
const Eq = "#e5c07b", F1 = "#e06c75", Xq = "#56b6c2", _q = "#ffffff", su = "#abb2bf", np = "#7d8799", zq = "#61afef", Dq = "#98c379", tQ = "#d19a66", Vq = "#c678dd", Yq = "#21252b", eQ = "#2c313a", iQ = "#282c34", WO = "#353a42", Uq = "#3E4451", nQ = "#528bff", jq = /* @__PURE__ */ it.theme({
  "&": {
    color: su,
    backgroundColor: iQ
  },
  ".cm-content": {
    caretColor: nQ
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: nQ },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: Uq },
  ".cm-panels": { backgroundColor: Yq, color: su },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847"
  },
  ".cm-gutters": {
    backgroundColor: iQ,
    color: np,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: eQ
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: WO
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: WO,
    borderBottomColor: WO
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: eQ,
      color: su
    }
  }
}, { dark: !0 }), Lq = /* @__PURE__ */ eo.define([
  {
    tag: w.keyword,
    color: Vq
  },
  {
    tag: [w.name, w.deleted, w.character, w.propertyName, w.macroName],
    color: F1
  },
  {
    tag: [/* @__PURE__ */ w.function(w.variableName), w.labelName],
    color: zq
  },
  {
    tag: [w.color, /* @__PURE__ */ w.constant(w.name), /* @__PURE__ */ w.standard(w.name)],
    color: tQ
  },
  {
    tag: [/* @__PURE__ */ w.definition(w.name), w.separator],
    color: su
  },
  {
    tag: [w.typeName, w.className, w.number, w.changed, w.annotation, w.modifier, w.self, w.namespace],
    color: Eq
  },
  {
    tag: [w.operator, w.operatorKeyword, w.url, w.escape, w.regexp, w.link, /* @__PURE__ */ w.special(w.string)],
    color: Xq
  },
  {
    tag: [w.meta, w.comment],
    color: np
  },
  {
    tag: w.strong,
    fontWeight: "bold"
  },
  {
    tag: w.emphasis,
    fontStyle: "italic"
  },
  {
    tag: w.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: w.link,
    color: np,
    textDecoration: "underline"
  },
  {
    tag: w.heading,
    fontWeight: "bold",
    color: F1
  },
  {
    tag: [w.atom, w.bool, /* @__PURE__ */ w.special(w.variableName)],
    color: tQ
  },
  {
    tag: [w.processingInstruction, w.string, w.inserted],
    color: Dq
  },
  {
    tag: w.invalid,
    color: _q
  }
]), Bq = [jq, /* @__PURE__ */ tx(Lq)];
var Gq = it.theme({
  "&": {
    backgroundColor: "#fff"
  }
}, {
  dark: !1
}), Nq = function(t) {
  t === void 0 && (t = {});
  var {
    indentWithTab: e = !0,
    editable: i = !0,
    readOnly: s = !1,
    theme: a = "light",
    placeholder: o = "",
    basicSetup: u = !0
  } = t, h = [];
  switch (e && h.unshift(Jl.of([J5])), u && (typeof u == "boolean" ? h.unshift(I1()) : h.unshift(I1(u))), o && h.unshift(oR(o)), a) {
    case "light":
      h.push(Gq);
      break;
    case "dark":
      h.push(Bq);
      break;
    case "none":
      break;
    default:
      h.push(a);
      break;
  }
  return i === !1 && h.push(it.editable.of(!1)), s && h.push($t.readOnly.of(!0)), [...h];
}, Wq = (n) => ({
  line: n.state.doc.lineAt(n.state.selection.main.from),
  lineCount: n.state.doc.lines,
  lineBreak: n.state.lineBreak,
  length: n.state.doc.length,
  readOnly: n.state.readOnly,
  tabSize: n.state.tabSize,
  selection: n.state.selection,
  selectionAsSingle: n.state.selection.asSingle().main,
  ranges: n.state.selection.ranges,
  selectionCode: n.state.sliceDoc(n.state.selection.main.from, n.state.selection.main.to),
  selections: n.state.selection.ranges.map((t) => n.state.sliceDoc(t.from, t.to)),
  selectedText: n.state.selection.ranges.some((t) => !t.empty)
}), lQ = Ii.define(), Hq = [];
function Kq(n) {
  var {
    value: t,
    selection: e,
    onChange: i,
    onStatistics: s,
    onCreateEditor: a,
    onUpdate: o,
    extensions: u = Hq,
    autoFocus: h,
    theme: d = "light",
    height: p = null,
    minHeight: g = null,
    maxHeight: y = null,
    width: Q = null,
    minWidth: b = null,
    maxWidth: x = null,
    placeholder: P = "",
    editable: A = !0,
    readOnly: V = !1,
    indentWithTab: G = !0,
    basicSetup: H = !0,
    root: _,
    initialState: W
  } = n, [q, J] = St.useState(), [N, I] = St.useState(), [K, Y] = St.useState(), ot = it.theme({
    "&": {
      height: p,
      minHeight: g,
      maxHeight: y,
      width: Q,
      minWidth: b,
      maxWidth: x
    },
    "& .cm-scroller": {
      height: "100% !important"
    }
  }), at = it.updateListener.of((z) => {
    if (z.docChanged && typeof i == "function" && // Fix echoing of the remote changes:
    // If transaction is market as remote we don't have to call `onChange` handler again
    !z.transactions.some((T) => T.annotation(lQ))) {
      var nt = z.state.doc, Ot = nt.toString();
      i(Ot, z);
    }
    s && s(Wq(z));
  }), ht = Nq({
    theme: d,
    editable: A,
    readOnly: V,
    placeholder: P,
    indentWithTab: G,
    basicSetup: H
  }), E = [at, ot, ...ht];
  return o && typeof o == "function" && E.push(it.updateListener.of(o)), E = E.concat(u), St.useLayoutEffect(() => {
    if (q && !K) {
      var z = {
        doc: t,
        selection: e,
        extensions: E
      }, nt = W ? $t.fromJSON(W.json, z, W.fields) : $t.create(z);
      if (Y(nt), !N) {
        var Ot = new it({
          state: nt,
          parent: q,
          root: _
        });
        I(Ot), a && a(Ot, nt);
      }
    }
    return () => {
      N && (Y(void 0), I(void 0));
    };
  }, [q, K]), St.useEffect(() => {
    n.container && J(n.container);
  }, [n.container]), St.useEffect(() => () => {
    N && (N.destroy(), I(void 0));
  }, [N]), St.useEffect(() => {
    h && N && N.focus();
  }, [h, N]), St.useEffect(() => {
    N && N.dispatch({
      effects: yt.reconfigure.of(E)
    });
  }, [d, u, p, g, y, Q, b, x, P, A, V, G, H, i, o]), St.useEffect(() => {
    if (t !== void 0) {
      var z = N ? N.state.doc.toString() : "";
      N && t !== z && N.dispatch({
        changes: {
          from: 0,
          to: z.length,
          insert: t || ""
        },
        annotations: [lQ.of(!0)]
      });
    }
  }, [t, N]), {
    state: K,
    setState: Y,
    view: N,
    setView: I,
    container: q,
    setContainer: J
  };
}
var HO = { exports: {} }, pa = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var sQ;
function Jq() {
  if (sQ) return pa;
  sQ = 1;
  var n = Symbol.for("react.transitional.element"), t = Symbol.for("react.fragment");
  function e(i, s, a) {
    var o = null;
    if (a !== void 0 && (o = "" + a), s.key !== void 0 && (o = "" + s.key), "key" in s) {
      a = {};
      for (var u in s)
        u !== "key" && (a[u] = s[u]);
    } else a = s;
    return s = a.ref, {
      $$typeof: n,
      type: i,
      key: o,
      ref: s !== void 0 ? s : null,
      props: a
    };
  }
  return pa.Fragment = t, pa.jsx = e, pa.jsxs = e, pa;
}
var rQ;
function Iq() {
  return rQ || (rQ = 1, HO.exports = Jq()), HO.exports;
}
var Fq = Iq(), tC = ["className", "value", "selection", "extensions", "onChange", "onStatistics", "onCreateEditor", "onUpdate", "autoFocus", "theme", "height", "minHeight", "maxHeight", "width", "minWidth", "maxWidth", "basicSetup", "placeholder", "indentWithTab", "editable", "readOnly", "root", "initialState"], em = /* @__PURE__ */ St.forwardRef((n, t) => {
  var {
    className: e,
    value: i = "",
    selection: s,
    extensions: a = [],
    onChange: o,
    onStatistics: u,
    onCreateEditor: h,
    onUpdate: d,
    autoFocus: p,
    theme: g = "light",
    height: y,
    minHeight: Q,
    maxHeight: b,
    width: x,
    minWidth: P,
    maxWidth: A,
    basicSetup: V,
    placeholder: G,
    indentWithTab: H,
    editable: _,
    readOnly: W,
    root: q,
    initialState: J
  } = n, N = X$(n, tC), I = St.useRef(null), {
    state: K,
    view: Y,
    container: ot,
    setContainer: at
  } = Kq({
    root: q,
    value: i,
    autoFocus: p,
    theme: g,
    height: y,
    minHeight: Q,
    maxHeight: b,
    width: x,
    minWidth: P,
    maxWidth: A,
    basicSetup: V,
    placeholder: G,
    indentWithTab: H,
    editable: _,
    readOnly: W,
    selection: s,
    onChange: o,
    onStatistics: u,
    onCreateEditor: h,
    onUpdate: d,
    extensions: a,
    initialState: J
  });
  St.useImperativeHandle(t, () => ({
    editor: I.current,
    state: K,
    view: Y
  }), [I, ot, K, Y]);
  var ht = St.useCallback((z) => {
    I.current = z, at(z);
  }, [at]);
  if (typeof i != "string")
    throw new Error("value must be typeof string but got " + typeof i);
  var E = typeof g == "string" ? "cm-theme-" + g : "cm-theme";
  return /* @__PURE__ */ Fq.jsx("div", od({
    ref: ht,
    className: "" + E + (e ? " " + e : "")
  }, N));
});
em.displayName = "CodeMirror";
var aQ = {};
class Eu {
  /**
  @internal
  */
  constructor(t, e, i, s, a, o, u, h, d, p = 0, g) {
    this.p = t, this.stack = e, this.state = i, this.reducePos = s, this.pos = a, this.score = o, this.buffer = u, this.bufferBase = h, this.curContext = d, this.lookAhead = p, this.parent = g;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((t, e) => e % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(t, e, i = 0) {
    let s = t.parser.context;
    return new Eu(t, [], e, i, i, 0, [], 0, s ? new oQ(s, s.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(t, e) {
    this.stack.push(this.state, e, this.bufferBase + this.buffer.length), this.state = t;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(t) {
    var e;
    let i = t >> 19, s = t & 65535, { parser: a } = this.p, o = this.reducePos < this.pos - 25;
    o && this.setLookAhead(this.pos);
    let u = a.dynamicPrecedence(s);
    if (u && (this.score += u), i == 0) {
      this.pushState(a.getGoto(this.state, s, !0), this.reducePos), s < a.minRepeatTerm && this.storeNode(s, this.reducePos, this.reducePos, o ? 8 : 4, !0), this.reduceContext(s, this.reducePos);
      return;
    }
    let h = this.stack.length - (i - 1) * 3 - (t & 262144 ? 6 : 0), d = h ? this.stack[h - 2] : this.p.ranges[0].from, p = this.reducePos - d;
    p >= 2e3 && !(!((e = this.p.parser.nodeSet.types[s]) === null || e === void 0) && e.isAnonymous) && (d == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = p) : this.p.lastBigReductionSize < p && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = d, this.p.lastBigReductionSize = p));
    let g = h ? this.stack[h - 1] : 0, y = this.bufferBase + this.buffer.length - g;
    if (s < a.minRepeatTerm || t & 131072) {
      let Q = a.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(s, d, Q, y + 4, !0);
    }
    if (t & 262144)
      this.state = this.stack[h];
    else {
      let Q = this.stack[h - 3];
      this.state = a.getGoto(Q, s, !0);
    }
    for (; this.stack.length > h; )
      this.stack.pop();
    this.reduceContext(s, d);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(t, e, i, s = 4, a = !1) {
    if (t == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let o = this, u = this.buffer.length;
      if (u == 0 && o.parent && (u = o.bufferBase - o.parent.bufferBase, o = o.parent), u > 0 && o.buffer[u - 4] == 0 && o.buffer[u - 1] > -1) {
        if (e == i)
          return;
        if (o.buffer[u - 2] >= e) {
          o.buffer[u - 2] = i;
          return;
        }
      }
    }
    if (!a || this.pos == i)
      this.buffer.push(t, e, i, s);
    else {
      let o = this.buffer.length;
      if (o > 0 && this.buffer[o - 4] != 0) {
        let u = !1;
        for (let h = o; h > 0 && this.buffer[h - 2] > i; h -= 4)
          if (this.buffer[h - 1] >= 0) {
            u = !0;
            break;
          }
        if (u)
          for (; o > 0 && this.buffer[o - 2] > i; )
            this.buffer[o] = this.buffer[o - 4], this.buffer[o + 1] = this.buffer[o - 3], this.buffer[o + 2] = this.buffer[o - 2], this.buffer[o + 3] = this.buffer[o - 1], o -= 4, s > 4 && (s -= 4);
      }
      this.buffer[o] = t, this.buffer[o + 1] = e, this.buffer[o + 2] = i, this.buffer[o + 3] = s;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(t, e, i, s) {
    if (t & 131072)
      this.pushState(t & 65535, this.pos);
    else if ((t & 262144) == 0) {
      let a = t, { parser: o } = this.p;
      (s > this.pos || e <= o.maxNode) && (this.pos = s, o.stateFlag(
        a,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = s)), this.pushState(a, i), this.shiftContext(e, i), e <= o.maxNode && this.buffer.push(e, i, s, 4);
    } else
      this.pos = s, this.shiftContext(e, i), e <= this.p.parser.maxNode && this.buffer.push(e, i, s, 4);
  }
  // Apply an action
  /**
  @internal
  */
  apply(t, e, i, s) {
    t & 65536 ? this.reduce(t) : this.shift(t, e, i, s);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(t, e) {
    let i = this.p.reused.length - 1;
    (i < 0 || this.p.reused[i] != t) && (this.p.reused.push(t), i++);
    let s = this.pos;
    this.reducePos = this.pos = s + t.length, this.pushState(e, s), this.buffer.push(
      i,
      s,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, t, this, this.p.stream.reset(this.pos - t.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let t = this, e = t.buffer.length;
    for (; e > 0 && t.buffer[e - 2] > t.reducePos; )
      e -= 4;
    let i = t.buffer.slice(e), s = t.bufferBase + e;
    for (; t && s == t.bufferBase; )
      t = t.parent;
    return new Eu(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, i, s, this.curContext, this.lookAhead, t);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(t, e) {
    let i = t <= this.p.parser.maxNode;
    i && this.storeNode(t, this.pos, e, 4), this.storeNode(0, this.pos, e, i ? 8 : 4), this.pos = this.reducePos = e, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(t) {
    for (let e = new eC(this); ; ) {
      let i = this.p.parser.stateSlot(
        e.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(e.state, t);
      if (i == 0)
        return !1;
      if ((i & 65536) == 0)
        return !0;
      e.reduce(i);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(t) {
    if (this.stack.length >= 300)
      return [];
    let e = this.p.parser.nextStates(this.state);
    if (e.length > 8 || this.stack.length >= 120) {
      let s = [];
      for (let a = 0, o; a < e.length; a += 2)
        (o = e[a + 1]) != this.state && this.p.parser.hasAction(o, t) && s.push(e[a], o);
      if (this.stack.length < 120)
        for (let a = 0; s.length < 8 && a < e.length; a += 2) {
          let o = e[a + 1];
          s.some((u, h) => h & 1 && u == o) || s.push(e[a], o);
        }
      e = s;
    }
    let i = [];
    for (let s = 0; s < e.length && i.length < 4; s += 2) {
      let a = e[s + 1];
      if (a == this.state)
        continue;
      let o = this.split();
      o.pushState(a, this.pos), o.storeNode(0, o.pos, o.pos, 4, !0), o.shiftContext(e[s], this.pos), o.reducePos = this.pos, o.score -= 200, i.push(o);
    }
    return i;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: t } = this.p, e = t.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if ((e & 65536) == 0)
      return !1;
    if (!t.validAction(this.state, e)) {
      let i = e >> 19, s = e & 65535, a = this.stack.length - i * 3;
      if (a < 0 || t.getGoto(this.stack[a], s, !1) < 0) {
        let o = this.findForcedReduction();
        if (o == null)
          return !1;
        e = o;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(e), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: t } = this.p, e = [], i = (s, a) => {
      if (!e.includes(s))
        return e.push(s), t.allActions(s, (o) => {
          if (!(o & 393216)) if (o & 65536) {
            let u = (o >> 19) - a;
            if (u > 1) {
              let h = o & 65535, d = this.stack.length - u * 3;
              if (d >= 0 && t.getGoto(this.stack[d], h, !1) >= 0)
                return u << 19 | 65536 | h;
            }
          } else {
            let u = i(o, a + 1);
            if (u != null)
              return u;
          }
        });
    };
    return i(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: t } = this.p;
    return t.data[t.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !t.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(t) {
    if (this.state != t.state || this.stack.length != t.stack.length)
      return !1;
    for (let e = 0; e < this.stack.length; e += 3)
      if (this.stack[e] != t.stack[e])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(t) {
    return this.p.parser.dialect.flags[t];
  }
  shiftContext(t, e) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, t, this, this.p.stream.reset(e)));
  }
  reduceContext(t, e) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, t, this, this.p.stream.reset(e)));
  }
  /**
  @internal
  */
  emitContext() {
    let t = this.buffer.length - 1;
    (t < 0 || this.buffer[t] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let t = this.buffer.length - 1;
    (t < 0 || this.buffer[t] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(t) {
    if (t != this.curContext.context) {
      let e = new oQ(this.curContext.tracker, t);
      e.hash != this.curContext.hash && this.emitContext(), this.curContext = e;
    }
  }
  /**
  @internal
  */
  setLookAhead(t) {
    t > this.lookAhead && (this.emitLookAhead(), this.lookAhead = t);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class oQ {
  constructor(t, e) {
    this.tracker = t, this.context = e, this.hash = t.strict ? t.hash(e) : 0;
  }
}
class eC {
  constructor(t) {
    this.start = t, this.state = t.state, this.stack = t.stack, this.base = this.stack.length;
  }
  reduce(t) {
    let e = t & 65535, i = t >> 19;
    i == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (i - 1) * 3;
    let s = this.start.p.parser.getGoto(this.stack[this.base - 3], e, !0);
    this.state = s;
  }
}
class Xu {
  constructor(t, e, i) {
    this.stack = t, this.pos = e, this.index = i, this.buffer = t.buffer, this.index == 0 && this.maybeNext();
  }
  static create(t, e = t.bufferBase + t.buffer.length) {
    return new Xu(t, e, e - t.bufferBase);
  }
  maybeNext() {
    let t = this.stack.parent;
    t != null && (this.index = this.stack.bufferBase - t.bufferBase, this.stack = t, this.buffer = t.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new Xu(this.stack, this.pos, this.index);
  }
}
function xa(n, t = Uint16Array) {
  if (typeof n != "string")
    return n;
  let e = null;
  for (let i = 0, s = 0; i < n.length; ) {
    let a = 0;
    for (; ; ) {
      let o = n.charCodeAt(i++), u = !1;
      if (o == 126) {
        a = 65535;
        break;
      }
      o >= 92 && o--, o >= 34 && o--;
      let h = o - 32;
      if (h >= 46 && (h -= 46, u = !0), a += h, u)
        break;
      a *= 46;
    }
    e ? e[s++] = a : e = new t(a);
  }
  return e;
}
class ru {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const cQ = new ru();
class iC {
  /**
  @internal
  */
  constructor(t, e) {
    this.input = t, this.ranges = e, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = cQ, this.rangeIndex = 0, this.pos = this.chunkPos = e[0].from, this.range = e[0], this.end = e[e.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(t, e) {
    let i = this.range, s = this.rangeIndex, a = this.pos + t;
    for (; a < i.from; ) {
      if (!s)
        return null;
      let o = this.ranges[--s];
      a -= i.from - o.to, i = o;
    }
    for (; e < 0 ? a > i.to : a >= i.to; ) {
      if (s == this.ranges.length - 1)
        return null;
      let o = this.ranges[++s];
      a += o.from - i.to, i = o;
    }
    return a;
  }
  /**
  @internal
  */
  clipPos(t) {
    if (t >= this.range.from && t < this.range.to)
      return t;
    for (let e of this.ranges)
      if (e.to > t)
        return Math.max(t, e.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsing—when looking forward—or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(t) {
    let e = this.chunkOff + t, i, s;
    if (e >= 0 && e < this.chunk.length)
      i = this.pos + t, s = this.chunk.charCodeAt(e);
    else {
      let a = this.resolveOffset(t, 1);
      if (a == null)
        return -1;
      if (i = a, i >= this.chunk2Pos && i < this.chunk2Pos + this.chunk2.length)
        s = this.chunk2.charCodeAt(i - this.chunk2Pos);
      else {
        let o = this.rangeIndex, u = this.range;
        for (; u.to <= i; )
          u = this.ranges[++o];
        this.chunk2 = this.input.chunk(this.chunk2Pos = i), i + this.chunk2.length > u.to && (this.chunk2 = this.chunk2.slice(0, u.to - i)), s = this.chunk2.charCodeAt(0);
      }
    }
    return i >= this.token.lookAhead && (this.token.lookAhead = i + 1), s;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(t, e = 0) {
    let i = e ? this.resolveOffset(e, -1) : this.pos;
    if (i == null || i < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = t, this.token.end = i;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(t, e) {
    this.token.value = t, this.token.end = e;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: t, chunkPos: e } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = t, this.chunk2Pos = e, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let t = this.input.chunk(this.pos), e = this.pos + t.length;
      this.chunk = e > this.range.to ? t.slice(0, this.range.to - this.pos) : t, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(t = 1) {
    for (this.chunkOff += t; this.pos + t >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      t -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += t, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(t, e) {
    if (e ? (this.token = e, e.start = t, e.lookAhead = t + 1, e.value = e.extended = -1) : this.token = cQ, this.pos != t) {
      if (this.pos = t, t == this.end)
        return this.setDone(), this;
      for (; t < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; t >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      t >= this.chunkPos && t < this.chunkPos + this.chunk.length ? this.chunkOff = t - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(t, e) {
    if (t >= this.chunkPos && e <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(t - this.chunkPos, e - this.chunkPos);
    if (t >= this.chunk2Pos && e <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(t - this.chunk2Pos, e - this.chunk2Pos);
    if (t >= this.range.from && e <= this.range.to)
      return this.input.read(t, e);
    let i = "";
    for (let s of this.ranges) {
      if (s.from >= e)
        break;
      s.to > t && (i += this.input.read(Math.max(s.from, t), Math.min(s.to, e)));
    }
    return i;
  }
}
class Js {
  constructor(t, e) {
    this.data = t, this.id = e;
  }
  token(t, e) {
    let { parser: i } = e.p;
    ok(this.data, t, e, this.id, i.data, i.tokenPrecTable);
  }
}
Js.prototype.contextual = Js.prototype.fallback = Js.prototype.extend = !1;
class lp {
  constructor(t, e, i) {
    this.precTable = e, this.elseToken = i, this.data = typeof t == "string" ? xa(t) : t;
  }
  token(t, e) {
    let i = t.pos, s = 0;
    for (; ; ) {
      let a = t.next < 0, o = t.resolveOffset(1, 1);
      if (ok(this.data, t, e, 0, this.data, this.precTable), t.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (a || s++, o == null)
        break;
      t.reset(o, t.token);
    }
    s && (t.reset(i, t.token), t.acceptToken(this.elseToken, s));
  }
}
lp.prototype.contextual = Js.prototype.fallback = Js.prototype.extend = !1;
class Rn {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(t, e = {}) {
    this.token = t, this.contextual = !!e.contextual, this.fallback = !!e.fallback, this.extend = !!e.extend;
  }
}
function ok(n, t, e, i, s, a) {
  let o = 0, u = 1 << i, { dialect: h } = e.p.parser;
  t: for (; (u & n[o]) != 0; ) {
    let d = n[o + 1];
    for (let Q = o + 3; Q < d; Q += 2)
      if ((n[Q + 1] & u) > 0) {
        let b = n[Q];
        if (h.allows(b) && (t.token.value == -1 || t.token.value == b || nC(b, t.token.value, s, a))) {
          t.acceptToken(b);
          break;
        }
      }
    let p = t.next, g = 0, y = n[o + 2];
    if (t.next < 0 && y > g && n[d + y * 3 - 3] == 65535) {
      o = n[d + y * 3 - 1];
      continue t;
    }
    for (; g < y; ) {
      let Q = g + y >> 1, b = d + Q + (Q << 1), x = n[b], P = n[b + 1] || 65536;
      if (p < x)
        y = Q;
      else if (p >= P)
        g = Q + 1;
      else {
        o = n[b + 2], t.advance();
        continue t;
      }
    }
    break;
  }
}
function uQ(n, t, e) {
  for (let i = t, s; (s = n[i]) != 65535; i++)
    if (s == e)
      return i - t;
  return -1;
}
function nC(n, t, e, i) {
  let s = uQ(e, i, t);
  return s < 0 || uQ(e, i, n) < s;
}
const si = typeof process < "u" && aQ && /\bparse\b/.test(aQ.LOG);
let KO = null;
function fQ(n, t, e) {
  let i = n.cursor(ae.IncludeAnonymous);
  for (i.moveTo(t); ; )
    if (!(e < 0 ? i.childBefore(t) : i.childAfter(t)))
      for (; ; ) {
        if ((e < 0 ? i.to < t : i.from > t) && !i.type.isError)
          return e < 0 ? Math.max(0, Math.min(
            i.to - 1,
            t - 25
            /* Lookahead.Margin */
          )) : Math.min(n.length, Math.max(
            i.from + 1,
            t + 25
            /* Lookahead.Margin */
          ));
        if (e < 0 ? i.prevSibling() : i.nextSibling())
          break;
        if (!i.parent())
          return e < 0 ? 0 : n.length;
      }
}
class lC {
  constructor(t, e) {
    this.fragments = t, this.nodeSet = e, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let t = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (t) {
      for (this.safeFrom = t.openStart ? fQ(t.tree, t.from + t.offset, 1) - t.offset : t.from, this.safeTo = t.openEnd ? fQ(t.tree, t.to + t.offset, -1) - t.offset : t.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(t.tree), this.start.push(-t.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(t) {
    if (t < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= t; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let e = this.trees.length - 1;
      if (e < 0)
        return this.nextFragment(), null;
      let i = this.trees[e], s = this.index[e];
      if (s == i.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let a = i.children[s], o = this.start[e] + i.positions[s];
      if (o > t)
        return this.nextStart = o, null;
      if (a instanceof ce) {
        if (o == t) {
          if (o < this.safeFrom)
            return null;
          let u = o + a.length;
          if (u <= this.safeTo) {
            let h = a.prop(kt.lookAhead);
            if (!h || u + h < this.fragment.to)
              return a;
          }
        }
        this.index[e]++, o + a.length >= Math.max(this.safeFrom, t) && (this.trees.push(a), this.start.push(o), this.index.push(0));
      } else
        this.index[e]++, this.nextStart = o + a.length;
    }
  }
}
class sC {
  constructor(t, e) {
    this.stream = e, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = t.tokenizers.map((i) => new ru());
  }
  getActions(t) {
    let e = 0, i = null, { parser: s } = t.p, { tokenizers: a } = s, o = s.stateSlot(
      t.state,
      3
      /* ParseState.TokenizerMask */
    ), u = t.curContext ? t.curContext.hash : 0, h = 0;
    for (let d = 0; d < a.length; d++) {
      if ((1 << d & o) == 0)
        continue;
      let p = a[d], g = this.tokens[d];
      if (!(i && !p.fallback) && ((p.contextual || g.start != t.pos || g.mask != o || g.context != u) && (this.updateCachedToken(g, p, t), g.mask = o, g.context = u), g.lookAhead > g.end + 25 && (h = Math.max(g.lookAhead, h)), g.value != 0)) {
        let y = e;
        if (g.extended > -1 && (e = this.addActions(t, g.extended, g.end, e)), e = this.addActions(t, g.value, g.end, e), !p.extend && (i = g, e > y))
          break;
      }
    }
    for (; this.actions.length > e; )
      this.actions.pop();
    return h && t.setLookAhead(h), !i && t.pos == this.stream.end && (i = new ru(), i.value = t.p.parser.eofTerm, i.start = i.end = t.pos, e = this.addActions(t, i.value, i.end, e)), this.mainToken = i, this.actions;
  }
  getMainToken(t) {
    if (this.mainToken)
      return this.mainToken;
    let e = new ru(), { pos: i, p: s } = t;
    return e.start = i, e.end = Math.min(i + 1, s.stream.end), e.value = i == s.stream.end ? s.parser.eofTerm : 0, e;
  }
  updateCachedToken(t, e, i) {
    let s = this.stream.clipPos(i.pos);
    if (e.token(this.stream.reset(s, t), i), t.value > -1) {
      let { parser: a } = i.p;
      for (let o = 0; o < a.specialized.length; o++)
        if (a.specialized[o] == t.value) {
          let u = a.specializers[o](this.stream.read(t.start, t.end), i);
          if (u >= 0 && i.p.parser.dialect.allows(u >> 1)) {
            (u & 1) == 0 ? t.value = u >> 1 : t.extended = u >> 1;
            break;
          }
        }
    } else
      t.value = 0, t.end = this.stream.clipPos(s + 1);
  }
  putAction(t, e, i, s) {
    for (let a = 0; a < s; a += 3)
      if (this.actions[a] == t)
        return s;
    return this.actions[s++] = t, this.actions[s++] = e, this.actions[s++] = i, s;
  }
  addActions(t, e, i, s) {
    let { state: a } = t, { parser: o } = t.p, { data: u } = o;
    for (let h = 0; h < 2; h++)
      for (let d = o.stateSlot(
        a,
        h ? 2 : 1
        /* ParseState.Actions */
      ); ; d += 3) {
        if (u[d] == 65535)
          if (u[d + 1] == 1)
            d = bn(u, d + 2);
          else {
            s == 0 && u[d + 1] == 2 && (s = this.putAction(bn(u, d + 2), e, i, s));
            break;
          }
        u[d] == e && (s = this.putAction(bn(u, d + 1), e, i, s));
      }
    return s;
  }
}
class rC {
  constructor(t, e, i, s) {
    this.parser = t, this.input = e, this.ranges = s, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new iC(e, s), this.tokens = new sC(t, this.stream), this.topTerm = t.top[1];
    let { from: a } = s[0];
    this.stacks = [Eu.start(this, t.top[0], a)], this.fragments = i.length && this.stream.end - a > t.bufferLength * 4 ? new lC(i, t.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let t = this.stacks, e = this.minStackPos, i = this.stacks = [], s, a;
    if (this.bigReductionCount > 300 && t.length == 1) {
      let [o] = t;
      for (; o.forceReduce() && o.stack.length && o.stack[o.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let o = 0; o < t.length; o++) {
      let u = t[o];
      for (; ; ) {
        if (this.tokens.mainToken = null, u.pos > e)
          i.push(u);
        else {
          if (this.advanceStack(u, i, t))
            continue;
          {
            s || (s = [], a = []), s.push(u);
            let h = this.tokens.getMainToken(u);
            a.push(h.value, h.end);
          }
        }
        break;
      }
    }
    if (!i.length) {
      let o = s && oC(s);
      if (o)
        return si && console.log("Finish with " + this.stackID(o)), this.stackToTree(o);
      if (this.parser.strict)
        throw si && s && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + e);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && s) {
      let o = this.stoppedAt != null && s[0].pos > this.stoppedAt ? s[0] : this.runRecovery(s, a, i);
      if (o)
        return si && console.log("Force-finish " + this.stackID(o)), this.stackToTree(o.forceAll());
    }
    if (this.recovering) {
      let o = this.recovering == 1 ? 1 : this.recovering * 3;
      if (i.length > o)
        for (i.sort((u, h) => h.score - u.score); i.length > o; )
          i.pop();
      i.some((u) => u.reducePos > e) && this.recovering--;
    } else if (i.length > 1) {
      t: for (let o = 0; o < i.length - 1; o++) {
        let u = i[o];
        for (let h = o + 1; h < i.length; h++) {
          let d = i[h];
          if (u.sameState(d) || u.buffer.length > 500 && d.buffer.length > 500)
            if ((u.score - d.score || u.buffer.length - d.buffer.length) > 0)
              i.splice(h--, 1);
            else {
              i.splice(o--, 1);
              continue t;
            }
        }
      }
      i.length > 12 && i.splice(
        12,
        i.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = i[0].pos;
    for (let o = 1; o < i.length; o++)
      i[o].pos < this.minStackPos && (this.minStackPos = i[o].pos);
    return null;
  }
  stopAt(t) {
    if (this.stoppedAt != null && this.stoppedAt < t)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = t;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(t, e, i) {
    let s = t.pos, { parser: a } = this, o = si ? this.stackID(t) + " -> " : "";
    if (this.stoppedAt != null && s > this.stoppedAt)
      return t.forceReduce() ? t : null;
    if (this.fragments) {
      let d = t.curContext && t.curContext.tracker.strict, p = d ? t.curContext.hash : 0;
      for (let g = this.fragments.nodeAt(s); g; ) {
        let y = this.parser.nodeSet.types[g.type.id] == g.type ? a.getGoto(t.state, g.type.id) : -1;
        if (y > -1 && g.length && (!d || (g.prop(kt.contextHash) || 0) == p))
          return t.useNode(g, y), si && console.log(o + this.stackID(t) + ` (via reuse of ${a.getName(g.type.id)})`), !0;
        if (!(g instanceof ce) || g.children.length == 0 || g.positions[0] > 0)
          break;
        let Q = g.children[0];
        if (Q instanceof ce && g.positions[0] == 0)
          g = Q;
        else
          break;
      }
    }
    let u = a.stateSlot(
      t.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (u > 0)
      return t.reduce(u), si && console.log(o + this.stackID(t) + ` (via always-reduce ${a.getName(
        u & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (t.stack.length >= 8400)
      for (; t.stack.length > 6e3 && t.forceReduce(); )
        ;
    let h = this.tokens.getActions(t);
    for (let d = 0; d < h.length; ) {
      let p = h[d++], g = h[d++], y = h[d++], Q = d == h.length || !i, b = Q ? t : t.split(), x = this.tokens.mainToken;
      if (b.apply(p, g, x ? x.start : b.pos, y), si && console.log(o + this.stackID(b) + ` (via ${(p & 65536) == 0 ? "shift" : `reduce of ${a.getName(
        p & 65535
        /* Action.ValueMask */
      )}`} for ${a.getName(g)} @ ${s}${b == t ? "" : ", split"})`), Q)
        return !0;
      b.pos > s ? e.push(b) : i.push(b);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(t, e) {
    let i = t.pos;
    for (; ; ) {
      if (!this.advanceStack(t, null, null))
        return !1;
      if (t.pos > i)
        return hQ(t, e), !0;
    }
  }
  runRecovery(t, e, i) {
    let s = null, a = !1;
    for (let o = 0; o < t.length; o++) {
      let u = t[o], h = e[o << 1], d = e[(o << 1) + 1], p = si ? this.stackID(u) + " -> " : "";
      if (u.deadEnd && (a || (a = !0, u.restart(), si && console.log(p + this.stackID(u) + " (restarted)"), this.advanceFully(u, i))))
        continue;
      let g = u.split(), y = p;
      for (let Q = 0; g.forceReduce() && Q < 10 && (si && console.log(y + this.stackID(g) + " (via force-reduce)"), !this.advanceFully(g, i)); Q++)
        si && (y = this.stackID(g) + " -> ");
      for (let Q of u.recoverByInsert(h))
        si && console.log(p + this.stackID(Q) + " (via recover-insert)"), this.advanceFully(Q, i);
      this.stream.end > u.pos ? (d == u.pos && (d++, h = 0), u.recoverByDelete(h, d), si && console.log(p + this.stackID(u) + ` (via recover-delete ${this.parser.getName(h)})`), hQ(u, i)) : (!s || s.score < u.score) && (s = u);
    }
    return s;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(t) {
    return t.close(), ce.build({
      buffer: Xu.create(t),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: t.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(t) {
    let e = (KO || (KO = /* @__PURE__ */ new WeakMap())).get(t);
    return e || KO.set(t, e = String.fromCodePoint(this.nextStackID++)), e + t;
  }
}
function hQ(n, t) {
  for (let e = 0; e < t.length; e++) {
    let i = t[e];
    if (i.pos == n.pos && i.sameState(n)) {
      t[e].score < n.score && (t[e] = n);
      return;
    }
  }
  t.push(n);
}
class aC {
  constructor(t, e, i) {
    this.source = t, this.flags = e, this.disabled = i;
  }
  allows(t) {
    return !this.disabled || this.disabled[t] == 0;
  }
}
const JO = (n) => n;
class ck {
  /**
  Define a context tracker.
  */
  constructor(t) {
    this.start = t.start, this.shift = t.shift || JO, this.reduce = t.reduce || JO, this.reuse = t.reuse || JO, this.hash = t.hash || (() => 0), this.strict = t.strict !== !1;
  }
}
class Na extends _b {
  /**
  @internal
  */
  constructor(t) {
    if (super(), this.wrappers = [], t.version != 14)
      throw new RangeError(`Parser version (${t.version}) doesn't match runtime version (14)`);
    let e = t.nodeNames.split(" ");
    this.minRepeatTerm = e.length;
    for (let u = 0; u < t.repeatNodeCount; u++)
      e.push("");
    let i = Object.keys(t.topRules).map((u) => t.topRules[u][1]), s = [];
    for (let u = 0; u < e.length; u++)
      s.push([]);
    function a(u, h, d) {
      s[u].push([h, h.deserialize(String(d))]);
    }
    if (t.nodeProps)
      for (let u of t.nodeProps) {
        let h = u[0];
        typeof h == "string" && (h = kt[h]);
        for (let d = 1; d < u.length; ) {
          let p = u[d++];
          if (p >= 0)
            a(p, h, u[d++]);
          else {
            let g = u[d + -p];
            for (let y = -p; y > 0; y--)
              a(u[d++], h, g);
            d++;
          }
        }
      }
    this.nodeSet = new Rp(e.map((u, h) => We.define({
      name: h >= this.minRepeatTerm ? void 0 : u,
      id: h,
      props: s[h],
      top: i.indexOf(h) > -1,
      error: h == 0,
      skipped: t.skippedNodes && t.skippedNodes.indexOf(h) > -1
    }))), t.propSources && (this.nodeSet = this.nodeSet.extend(...t.propSources)), this.strict = !1, this.bufferLength = qb;
    let o = xa(t.tokenData);
    this.context = t.context, this.specializerSpecs = t.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let u = 0; u < this.specializerSpecs.length; u++)
      this.specialized[u] = this.specializerSpecs[u].term;
    this.specializers = this.specializerSpecs.map(OQ), this.states = xa(t.states, Uint32Array), this.data = xa(t.stateData), this.goto = xa(t.goto), this.maxTerm = t.maxTerm, this.tokenizers = t.tokenizers.map((u) => typeof u == "number" ? new Js(o, u) : u), this.topRules = t.topRules, this.dialects = t.dialects || {}, this.dynamicPrecedences = t.dynamicPrecedences || null, this.tokenPrecTable = t.tokenPrec, this.termNames = t.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(t, e, i) {
    let s = new rC(this, t, e, i);
    for (let a of this.wrappers)
      s = a(s, t, e, i);
    return s;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(t, e, i = !1) {
    let s = this.goto;
    if (e >= s[0])
      return -1;
    for (let a = s[e + 1]; ; ) {
      let o = s[a++], u = o & 1, h = s[a++];
      if (u && i)
        return h;
      for (let d = a + (o >> 1); a < d; a++)
        if (s[a] == t)
          return h;
      if (u)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(t, e) {
    let i = this.data;
    for (let s = 0; s < 2; s++)
      for (let a = this.stateSlot(
        t,
        s ? 2 : 1
        /* ParseState.Actions */
      ), o; ; a += 3) {
        if ((o = i[a]) == 65535)
          if (i[a + 1] == 1)
            o = i[a = bn(i, a + 2)];
          else {
            if (i[a + 1] == 2)
              return bn(i, a + 2);
            break;
          }
        if (o == e || o == 0)
          return bn(i, a + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(t, e) {
    return this.states[t * 6 + e];
  }
  /**
  @internal
  */
  stateFlag(t, e) {
    return (this.stateSlot(
      t,
      0
      /* ParseState.Flags */
    ) & e) > 0;
  }
  /**
  @internal
  */
  validAction(t, e) {
    return !!this.allActions(t, (i) => i == e ? !0 : null);
  }
  /**
  @internal
  */
  allActions(t, e) {
    let i = this.stateSlot(
      t,
      4
      /* ParseState.DefaultReduce */
    ), s = i ? e(i) : void 0;
    for (let a = this.stateSlot(
      t,
      1
      /* ParseState.Actions */
    ); s == null; a += 3) {
      if (this.data[a] == 65535)
        if (this.data[a + 1] == 1)
          a = bn(this.data, a + 2);
        else
          break;
      s = e(bn(this.data, a + 1));
    }
    return s;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(t) {
    let e = [];
    for (let i = this.stateSlot(
      t,
      1
      /* ParseState.Actions */
    ); ; i += 3) {
      if (this.data[i] == 65535)
        if (this.data[i + 1] == 1)
          i = bn(this.data, i + 2);
        else
          break;
      if ((this.data[i + 2] & 1) == 0) {
        let s = this.data[i + 1];
        e.some((a, o) => o & 1 && a == s) || e.push(this.data[i], s);
      }
    }
    return e;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(t) {
    let e = Object.assign(Object.create(Na.prototype), this);
    if (t.props && (e.nodeSet = this.nodeSet.extend(...t.props)), t.top) {
      let i = this.topRules[t.top];
      if (!i)
        throw new RangeError(`Invalid top rule name ${t.top}`);
      e.top = i;
    }
    return t.tokenizers && (e.tokenizers = this.tokenizers.map((i) => {
      let s = t.tokenizers.find((a) => a.from == i);
      return s ? s.to : i;
    })), t.specializers && (e.specializers = this.specializers.slice(), e.specializerSpecs = this.specializerSpecs.map((i, s) => {
      let a = t.specializers.find((u) => u.from == i.external);
      if (!a)
        return i;
      let o = Object.assign(Object.assign({}, i), { external: a.to });
      return e.specializers[s] = OQ(o), o;
    })), t.contextTracker && (e.context = t.contextTracker), t.dialect && (e.dialect = this.parseDialect(t.dialect)), t.strict != null && (e.strict = t.strict), t.wrap && (e.wrappers = e.wrappers.concat(t.wrap)), t.bufferLength != null && (e.bufferLength = t.bufferLength), e;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(t) {
    return this.termNames ? this.termNames[t] : String(t <= this.maxNode && this.nodeSet.types[t].name || t);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(t) {
    let e = this.dynamicPrecedences;
    return e == null ? 0 : e[t] || 0;
  }
  /**
  @internal
  */
  parseDialect(t) {
    let e = Object.keys(this.dialects), i = e.map(() => !1);
    if (t)
      for (let a of t.split(" ")) {
        let o = e.indexOf(a);
        o >= 0 && (i[o] = !0);
      }
    let s = null;
    for (let a = 0; a < e.length; a++)
      if (!i[a])
        for (let o = this.dialects[e[a]], u; (u = this.data[o++]) != 65535; )
          (s || (s = new Uint8Array(this.maxTerm + 1)))[u] = 1;
    return new aC(t, i, s);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(t) {
    return new Na(t);
  }
}
function bn(n, t) {
  return n[t] | n[t + 1] << 16;
}
function oC(n) {
  let t = null;
  for (let e of n) {
    let i = e.p.stoppedAt;
    (e.pos == e.p.stream.end || i != null && e.pos > i) && e.p.parser.stateFlag(
      e.state,
      2
      /* StateFlag.Accepting */
    ) && (!t || t.score < e.score) && (t = e);
  }
  return t;
}
function OQ(n) {
  if (n.external) {
    let t = n.extend ? 1 : 0;
    return (e, i) => n.external(e, i) << 1 | t;
  }
  return n.get;
}
const cC = 1, uk = 194, fk = 195, uC = 196, dQ = 197, fC = 198, hC = 199, OC = 200, dC = 2, hk = 3, pQ = 201, pC = 24, mC = 25, gC = 49, yC = 50, SC = 55, QC = 56, vC = 57, bC = 59, xC = 60, kC = 61, wC = 62, TC = 63, $C = 65, PC = 238, RC = 71, AC = 241, MC = 242, qC = 243, CC = 244, ZC = 245, EC = 246, XC = 247, _C = 248, Ok = 72, zC = 249, DC = 250, VC = 251, YC = 252, UC = 253, jC = 254, LC = 255, BC = 256, GC = 73, NC = 77, WC = 263, HC = 112, KC = 130, JC = 151, IC = 152, FC = 155, Kl = 10, Wa = 13, im = 32, Hu = 9, nm = 35, tZ = 40, eZ = 46, sp = 123, mQ = 125, dk = 39, pk = 34, gQ = 92, iZ = 111, nZ = 120, lZ = 78, sZ = 117, rZ = 85, aZ = /* @__PURE__ */ new Set([
  mC,
  gC,
  yC,
  WC,
  $C,
  KC,
  QC,
  vC,
  PC,
  wC,
  TC,
  Ok,
  GC,
  NC,
  xC,
  kC,
  JC,
  IC,
  FC,
  HC
]);
function IO(n) {
  return n == Kl || n == Wa;
}
function FO(n) {
  return n >= 48 && n <= 57 || n >= 65 && n <= 70 || n >= 97 && n <= 102;
}
const oZ = new Rn((n, t) => {
  let e;
  if (n.next < 0)
    n.acceptToken(hC);
  else if (t.context.flags & au)
    IO(n.next) && n.acceptToken(fC, 1);
  else if (((e = n.peek(-1)) < 0 || IO(e)) && t.canShift(dQ)) {
    let i = 0;
    for (; n.next == im || n.next == Hu; )
      n.advance(), i++;
    (n.next == Kl || n.next == Wa || n.next == nm) && n.acceptToken(dQ, -i);
  } else IO(n.next) && n.acceptToken(uC, 1);
}, { contextual: !0 }), cZ = new Rn((n, t) => {
  let e = t.context;
  if (e.flags) return;
  let i = n.peek(-1);
  if (i == Kl || i == Wa) {
    let s = 0, a = 0;
    for (; ; ) {
      if (n.next == im) s++;
      else if (n.next == Hu) s += 8 - s % 8;
      else break;
      n.advance(), a++;
    }
    s != e.indent && n.next != Kl && n.next != Wa && n.next != nm && (s < e.indent ? n.acceptToken(fk, -a) : n.acceptToken(uk));
  }
}), au = 1, mk = 2, yn = 4, Sn = 8, Qn = 16, vn = 32;
function ou(n, t, e) {
  this.parent = n, this.indent = t, this.flags = e, this.hash = (n ? n.hash + n.hash << 8 : 0) + t + (t << 4) + e + (e << 6);
}
const uZ = new ou(null, 0, 0);
function fZ(n) {
  let t = 0;
  for (let e = 0; e < n.length; e++)
    t += n.charCodeAt(e) == Hu ? 8 - t % 8 : 1;
  return t;
}
const yQ = new Map([
  [AC, 0],
  [MC, yn],
  [qC, Sn],
  [CC, Sn | yn],
  [ZC, Qn],
  [EC, Qn | yn],
  [XC, Qn | Sn],
  [_C, Qn | Sn | yn],
  [zC, vn],
  [DC, vn | yn],
  [VC, vn | Sn],
  [YC, vn | Sn | yn],
  [UC, vn | Qn],
  [jC, vn | Qn | yn],
  [LC, vn | Qn | Sn],
  [BC, vn | Qn | Sn | yn]
].map(([n, t]) => [n, t | mk])), hZ = new ck({
  start: uZ,
  reduce(n, t, e, i) {
    return n.flags & au && aZ.has(t) || (t == RC || t == Ok) && n.flags & mk ? n.parent : n;
  },
  shift(n, t, e, i) {
    return t == uk ? new ou(n, fZ(i.read(i.pos, e.pos)), 0) : t == fk ? n.parent : t == pC || t == SC || t == bC || t == hk ? new ou(n, 0, au) : yQ.has(t) ? new ou(n, 0, yQ.get(t) | n.flags & au) : n;
  },
  hash(n) {
    return n.hash;
  }
}), OZ = new Rn((n) => {
  for (let t = 0; t < 5; t++) {
    if (n.next != "print".charCodeAt(t)) return;
    n.advance();
  }
  if (!/\w/.test(String.fromCharCode(n.next)))
    for (let t = 0; ; t++) {
      let e = n.peek(t);
      if (!(e == im || e == Hu)) {
        e != tZ && e != eZ && e != Kl && e != Wa && e != nm && n.acceptToken(cC);
        return;
      }
    }
}), dZ = new Rn((n, t) => {
  let { flags: e } = t.context, i = e & yn ? pk : dk, s = (e & Sn) > 0, a = !(e & Qn), o = (e & vn) > 0, u = n.pos;
  for (; !(n.next < 0); )
    if (o && n.next == sp)
      if (n.peek(1) == sp)
        n.advance(2);
      else {
        if (n.pos == u) {
          n.acceptToken(hk, 1);
          return;
        }
        break;
      }
    else if (a && n.next == gQ) {
      if (n.pos == u) {
        n.advance();
        let h = n.next;
        h >= 0 && (n.advance(), pZ(n, h)), n.acceptToken(dC);
        return;
      }
      break;
    } else if (n.next == gQ && !a && n.peek(1) > -1)
      n.advance(2);
    else if (n.next == i && (!s || n.peek(1) == i && n.peek(2) == i)) {
      if (n.pos == u) {
        n.acceptToken(pQ, s ? 3 : 1);
        return;
      }
      break;
    } else if (n.next == Kl) {
      if (s)
        n.advance();
      else if (n.pos == u) {
        n.acceptToken(pQ);
        return;
      }
      break;
    } else
      n.advance();
  n.pos > u && n.acceptToken(OC);
});
function pZ(n, t) {
  if (t == iZ)
    for (let e = 0; e < 2 && n.next >= 48 && n.next <= 55; e++) n.advance();
  else if (t == nZ)
    for (let e = 0; e < 2 && FO(n.next); e++) n.advance();
  else if (t == sZ)
    for (let e = 0; e < 4 && FO(n.next); e++) n.advance();
  else if (t == rZ)
    for (let e = 0; e < 8 && FO(n.next); e++) n.advance();
  else if (t == lZ && n.next == sp) {
    for (n.advance(); n.next >= 0 && n.next != mQ && n.next != dk && n.next != pk && n.next != Kl; ) n.advance();
    n.next == mQ && n.advance();
  }
}
const mZ = Cp({
  'async "*" "**" FormatConversion FormatSpec': w.modifier,
  "for while if elif else try except finally return raise break continue with pass assert await yield match case": w.controlKeyword,
  "in not and or is del": w.operatorKeyword,
  "from def class global nonlocal lambda": w.definitionKeyword,
  import: w.moduleKeyword,
  "with as print": w.keyword,
  Boolean: w.bool,
  None: w.null,
  VariableName: w.variableName,
  "CallExpression/VariableName": w.function(w.variableName),
  "FunctionDefinition/VariableName": w.function(w.definition(w.variableName)),
  "ClassDefinition/VariableName": w.definition(w.className),
  PropertyName: w.propertyName,
  "CallExpression/MemberExpression/PropertyName": w.function(w.propertyName),
  Comment: w.lineComment,
  Number: w.number,
  String: w.string,
  FormatString: w.special(w.string),
  Escape: w.escape,
  UpdateOp: w.updateOperator,
  "ArithOp!": w.arithmeticOperator,
  BitOp: w.bitwiseOperator,
  CompareOp: w.compareOperator,
  AssignOp: w.definitionOperator,
  Ellipsis: w.punctuation,
  At: w.meta,
  "( )": w.paren,
  "[ ]": w.squareBracket,
  "{ }": w.brace,
  ".": w.derefOperator,
  ", ;": w.separator
}), gZ = { __proto__: null, await: 44, or: 54, and: 56, in: 60, not: 62, is: 64, if: 70, else: 72, lambda: 76, yield: 94, from: 96, async: 102, for: 104, None: 162, True: 164, False: 164, del: 178, pass: 182, break: 186, continue: 190, return: 194, raise: 202, import: 206, as: 208, global: 212, nonlocal: 214, assert: 218, type: 223, elif: 236, while: 240, try: 246, except: 248, finally: 250, with: 254, def: 258, class: 268, match: 279, case: 285 }, yZ = Na.deserialize({
  version: 14,
  states: "##jO`QeOOP$}OSOOO&WQtO'#HUOOQS'#Co'#CoOOQS'#Cp'#CpO'vQdO'#CnO*UQtO'#HTOOQS'#HU'#HUOOQS'#DU'#DUOOQS'#HT'#HTO*rQdO'#D_O+VQdO'#DfO+gQdO'#DjO+zOWO'#DuO,VOWO'#DvO.[QtO'#GuOOQS'#Gu'#GuO'vQdO'#GtO0ZQtO'#GtOOQS'#Eb'#EbO0rQdO'#EcOOQS'#Gs'#GsO0|QdO'#GrOOQV'#Gr'#GrO1XQdO'#FYOOQS'#G^'#G^O1^QdO'#FXOOQV'#IS'#ISOOQV'#Gq'#GqOOQV'#Fq'#FqQ`QeOOO'vQdO'#CqO1lQdO'#C}O1sQdO'#DRO2RQdO'#HYO2cQtO'#EVO'vQdO'#EWOOQS'#EY'#EYOOQS'#E['#E[OOQS'#E^'#E^O2wQdO'#E`O3_QdO'#EdO3rQdO'#EfO3zQtO'#EfO1XQdO'#EiO0rQdO'#ElO1XQdO'#EnO0rQdO'#EtO0rQdO'#EwO4VQdO'#EyO4^QdO'#FOO4iQdO'#EzO0rQdO'#FOO1XQdO'#FQO1XQdO'#FVO4nQdO'#F[P4uOdO'#GpPOOO)CBd)CBdOOQS'#Ce'#CeOOQS'#Cf'#CfOOQS'#Cg'#CgOOQS'#Ch'#ChOOQS'#Ci'#CiOOQS'#Cj'#CjOOQS'#Cl'#ClO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO5TQdO'#DoOOQS,5:Y,5:YO5hQdO'#HdOOQS,5:],5:]O5uQ!fO,5:]O5zQtO,59YO1lQdO,59bO1lQdO,59bO1lQdO,59bO8jQdO,59bO8oQdO,59bO8vQdO,59jO8}QdO'#HTO:TQdO'#HSOOQS'#HS'#HSOOQS'#D['#D[O:lQdO,59aO'vQdO,59aO:zQdO,59aOOQS,59y,59yO;PQdO,5:RO'vQdO,5:ROOQS,5:Q,5:QO;_QdO,5:QO;dQdO,5:XO'vQdO,5:XO'vQdO,5:VOOQS,5:U,5:UO;uQdO,5:UO;zQdO,5:WOOOW'#Fy'#FyO<POWO,5:aOOQS,5:a,5:aO<[QdO'#HwOOOW'#Dw'#DwOOOW'#Fz'#FzO<lOWO,5:bOOQS,5:b,5:bOOQS'#F}'#F}O<zQtO,5:iO?lQtO,5=`O@VQ#xO,5=`O@vQtO,5=`OOQS,5:},5:}OA_QeO'#GWOBqQdO,5;^OOQV,5=^,5=^OB|QtO'#IPOCkQdO,5;tOOQS-E:[-E:[OOQV,5;s,5;sO4dQdO'#FQOOQV-E9o-E9oOCsQtO,59]OEzQtO,59iOFeQdO'#HVOFpQdO'#HVO1XQdO'#HVOF{QdO'#DTOGTQdO,59mOGYQdO'#HZO'vQdO'#HZO0rQdO,5=tOOQS,5=t,5=tO0rQdO'#EROOQS'#ES'#ESOGwQdO'#GPOHXQdO,58|OHXQdO,58|O*xQdO,5:oOHgQtO'#H]OOQS,5:r,5:rOOQS,5:z,5:zOHzQdO,5;OOI]QdO'#IOO1XQdO'#H}OOQS,5;Q,5;QOOQS'#GT'#GTOIqQtO,5;QOJPQdO,5;QOJUQdO'#IQOOQS,5;T,5;TOJdQdO'#H|OOQS,5;W,5;WOJuQdO,5;YO4iQdO,5;`O4iQdO,5;cOJ}QtO'#ITO'vQdO'#ITOKXQdO,5;eO4VQdO,5;eO0rQdO,5;jO1XQdO,5;lOK^QeO'#EuOLjQgO,5;fO!!kQdO'#IUO4iQdO,5;jO!!vQdO,5;lO!#OQdO,5;qO!#ZQtO,5;vO'vQdO,5;vPOOO,5=[,5=[P!#bOSO,5=[P!#jOdO,5=[O!&bQtO1G.jO!&iQtO1G.jO!)YQtO1G.jO!)dQtO1G.jO!+}QtO1G.jO!,bQtO1G.jO!,uQdO'#HcO!-TQtO'#GuO0rQdO'#HcO!-_QdO'#HbOOQS,5:Z,5:ZO!-gQdO,5:ZO!-lQdO'#HeO!-wQdO'#HeO!.[QdO,5>OOOQS'#Ds'#DsOOQS1G/w1G/wOOQS1G.|1G.|O!/[QtO1G.|O!/cQtO1G.|O1lQdO1G.|O!0OQdO1G/UOOQS'#DZ'#DZO0rQdO,59tOOQS1G.{1G.{O!0VQdO1G/eO!0gQdO1G/eO!0oQdO1G/fO'vQdO'#H[O!0tQdO'#H[O!0yQtO1G.{O!1ZQdO,59iO!2aQdO,5=zO!2qQdO,5=zO!2yQdO1G/mO!3OQtO1G/mOOQS1G/l1G/lO!3`QdO,5=uO!4VQdO,5=uO0rQdO1G/qO!4tQdO1G/sO!4yQtO1G/sO!5ZQtO1G/qOOQS1G/p1G/pOOQS1G/r1G/rOOOW-E9w-E9wOOQS1G/{1G/{O!5kQdO'#HxO0rQdO'#HxO!5|QdO,5>cOOOW-E9x-E9xOOQS1G/|1G/|OOQS-E9{-E9{O!6[Q#xO1G2zO!6{QtO1G2zO'vQdO,5<jOOQS,5<j,5<jOOQS-E9|-E9|OOQS,5<r,5<rOOQS-E:U-E:UOOQV1G0x1G0xO1XQdO'#GRO!7dQtO,5>kOOQS1G1`1G1`O!8RQdO1G1`OOQS'#DV'#DVO0rQdO,5=qOOQS,5=q,5=qO!8WQdO'#FrO!8cQdO,59oO!8kQdO1G/XO!8uQtO,5=uOOQS1G3`1G3`OOQS,5:m,5:mO!9fQdO'#GtOOQS,5<k,5<kOOQS-E9}-E9}O!9wQdO1G.hOOQS1G0Z1G0ZO!:VQdO,5=wO!:gQdO,5=wO0rQdO1G0jO0rQdO1G0jO!:xQdO,5>jO!;ZQdO,5>jO1XQdO,5>jO!;lQdO,5>iOOQS-E:R-E:RO!;qQdO1G0lO!;|QdO1G0lO!<RQdO,5>lO!<aQdO,5>lO!<oQdO,5>hO!=VQdO,5>hO!=hQdO'#EpO0rQdO1G0tO!=sQdO1G0tO!=xQgO1G0zO!AvQgO1G0}O!EqQdO,5>oO!E{QdO,5>oO!FTQtO,5>oO0rQdO1G1PO!F_QdO1G1PO4iQdO1G1UO!!vQdO1G1WOOQV,5;a,5;aO!FdQfO,5;aO!FiQgO1G1QO!JjQdO'#GZO4iQdO1G1QO4iQdO1G1QO!JzQdO,5>pO!KXQdO,5>pO1XQdO,5>pOOQV1G1U1G1UO!KaQdO'#FSO!KrQ!fO1G1WO!KzQdO1G1WOOQV1G1]1G1]O4iQdO1G1]O!LPQdO1G1]O!LXQdO'#F^OOQV1G1b1G1bO!#ZQtO1G1bPOOO1G2v1G2vP!L^OSO1G2vOOQS,5=},5=}OOQS'#Dp'#DpO0rQdO,5=}O!LfQdO,5=|O!LyQdO,5=|OOQS1G/u1G/uO!MRQdO,5>PO!McQdO,5>PO!MkQdO,5>PO!NOQdO,5>PO!N`QdO,5>POOQS1G3j1G3jOOQS7+$h7+$hO!8kQdO7+$pO#!RQdO1G.|O#!YQdO1G.|OOQS1G/`1G/`OOQS,5<`,5<`O'vQdO,5<`OOQS7+%P7+%PO#!aQdO7+%POOQS-E9r-E9rOOQS7+%Q7+%QO#!qQdO,5=vO'vQdO,5=vOOQS7+$g7+$gO#!vQdO7+%PO##OQdO7+%QO##TQdO1G3fOOQS7+%X7+%XO##eQdO1G3fO##mQdO7+%XOOQS,5<_,5<_O'vQdO,5<_O##rQdO1G3aOOQS-E9q-E9qO#$iQdO7+%]OOQS7+%_7+%_O#$wQdO1G3aO#%fQdO7+%_O#%kQdO1G3gO#%{QdO1G3gO#&TQdO7+%]O#&YQdO,5>dO#&sQdO,5>dO#&sQdO,5>dOOQS'#Dx'#DxO#'UO&jO'#DzO#'aO`O'#HyOOOW1G3}1G3}O#'fQdO1G3}O#'nQdO1G3}O#'yQ#xO7+(fO#(jQtO1G2UP#)TQdO'#GOOOQS,5<m,5<mOOQS-E:P-E:POOQS7+&z7+&zOOQS1G3]1G3]OOQS,5<^,5<^OOQS-E9p-E9pOOQS7+$s7+$sO#)bQdO,5=`O#){QdO,5=`O#*^QtO,5<aO#*qQdO1G3cOOQS-E9s-E9sOOQS7+&U7+&UO#+RQdO7+&UO#+aQdO,5<nO#+uQdO1G4UOOQS-E:Q-E:QO#,WQdO1G4UOOQS1G4T1G4TOOQS7+&W7+&WO#,iQdO7+&WOOQS,5<p,5<pO#,tQdO1G4WOOQS-E:S-E:SOOQS,5<l,5<lO#-SQdO1G4SOOQS-E:O-E:OO1XQdO'#EqO#-jQdO'#EqO#-uQdO'#IRO#-}QdO,5;[OOQS7+&`7+&`O0rQdO7+&`O#.SQgO7+&fO!JmQdO'#GXO4iQdO7+&fO4iQdO7+&iO#2QQtO,5<tO'vQdO,5<tO#2[QdO1G4ZOOQS-E:W-E:WO#2fQdO1G4ZO4iQdO7+&kO0rQdO7+&kOOQV7+&p7+&pO!KrQ!fO7+&rO!KzQdO7+&rO`QeO1G0{OOQV-E:X-E:XO4iQdO7+&lO4iQdO7+&lOOQV,5<u,5<uO#2nQdO,5<uO!JmQdO,5<uOOQV7+&l7+&lO#2yQgO7+&lO#6tQdO,5<vO#7PQdO1G4[OOQS-E:Y-E:YO#7^QdO1G4[O#7fQdO'#IWO#7tQdO'#IWO1XQdO'#IWOOQS'#IW'#IWO#8PQdO'#IVOOQS,5;n,5;nO#8XQdO,5;nO0rQdO'#FUOOQV7+&r7+&rO4iQdO7+&rOOQV7+&w7+&wO4iQdO7+&wO#8^QfO,5;xOOQV7+&|7+&|POOO7+(b7+(bO#8cQdO1G3iOOQS,5<c,5<cO#8qQdO1G3hOOQS-E9u-E9uO#9UQdO,5<dO#9aQdO,5<dO#9tQdO1G3kOOQS-E9v-E9vO#:UQdO1G3kO#:^QdO1G3kO#:nQdO1G3kO#:UQdO1G3kOOQS<<H[<<H[O#:yQtO1G1zOOQS<<Hk<<HkP#;WQdO'#FtO8vQdO1G3bO#;eQdO1G3bO#;jQdO<<HkOOQS<<Hl<<HlO#;zQdO7+)QOOQS<<Hs<<HsO#<[QtO1G1yP#<{QdO'#FsO#=YQdO7+)RO#=jQdO7+)RO#=rQdO<<HwO#=wQdO7+({OOQS<<Hy<<HyO#>nQdO,5<bO'vQdO,5<bOOQS-E9t-E9tOOQS<<Hw<<HwOOQS,5<g,5<gO0rQdO,5<gO#>sQdO1G4OOOQS-E9y-E9yO#?^QdO1G4OO<[QdO'#H{OOOO'#D{'#D{OOOO'#F|'#F|O#?oO&jO,5:fOOOW,5>e,5>eOOOW7+)i7+)iO#?zQdO7+)iO#@SQdO1G2zO#@mQdO1G2zP'vQdO'#FuO0rQdO<<IpO1XQdO1G2YP1XQdO'#GSO#AOQdO7+)pO#AaQdO7+)pOOQS<<Ir<<IrP1XQdO'#GUP0rQdO'#GQOOQS,5;],5;]O#ArQdO,5>mO#BQQdO,5>mOOQS1G0v1G0vOOQS<<Iz<<IzOOQV-E:V-E:VO4iQdO<<JQOOQV,5<s,5<sO4iQdO,5<sOOQV<<JQ<<JQOOQV<<JT<<JTO#BYQtO1G2`P#BdQdO'#GYO#BkQdO7+)uO#BuQgO<<JVO4iQdO<<JVOOQV<<J^<<J^O4iQdO<<J^O!KrQ!fO<<J^O#FpQgO7+&gOOQV<<JW<<JWO#FzQgO<<JWOOQV1G2a1G2aO1XQdO1G2aO#JuQdO1G2aO4iQdO<<JWO1XQdO1G2bP0rQdO'#G[O#KQQdO7+)vO#K_QdO7+)vOOQS'#FT'#FTO0rQdO,5>rO#KgQdO,5>rO#KrQdO,5>rO#K}QdO,5>qO#L`QdO,5>qOOQS1G1Y1G1YOOQS,5;p,5;pOOQV<<Jc<<JcO#LhQdO1G1dOOQS7+)T7+)TP#LmQdO'#FwO#L}QdO1G2OO#MbQdO1G2OO#MrQdO1G2OP#M}QdO'#FxO#N[QdO7+)VO#NlQdO7+)VO#NlQdO7+)VO#NtQdO7+)VO$ UQdO7+(|O8vQdO7+(|OOQSAN>VAN>VO$ oQdO<<LmOOQSAN>cAN>cO0rQdO1G1|O$!PQtO1G1|P$!ZQdO'#FvOOQS1G2R1G2RP$!hQdO'#F{O$!uQdO7+)jO$#`QdO,5>gOOOO-E9z-E9zOOOW<<MT<<MTO$#nQdO7+(fOOQSAN?[AN?[OOQS7+'t7+'tO$$XQdO<<M[OOQS,5<q,5<qO$$jQdO1G4XOOQS-E:T-E:TOOQVAN?lAN?lOOQV1G2_1G2_O4iQdOAN?qO$$xQgOAN?qOOQVAN?xAN?xO4iQdOAN?xOOQV<<JR<<JRO4iQdOAN?rO4iQdO7+'{OOQV7+'{7+'{O1XQdO7+'{OOQVAN?rAN?rOOQS7+'|7+'|O$(sQdO<<MbOOQS1G4^1G4^O0rQdO1G4^OOQS,5<w,5<wO$)QQdO1G4]OOQS-E:Z-E:ZOOQU'#G_'#G_O$)cQfO7+'OO$)nQdO'#F_O$*uQdO7+'jO$+VQdO7+'jOOQS7+'j7+'jO$+bQdO<<LqO$+rQdO<<LqO$+rQdO<<LqO$+zQdO'#H^OOQS<<Lh<<LhO$,UQdO<<LhOOQS7+'h7+'hOOQS'#D|'#D|OOOO1G4R1G4RO$,oQdO1G4RO$,wQdO1G4RP!=hQdO'#GVOOQVG25]G25]O4iQdOG25]OOQVG25dG25dOOQVG25^G25^OOQV<<Kg<<KgO4iQdO<<KgOOQS7+)x7+)xP$-SQdO'#G]OOQU-E:]-E:]OOQV<<Jj<<JjO$-vQtO'#FaOOQS'#Fc'#FcO$.WQdO'#FbO$.xQdO'#FbOOQS'#Fb'#FbO$.}QdO'#IYO$)nQdO'#FiO$)nQdO'#FiO$/fQdO'#FjO$)nQdO'#FkO$/mQdO'#IZOOQS'#IZ'#IZO$0[QdO,5;yOOQS<<KU<<KUO$0dQdO<<KUO$0tQdOANB]O$1UQdOANB]O$1^QdO'#H_OOQS'#H_'#H_O1sQdO'#DcO$1wQdO,5=xOOQSANBSANBSOOOO7+)m7+)mO$2`QdO7+)mOOQVLD*wLD*wOOQVANARANARO5uQ!fO'#GaO$2hQtO,5<SO$)nQdO'#FmOOQS,5<W,5<WOOQS'#Fd'#FdO$3YQdO,5;|O$3_QdO,5;|OOQS'#Fg'#FgO$)nQdO'#G`O$4PQdO,5<QO$4kQdO,5>tO$4{QdO,5>tO1XQdO,5<PO$5^QdO,5<TO$5cQdO,5<TO$)nQdO'#I[O$5hQdO'#I[O$5mQdO,5<UOOQS,5<V,5<VO0rQdO'#FpOOQU1G1e1G1eO4iQdO1G1eOOQSAN@pAN@pO$5rQdOG27wO$6SQdO,59}OOQS1G3d1G3dOOOO<<MX<<MXOOQS,5<{,5<{OOQS-E:_-E:_O$6XQtO'#FaO$6`QdO'#I]O$6nQdO'#I]O$6vQdO,5<XOOQS1G1h1G1hO$6{QdO1G1hO$7QQdO,5<zOOQS-E:^-E:^O$7lQdO,5=OO$8TQdO1G4`OOQS-E:b-E:bOOQS1G1k1G1kOOQS1G1o1G1oO$8eQdO,5>vO$)nQdO,5>vOOQS1G1p1G1pOOQS,5<[,5<[OOQU7+'P7+'PO$+zQdO1G/iO$)nQdO,5<YO$8sQdO,5>wO$8zQdO,5>wOOQS1G1s1G1sOOQS7+'S7+'SP$)nQdO'#GdO$9SQdO1G4bO$9^QdO1G4bO$9fQdO1G4bOOQS7+%T7+%TO$9tQdO1G1tO$:SQtO'#FaO$:ZQdO,5<}OOQS,5<},5<}O$:iQdO1G4cOOQS-E:a-E:aO$)nQdO,5<|O$:pQdO,5<|O$:uQdO7+)|OOQS-E:`-E:`O$;PQdO7+)|O$)nQdO,5<ZP$)nQdO'#GcO$;XQdO1G2hO$)nQdO1G2hP$;gQdO'#GbO$;nQdO<<MhO$;xQdO1G1uO$<WQdO7+(SO8vQdO'#C}O8vQdO,59bO8vQdO,59bO8vQdO,59bO$<fQtO,5=`O8vQdO1G.|O0rQdO1G/XO0rQdO7+$pP$<yQdO'#GOO'vQdO'#GtO$=WQdO,59bO$=]QdO,59bO$=dQdO,59mO$=iQdO1G/UO1sQdO'#DRO8vQdO,59j",
  stateData: "$>S~O%cOS%^OSSOS%]PQ~OPdOVaOfoOhYOopOs!POvqO!PrO!Q{O!T!SO!U!RO!XZO!][O!h`O!r`O!s`O!t`O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO#l!QO#o!TO#s!UO#u!VO#z!WO#}hO$P!XO%oRO%pRO%tSO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O~O%]!YO~OV!aO_!aOa!bOh!iO!X!kO!f!mO%j![O%k!]O%l!^O%m!_O%n!_O%o!`O%p!`O%q!aO%r!aO%s!aO~Ok%xXl%xXm%xXn%xXo%xXp%xXs%xXz%xX{%xX!x%xX#g%xX%[%xX%_%xX%z%xXg%xX!T%xX!U%xX%{%xX!W%xX![%xX!Q%xX#[%xXt%xX!m%xX~P%SOfoOhYO!XZO!][O!h`O!r`O!s`O!t`O%oRO%pRO%tSO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O~Oz%wX{%wX#g%wX%[%wX%_%wX%z%wX~Ok!pOl!qOm!oOn!oOo!rOp!sOs!tO!x%wX~P)pOV!zOg!|Oo0cOv0qO!PrO~P'vOV#OOo0cOv0qO!W#PO~P'vOV#SOa#TOo0cOv0qO![#UO~P'vOQ#XO%`#XO%a#ZO~OQ#^OR#[O%`#^O%a#`O~OV%iX_%iXa%iXh%iXk%iXl%iXm%iXn%iXo%iXp%iXs%iXz%iX!X%iX!f%iX%j%iX%k%iX%l%iX%m%iX%n%iX%o%iX%p%iX%q%iX%r%iX%s%iXg%iX!T%iX!U%iX~O&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O{%iX!x%iX#g%iX%[%iX%_%iX%z%iX%{%iX!W%iX![%iX!Q%iX#[%iXt%iX!m%iX~P,eOz#dO{%hX!x%hX#g%hX%[%hX%_%hX%z%hX~Oo0cOv0qO~P'vO#g#gO%[#iO%_#iO~O%uWO~O!T#nO#u!VO#z!WO#}hO~OopO~P'vOV#sOa#tO%uWO{wP~OV#xOo0cOv0qO!Q#yO~P'vO{#{O!x$QO%z#|O#g!yX%[!yX%_!yX~OV#xOo0cOv0qO#g#SX%[#SX%_#SX~P'vOo0cOv0qO#g#WX%[#WX%_#WX~P'vOh$WO%uWO~O!f$YO!r$YO%uWO~OV$eO~P'vO!U$gO#s$hO#u$iO~O{$jO~OV$qO~P'vOS$sO%[$rO%_$rO%c$tO~OV$}Oa$}Og%POo0cOv0qO~P'vOo0cOv0qO{%SO~P'vO&Y%UO~Oa!bOh!iO!X!kO!f!mOVba_bakbalbambanbaobapbasbazba{ba!xba#gba%[ba%_ba%jba%kba%lba%mba%nba%oba%pba%qba%rba%sba%zbagba!Tba!Uba%{ba!Wba![ba!Qba#[batba!mba~On%ZO~Oo%ZO~P'vOo0cO~P'vOk0eOl0fOm0dOn0dOo0mOp0nOs0rOg%wX!T%wX!U%wX%{%wX!W%wX![%wX!Q%wX#[%wX!m%wX~P)pO%{%]Og%vXz%vX!T%vX!U%vX!W%vX{%vX~Og%_Oz%`O!T%dO!U%cO~Og%_O~Oz%gO!T%dO!U%cO!W&SX~O!W%kO~Oz%lO{%nO!T%dO!U%cO![%}X~O![%rO~O![%sO~OQ#XO%`#XO%a%uO~OV%wOo0cOv0qO!PrO~P'vOQ#^OR#[O%`#^O%a%zO~OV!qa_!qaa!qah!qak!qal!qam!qan!qao!qap!qas!qaz!qa{!qa!X!qa!f!qa!x!qa#g!qa%[!qa%_!qa%j!qa%k!qa%l!qa%m!qa%n!qa%o!qa%p!qa%q!qa%r!qa%s!qa%z!qag!qa!T!qa!U!qa%{!qa!W!qa![!qa!Q!qa#[!qat!qa!m!qa~P#yOz%|O{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~P%SOV&OOopOvqO{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~P'vOz%|O{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~OPdOVaOopOvqO!PrO!Q{O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO#g$zX%[$zX%_$zX~P'vO#g#gO%[&TO%_&TO~O!f&UOh&sX%[&sXz&sX#[&sX#g&sX%_&sX#Z&sXg&sX~Oh!iO%[&WO~Okealeameaneaoeapeaseazea{ea!xea#gea%[ea%_ea%zeagea!Tea!Uea%{ea!Wea![ea!Qea#[eatea!mea~P%SOsqazqa{qa#gqa%[qa%_qa%zqa~Ok!pOl!qOm!oOn!oOo!rOp!sO!xqa~PEcO%z&YOz%yX{%yX~O%uWOz%yX{%yX~Oz&]O{wX~O{&_O~Oz%lO#g%}X%[%}X%_%}Xg%}X{%}X![%}X!m%}X%z%}X~OV0lOo0cOv0qO!PrO~P'vO%z#|O#gUa%[Ua%_Ua~Oz&hO#g&PX%[&PX%_&PXn&PX~P%SOz&kO!Q&jO#g#Wa%[#Wa%_#Wa~Oz&lO#[&nO#g&rX%[&rX%_&rXg&rX~O!f$YO!r$YO#Z&qO%uWO~O#Z&qO~Oz&sO#g&tX%[&tX%_&tX~Oz&uO#g&pX%[&pX%_&pX{&pX~O!X&wO%z&xO~Oz&|On&wX~P%SOn'PO~OPdOVaOopOvqO!PrO!Q{O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO%['UO~P'vOt'YO#p'WO#q'XOP#naV#naf#nah#nao#nas#nav#na!P#na!Q#na!T#na!U#na!X#na!]#na!h#na!r#na!s#na!t#na!{#na!}#na#P#na#R#na#T#na#X#na#Z#na#^#na#_#na#a#na#c#na#l#na#o#na#s#na#u#na#z#na#}#na$P#na%X#na%o#na%p#na%t#na%u#na&Z#na&[#na&]#na&^#na&_#na&`#na&a#na&b#na&c#na&d#na&e#na&f#na&g#na&h#na&i#na&j#na%Z#na%_#na~Oz'ZO#[']O{&xX~Oh'_O!X&wO~Oh!iO{$jO!X&wO~O{'eO~P%SO%['hO%_'hO~OS'iO%['hO%_'hO~OV!aO_!aOa!bOh!iO!X!kO!f!mO%l!^O%m!_O%n!_O%o!`O%p!`O%q!aO%r!aO%s!aOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~O%k!]O~P!#uO%kWi~P!#uOV!aO_!aOa!bOh!iO!X!kO!f!mO%o!`O%p!`O%q!aO%r!aO%s!aOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%kWi%lWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~O%m!_O%n!_O~P!&pO%mWi%nWi~P!&pOa!bOh!iO!X!kO!f!mOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%kWi%lWi%mWi%nWi%oWi%pWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~OV!aO_!aO%q!aO%r!aO%s!aO~P!)nOVWi_Wi%qWi%rWi%sWi~P!)nO!T%dO!U%cOg&VXz&VX~O%z'kO%{'kO~P,eOz'mOg&UX~Og'oO~Oz'pO{'rO!W&XX~Oo0cOv0qOz'pO{'sO!W&XX~P'vO!W'uO~Om!oOn!oOo!rOp!sOkjisjizji{ji!xji#gji%[ji%_ji%zji~Ol!qO~P!.aOlji~P!.aOk0eOl0fOm0dOn0dOo0mOp0nO~Ot'wO~P!/jOV'|Og'}Oo0cOv0qO~P'vOg'}Oz(OO~Og(QO~O!U(SO~Og(TOz(OO!T%dO!U%cO~P%SOk0eOl0fOm0dOn0dOo0mOp0nOgqa!Tqa!Uqa%{qa!Wqa![qa!Qqa#[qatqa!mqa~PEcOV'|Oo0cOv0qO!W&Sa~P'vOz(WO!W&Sa~O!W(XO~Oz(WO!T%dO!U%cO!W&Sa~P%SOV(]Oo0cOv0qO![%}a#g%}a%[%}a%_%}ag%}a{%}a!m%}a%z%}a~P'vOz(^O![%}a#g%}a%[%}a%_%}ag%}a{%}a!m%}a%z%}a~O![(aO~Oz(^O!T%dO!U%cO![%}a~P%SOz(dO!T%dO!U%cO![&Ta~P%SOz(gO{&lX![&lX!m&lX%z&lX~O{(kO![(mO!m(nO%z(jO~OV&OOopOvqO{%hi!x%hi#g%hi%[%hi%_%hi%z%hi~P'vOz(pO{%hi!x%hi#g%hi%[%hi%_%hi%z%hi~O!f&UOh&sa%[&saz&sa#[&sa#g&sa%_&sa#Z&sag&sa~O%[(uO~OV#sOa#tO%uWO~Oz&]O{wa~OopOvqO~P'vOz(^O#g%}a%[%}a%_%}ag%}a{%}a![%}a!m%}a%z%}a~P%SOz(zO#g%hX%[%hX%_%hX%z%hX~O%z#|O#gUi%[Ui%_Ui~O#g&Pa%[&Pa%_&Pan&Pa~P'vOz(}O#g&Pa%[&Pa%_&Pan&Pa~O%uWO#g&ra%[&ra%_&rag&ra~Oz)SO#g&ra%[&ra%_&rag&ra~Og)VO~OV)WOh$WO%uWO~O#Z)XO~O%uWO#g&ta%[&ta%_&ta~Oz)ZO#g&ta%[&ta%_&ta~Oo0cOv0qO#g&pa%[&pa%_&pa{&pa~P'vOz)^O#g&pa%[&pa%_&pa{&pa~OV)`Oa)`O%uWO~O%z)eO~Ot)hO#j)gOP#hiV#hif#hih#hio#his#hiv#hi!P#hi!Q#hi!T#hi!U#hi!X#hi!]#hi!h#hi!r#hi!s#hi!t#hi!{#hi!}#hi#P#hi#R#hi#T#hi#X#hi#Z#hi#^#hi#_#hi#a#hi#c#hi#l#hi#o#hi#s#hi#u#hi#z#hi#}#hi$P#hi%X#hi%o#hi%p#hi%t#hi%u#hi&Z#hi&[#hi&]#hi&^#hi&_#hi&`#hi&a#hi&b#hi&c#hi&d#hi&e#hi&f#hi&g#hi&h#hi&i#hi&j#hi%Z#hi%_#hi~Ot)iOP#kiV#kif#kih#kio#kis#kiv#ki!P#ki!Q#ki!T#ki!U#ki!X#ki!]#ki!h#ki!r#ki!s#ki!t#ki!{#ki!}#ki#P#ki#R#ki#T#ki#X#ki#Z#ki#^#ki#_#ki#a#ki#c#ki#l#ki#o#ki#s#ki#u#ki#z#ki#}#ki$P#ki%X#ki%o#ki%p#ki%t#ki%u#ki&Z#ki&[#ki&]#ki&^#ki&_#ki&`#ki&a#ki&b#ki&c#ki&d#ki&e#ki&f#ki&g#ki&h#ki&i#ki&j#ki%Z#ki%_#ki~OV)kOn&wa~P'vOz)lOn&wa~Oz)lOn&wa~P%SOn)pO~O%Y)tO~Ot)wO#p'WO#q)vOP#niV#nif#nih#nio#nis#niv#ni!P#ni!Q#ni!T#ni!U#ni!X#ni!]#ni!h#ni!r#ni!s#ni!t#ni!{#ni!}#ni#P#ni#R#ni#T#ni#X#ni#Z#ni#^#ni#_#ni#a#ni#c#ni#l#ni#o#ni#s#ni#u#ni#z#ni#}#ni$P#ni%X#ni%o#ni%p#ni%t#ni%u#ni&Z#ni&[#ni&]#ni&^#ni&_#ni&`#ni&a#ni&b#ni&c#ni&d#ni&e#ni&f#ni&g#ni&h#ni&i#ni&j#ni%Z#ni%_#ni~OV)zOo0cOv0qO{$jO~P'vOo0cOv0qO{&xa~P'vOz*OO{&xa~OV*SOa*TOg*WO%q*UO%uWO~O{$jO&{*YO~Oh'_O~Oh!iO{$jO~O%[*_O~O%[*aO%_*aO~OV$}Oa$}Oo0cOv0qOg&Ua~P'vOz*dOg&Ua~Oo0cOv0qO{*gO!W&Xa~P'vOz*hO!W&Xa~Oo0cOv0qOz*hO{*kO!W&Xa~P'vOo0cOv0qOz*hO!W&Xa~P'vOz*hO{*kO!W&Xa~Om0dOn0dOo0mOp0nOgjikjisjizji!Tji!Uji%{ji!Wji{ji![ji#gji%[ji%_ji!Qji#[jitji!mji%zji~Ol0fO~P!NkOlji~P!NkOV'|Og*pOo0cOv0qO~P'vOn*rO~Og*pOz*tO~Og*uO~OV'|Oo0cOv0qO!W&Si~P'vOz*vO!W&Si~O!W*wO~OV(]Oo0cOv0qO![%}i#g%}i%[%}i%_%}ig%}i{%}i!m%}i%z%}i~P'vOz*zO!T%dO!U%cO![&Ti~Oz*}O![%}i#g%}i%[%}i%_%}ig%}i{%}i!m%}i%z%}i~O![+OO~Oa+QOo0cOv0qO![&Ti~P'vOz*zO![&Ti~O![+SO~OV+UOo0cOv0qO{&la![&la!m&la%z&la~P'vOz+VO{&la![&la!m&la%z&la~O!]+YO&n+[O![!nX~O![+^O~O{(kO![+_O~O{(kO![+_O!m+`O~OV&OOopOvqO{%hq!x%hq#g%hq%[%hq%_%hq%z%hq~P'vOz$ri{$ri!x$ri#g$ri%[$ri%_$ri%z$ri~P%SOV&OOopOvqO~P'vOV&OOo0cOv0qO#g%ha%[%ha%_%ha%z%ha~P'vOz+aO#g%ha%[%ha%_%ha%z%ha~Oz$ia#g$ia%[$ia%_$ian$ia~P%SO#g&Pi%[&Pi%_&Pin&Pi~P'vOz+dO#g#Wq%[#Wq%_#Wq~O#[+eOz$va#g$va%[$va%_$vag$va~O%uWO#g&ri%[&ri%_&rig&ri~Oz+gO#g&ri%[&ri%_&rig&ri~OV+iOh$WO%uWO~O%uWO#g&ti%[&ti%_&ti~Oo0cOv0qO#g&pi%[&pi%_&pi{&pi~P'vO{#{Oz#eX!W#eX~Oz+mO!W&uX~O!W+oO~Ot+rO#j)gOP#hqV#hqf#hqh#hqo#hqs#hqv#hq!P#hq!Q#hq!T#hq!U#hq!X#hq!]#hq!h#hq!r#hq!s#hq!t#hq!{#hq!}#hq#P#hq#R#hq#T#hq#X#hq#Z#hq#^#hq#_#hq#a#hq#c#hq#l#hq#o#hq#s#hq#u#hq#z#hq#}#hq$P#hq%X#hq%o#hq%p#hq%t#hq%u#hq&Z#hq&[#hq&]#hq&^#hq&_#hq&`#hq&a#hq&b#hq&c#hq&d#hq&e#hq&f#hq&g#hq&h#hq&i#hq&j#hq%Z#hq%_#hq~On$|az$|a~P%SOV)kOn&wi~P'vOz+yOn&wi~Oz,TO{$jO#[,TO~O#q,VOP#nqV#nqf#nqh#nqo#nqs#nqv#nq!P#nq!Q#nq!T#nq!U#nq!X#nq!]#nq!h#nq!r#nq!s#nq!t#nq!{#nq!}#nq#P#nq#R#nq#T#nq#X#nq#Z#nq#^#nq#_#nq#a#nq#c#nq#l#nq#o#nq#s#nq#u#nq#z#nq#}#nq$P#nq%X#nq%o#nq%p#nq%t#nq%u#nq&Z#nq&[#nq&]#nq&^#nq&_#nq&`#nq&a#nq&b#nq&c#nq&d#nq&e#nq&f#nq&g#nq&h#nq&i#nq&j#nq%Z#nq%_#nq~O#[,WOz%Oa{%Oa~Oo0cOv0qO{&xi~P'vOz,YO{&xi~O{#{O%z,[Og&zXz&zX~O%uWOg&zXz&zX~Oz,`Og&yX~Og,bO~O%Y,eO~O!T%dO!U%cOg&Viz&Vi~OV$}Oa$}Oo0cOv0qOg&Ui~P'vO{,hOz$la!W$la~Oo0cOv0qO{,iOz$la!W$la~P'vOo0cOv0qO{*gO!W&Xi~P'vOz,lO!W&Xi~Oo0cOv0qOz,lO!W&Xi~P'vOz,lO{,oO!W&Xi~Og$hiz$hi!W$hi~P%SOV'|Oo0cOv0qO~P'vOn,qO~OV'|Og,rOo0cOv0qO~P'vOV'|Oo0cOv0qO!W&Sq~P'vOz$gi![$gi#g$gi%[$gi%_$gig$gi{$gi!m$gi%z$gi~P%SOV(]Oo0cOv0qO~P'vOa+QOo0cOv0qO![&Tq~P'vOz,sO![&Tq~O![,tO~OV(]Oo0cOv0qO![%}q#g%}q%[%}q%_%}qg%}q{%}q!m%}q%z%}q~P'vO{,uO~OV+UOo0cOv0qO{&li![&li!m&li%z&li~P'vOz,zO{&li![&li!m&li%z&li~O!]+YO&n+[O![!na~O{(kO![,}O~OV&OOo0cOv0qO#g%hi%[%hi%_%hi%z%hi~P'vOz-OO#g%hi%[%hi%_%hi%z%hi~O%uWO#g&rq%[&rq%_&rqg&rq~Oz-RO#g&rq%[&rq%_&rqg&rq~OV)`Oa)`O%uWO!W&ua~Oz-TO!W&ua~On$|iz$|i~P%SOV)kO~P'vOV)kOn&wq~P'vOt-XOP#myV#myf#myh#myo#mys#myv#my!P#my!Q#my!T#my!U#my!X#my!]#my!h#my!r#my!s#my!t#my!{#my!}#my#P#my#R#my#T#my#X#my#Z#my#^#my#_#my#a#my#c#my#l#my#o#my#s#my#u#my#z#my#}#my$P#my%X#my%o#my%p#my%t#my%u#my&Z#my&[#my&]#my&^#my&_#my&`#my&a#my&b#my&c#my&d#my&e#my&f#my&g#my&h#my&i#my&j#my%Z#my%_#my~O%Z-]O%_-]O~P`O#q-^OP#nyV#nyf#nyh#nyo#nys#nyv#ny!P#ny!Q#ny!T#ny!U#ny!X#ny!]#ny!h#ny!r#ny!s#ny!t#ny!{#ny!}#ny#P#ny#R#ny#T#ny#X#ny#Z#ny#^#ny#_#ny#a#ny#c#ny#l#ny#o#ny#s#ny#u#ny#z#ny#}#ny$P#ny%X#ny%o#ny%p#ny%t#ny%u#ny&Z#ny&[#ny&]#ny&^#ny&_#ny&`#ny&a#ny&b#ny&c#ny&d#ny&e#ny&f#ny&g#ny&h#ny&i#ny&j#ny%Z#ny%_#ny~Oz-aO{$jO#[-aO~Oo0cOv0qO{&xq~P'vOz-dO{&xq~O%z,[Og&zaz&za~O{#{Og&zaz&za~OV*SOa*TO%q*UO%uWOg&ya~Oz-hOg&ya~O$S-lO~OV$}Oa$}Oo0cOv0qO~P'vOo0cOv0qO{-mOz$li!W$li~P'vOo0cOv0qOz$li!W$li~P'vO{-mOz$li!W$li~Oo0cOv0qO{*gO~P'vOo0cOv0qO{*gO!W&Xq~P'vOz-pO!W&Xq~Oo0cOv0qOz-pO!W&Xq~P'vOs-sO!T%dO!U%cOg&Oq!W&Oq![&Oqz&Oq~P!/jOa+QOo0cOv0qO![&Ty~P'vOz$ji![$ji~P%SOa+QOo0cOv0qO~P'vOV+UOo0cOv0qO~P'vOV+UOo0cOv0qO{&lq![&lq!m&lq%z&lq~P'vO{(kO![-xO!m-yO%z-wO~OV&OOo0cOv0qO#g%hq%[%hq%_%hq%z%hq~P'vO%uWO#g&ry%[&ry%_&ryg&ry~OV)`Oa)`O%uWO!W&ui~Ot-}OP#m!RV#m!Rf#m!Rh#m!Ro#m!Rs#m!Rv#m!R!P#m!R!Q#m!R!T#m!R!U#m!R!X#m!R!]#m!R!h#m!R!r#m!R!s#m!R!t#m!R!{#m!R!}#m!R#P#m!R#R#m!R#T#m!R#X#m!R#Z#m!R#^#m!R#_#m!R#a#m!R#c#m!R#l#m!R#o#m!R#s#m!R#u#m!R#z#m!R#}#m!R$P#m!R%X#m!R%o#m!R%p#m!R%t#m!R%u#m!R&Z#m!R&[#m!R&]#m!R&^#m!R&_#m!R&`#m!R&a#m!R&b#m!R&c#m!R&d#m!R&e#m!R&f#m!R&g#m!R&h#m!R&i#m!R&j#m!R%Z#m!R%_#m!R~Oo0cOv0qO{&xy~P'vOV*SOa*TO%q*UO%uWOg&yi~O$S-lO%Z.VO%_.VO~OV.aOh._O!X.^O!].`O!h.YO!s.[O!t.[O%p.XO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O~Oo0cOv0qOz$lq!W$lq~P'vO{.fOz$lq!W$lq~Oo0cOv0qO{*gO!W&Xy~P'vOz.gO!W&Xy~Oo0cOv.kO~P'vOs-sO!T%dO!U%cOg&Oy!W&Oy![&Oyz&Oy~P!/jO{(kO![.nO~O{(kO![.nO!m.oO~OV*SOa*TO%q*UO%uWO~Oh.tO!f.rOz$TX#[$TX%j$TXg$TX~Os$TX{$TX!W$TX![$TX~P$-bO%o.vO%p.vOs$UXz$UX{$UX#[$UX%j$UX!W$UXg$UX![$UX~O!h.xO~Oz.|O#[/OO%j.yOs&|X{&|X!W&|Xg&|X~Oa/RO~P$)zOh.tOs&}Xz&}X{&}X#[&}X%j&}X!W&}Xg&}X![&}X~Os/VO{$jO~Oo0cOv0qOz$ly!W$ly~P'vOo0cOv0qO{*gO!W&X!R~P'vOz/ZO!W&X!R~Og&RXs&RX!T&RX!U&RX!W&RX![&RXz&RX~P!/jOs-sO!T%dO!U%cOg&Qa!W&Qa![&Qaz&Qa~O{(kO![/^O~O!f.rOh$[as$[az$[a{$[a#[$[a%j$[a!W$[ag$[a![$[a~O!h/eO~O%o.vO%p.vOs$Uaz$Ua{$Ua#[$Ua%j$Ua!W$Uag$Ua![$Ua~O%j.yOs$Yaz$Ya{$Ya#[$Ya!W$Yag$Ya![$Ya~Os&|a{&|a!W&|ag&|a~P$)nOz/jOs&|a{&|a!W&|ag&|a~O!W/mO~Og/mO~O{/oO~O![/pO~Oo0cOv0qO{*gO!W&X!Z~P'vO{/sO~O%z/tO~P$-bOz/uO#[/OO%j.yOg'PX~Oz/uOg'PX~Og/wO~O!h/xO~O#[/OOs%Saz%Sa{%Sa%j%Sa!W%Sag%Sa![%Sa~O#[/OO%j.yOs%Waz%Wa{%Wa!W%Wag%Wa~Os&|i{&|i!W&|ig&|i~P$)nOz/zO#[/OO%j.yO!['Oa~Og'Pa~P$)nOz0SOg'Pa~Oa0UO!['Oi~P$)zOz0WO!['Oi~Oz0WO#[/OO%j.yO!['Oi~O#[/OO%j.yOg$biz$bi~O%z0ZO~P$-bO#[/OO%j.yOg%Vaz%Va~Og'Pi~P$)nO{0^O~Oa0UO!['Oq~P$)zOz0`O!['Oq~O#[/OO%j.yOz%Ui![%Ui~Oa0UO~P$)zOa0UO!['Oy~P$)zO#[/OO%j.yOg$ciz$ci~O#[/OO%j.yOz%Uq![%Uq~Oz+aO#g%ha%[%ha%_%ha%z%ha~P%SOV&OOo0cOv0qO~P'vOn0hO~Oo0hO~P'vO{0iO~Ot0jO~P!/jO&]&Z&j&h&i&g&f&d&e&c&b&`&a&_&^&[%u~",
  goto: "!=j'QPPPPPP'RP'Z*s+[+t,_,y-fP.SP'Z.r.r'ZPPP'Z2[PPPPPP2[5PPP5PP7b7k=sPP=v>h>kPP'Z'ZPP>zPP'Z'ZPP'Z'Z'Z'Z'Z?O?w'ZP?zP@QDXGuGyPG|HWH['ZPPPH_Hk'RP'R'RP'RP'RP'RP'RP'R'R'RP'RPP'RPP'RP'RPHqH}IVPI^IdPI^PI^I^PPPI^PKrPK{LVL]KrPI^LfPI^PLmLsPLwM]MzNeLwLwNkNxLwLwLwLw! ^! d! g! l! o! y!!P!!]!!o!!u!#P!#V!#s!#y!$P!$Z!$a!$g!$y!%T!%Z!%a!%k!%q!%w!%}!&T!&Z!&e!&k!&u!&{!'U!'[!'k!'s!'}!(UPPPPPPPPPPP!([!(_!(e!(n!(x!)TPPPPPPPPPPPP!-u!/Z!3^!6oPP!6w!7W!7a!8Y!8P!8c!8i!8l!8o!8r!8z!9jPPPPPPPPPPPPPPPPP!9m!9q!9wP!:]!:a!:m!:v!;S!;j!;m!;p!;v!;|!<S!<VP!<_!<h!=d!=g]eOn#g$j)t,P'}`OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0r{!cQ#c#p$R$d$p%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g}!dQ#c#p$R$d$p$u%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!P!eQ#c#p$R$d$p$u$v%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!R!fQ#c#p$R$d$p$u$v$w%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!T!gQ#c#p$R$d$p$u$v$w$x%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!V!hQ#c#p$R$d$p$u$v$w$x$y%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!Z!hQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g'}TOTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0r&eVOYZ[dnprxy}!P!Q!U!i!k!o!p!q!s!t#[#d#g#y#{#}$Q$h$j$}%S%Z%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0n0r%oXOYZ[dnrxy}!P!Q!U!i!k#[#d#g#y#{#}$Q$h$j$}%S%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,s,u,w,y,z-O-d-f-m-p.f.g/V/Z0i0j0kQ#vqQ/[.kR0o0q't`OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rh#jhz{$W$Z&l&q)S)X+f+g-RW#rq&].k0qQ$]|Q$a!OQ$n!VQ$o!WW$|!i'm*d,gS&[#s#tQ'S$iQ(s&UQ)U&nU)Y&s)Z+jW)a&w+m-T-{Q*Q']W*R'_,`-h.TQ+l)`S,_*S*TQ-Q+eQ-_,TQ-c,WQ.R-al.W-l.^._.a.z.|/R/j/o/t/y0U0Z0^Q/S.`Q/a.tQ/l/OU0P/u0S0[X0V/z0W0_0`R&Z#r!_!wYZ!P!Q!k%S%`%g'p'r's(O(W)g*g*h*k*q*t*v,h,i,k,l,o-m-p.f.g/ZR%^!vQ!{YQ%x#[Q&d#}Q&g$QR,{+YT.j-s/s!Y!jQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v0gQ&X#kQ'c$oR*^'dR'l$|Q%V!mR/_.r'|_OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rS#a_#b!P.[-l.^._.`.a.t.z.|/R/j/o/t/u/y/z0S0U0W0Z0[0^0_0`'|_OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rT#a_#bT#^^#_R(o%xa(l%x(n(o+`,{-y-z.oT+[(k+]R-z,{Q$PsQ+l)aQ,^*RR-e,_X#}s$O$P&fQ&y$aQ'a$nQ'd$oR)s'SQ)b&wV-S+m-T-{ZgOn$j)t,PXkOn)t,PQ$k!TQ&z$bQ&{$cQ'^$mQ'b$oQ)q'RQ)x'WQ){'XQ)|'YQ*Z'`S*]'c'dQ+s)gQ+u)hQ+v)iQ+z)oS+|)r*[Q,Q)vQ,R)wS,S)y)zQ,d*^Q-V+rQ-W+tQ-Y+{S-Z+},OQ-`,UQ-b,VQ-|-XQ.O-[Q.P-^Q.Q-_Q.p-}Q.q.RQ/W.dR/r/XWkOn)t,PR#mjQ'`$nS)r'S'aR,O)sQ,]*RR-f,^Q*['`Q+})rR-[,OZiOjn)t,PQ'f$pR*`'gT-j,e-ku.c-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^t.c-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^Q/S.`X0V/z0W0_0`!P.Z-l.^._.`.a.t.z.|/R/j/o/t/u/y/z0S0U0W0Z0[0^0_0`Q.w.YR/f.xg.z.].{/b/i/n/|0O0Q0]0a0bu.b-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^X.u.W.b/a0PR/c.tV0R/u0S0[R/X.dQnOS#on,PR,P)tQ&^#uR(x&^S%m#R#wS(_%m(bT(b%p&`Q%a!yQ%h!}W(P%a%h(U(YQ(U%eR(Y%jQ&i$RR)O&iQ(e%qQ*{(`T+R(e*{Q'n%OR*e'nS'q%R%SY*i'q*j,m-q.hU*j'r's'tU,m*k*l*mS-q,n,oR.h-rQ#Y]R%t#YQ#_^R%y#_Q(h%vS+W(h+XR+X(iQ+](kR,|+]Q#b_R%{#bQ#ebQ%}#cW&Q#e%}({+bQ({&cR+b0gQ$OsS&e$O&fR&f$PQ&v$_R)_&vQ&V#jR(t&VQ&m$VS)T&m+hR+h)UQ$Z{R&p$ZQ&t$]R)[&tQ+n)bR-U+nQ#hfR&S#hQ)f&zR+q)fQ&}$dS)m&})nR)n'OQ'V$kR)u'VQ'[$lS*P'[,ZR,Z*QQ,a*VR-i,aWjOn)t,PR#ljQ-k,eR.U-kd.{.]/b/i/n/|0O0Q0]0a0bR/h.{U.s.W/a0PR/`.sQ/{/nS0X/{0YR0Y/|S/v/b/cR0T/vQ.}.]R/k.}R!ZPXmOn)t,PWlOn)t,PR'T$jYfOn$j)t,PR&R#g[sOn#g$j)t,PR&d#}&dQOYZ[dnprxy}!P!Q!U!i!k!o!p!q!s!t#[#d#g#y#{#}$Q$h$j$}%S%Z%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0n0rQ!nTQ#caQ#poU$Rt%c(SS$d!R$gQ$p!XQ$u!cQ$v!dQ$w!eQ$x!fQ$y!gQ$z!hQ%e!zQ%j#OQ%p#SQ%q#TQ&`#xQ'O$eQ'g$qQ(q&OU(|&h(}+cW)j&|)l+x+yQ*o'|Q*x(]Q+w)kQ,v+QR0g0lQ!yYQ!}ZQ$b!PQ$c!QQ%R!kQ't%S^'{%`%g(O(W*q*t*v^*f'p*h,k,l-p.g/ZQ*l'rQ*m'sQ+t)gQ,j*gQ,n*kQ-n,hQ-o,iQ-r,oQ.e-mR/Y.f[bOn#g$j)t,P!^!vYZ!P!Q!k%S%`%g'p'r's(O(W)g*g*h*k*q*t*v,h,i,k,l,o-m-p.f.g/ZQ#R[Q#fdS#wrxQ$UyW$_}$Q'P)pS$l!U$hW${!i'm*d,gS%v#[+Y`&P#d%|(p(r(z+a-O0kQ&a#yQ&b#{Q&c#}Q'j$}Q'z%^W([%l(^*y*}Q(`%nQ(i%wQ(v&ZS(y&_0iQ)P&jQ)Q&kU)]&u)^+kQ)d&xQ)y'WY)}'Z*O,X,Y-dQ*b'lS*n'w0jW+P(d*z,s,wW+T(g+V,y,zQ+p)eQ,U)zQ,c*YQ,x+UQ-P+dQ-e,]Q-v,uQ.S-fR/q/VhUOn#d#g$j%|&_'w(p(r)t,P%U!uYZ[drxy}!P!Q!U!i!k#[#y#{#}$Q$h$}%S%^%`%g%l%n%w&Z&j&k&u&x'P'W'Z'l'm'p'r's(O(W(^(d(g(z)^)e)g)p)z*O*Y*d*g*h*k*q*t*v*y*z*}+U+V+Y+a+d+k,X,Y,],g,h,i,k,l,o,s,u,w,y,z-O-d-f-m-p.f.g/V/Z0i0j0kQ#qpW%W!o!s0d0nQ%X!pQ%Y!qQ%[!tQ%f0cS'v%Z0hQ'x0eQ'y0fQ,p*rQ-u,qS.i-s/sR0p0rU#uq.k0qR(w&][cOn#g$j)t,PZ!xY#[#}$Q+YQ#W[Q#zrR$TxQ%b!yQ%i!}Q%o#RQ'j${Q(V%eQ(Z%jQ(c%pQ(f%qQ*|(`Q,f*bQ-t,pQ.m-uR/].lQ$StQ(R%cR*s(SQ.l-sR/}/sR#QZR#V[R%Q!iQ%O!iV*c'm*d,g!Z!lQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v0gR%T!kT#]^#_Q%x#[R,{+YQ(m%xS+_(n(oQ,}+`Q-x,{S.n-y-zR/^.oT+Z(k+]Q$`}Q&g$QQ)o'PR+{)pQ$XzQ)W&qR+i)XQ$XzQ&o$WQ)W&qR+i)XQ#khW$Vz$W&q)XQ$[{Q&r$ZZ)R&l)S+f+g-RR$^|R)c&wXlOn)t,PQ$f!RR'Q$gQ$m!UR'R$hR*X'_Q*V'_V-g,`-h.TQ.d-lQ/P.^R/Q._U.]-l.^._Q/U.aQ/b.tQ/g.zU/i.|/j/yQ/n/RQ/|/oQ0O/tU0Q/u0S0[Q0]0UQ0a0ZR0b0^R/T.`R/d.t",
  nodeNames: "⚠ print Escape { Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ) ( ParenthesizedExpression BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from TupleExpression ComprehensionExpression async for LambdaExpression ] [ ArrayExpression ArrayComprehensionExpression } { DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatSelfDoc FormatConversion FormatSpec FormatReplacement FormatSelfDoc ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert TypeDefinition type TypeParamList TypeParam StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At MatchStatement match MatchBody MatchClause case CapturePattern LiteralPattern ArithOp ArithOp AsPattern OrPattern LogicOp AttributePattern SequencePattern MappingPattern StarPattern ClassPattern PatternArgList KeywordPattern KeywordPattern Guard",
  maxTerm: 277,
  context: hZ,
  nodeProps: [
    ["isolate", -5, 4, 71, 72, 73, 77, ""],
    ["group", -15, 6, 85, 87, 88, 90, 92, 94, 96, 98, 99, 100, 102, 105, 108, 110, "Statement Statement", -22, 8, 18, 21, 25, 40, 49, 50, 56, 57, 60, 61, 62, 63, 64, 67, 70, 71, 72, 79, 80, 81, 82, "Expression", -10, 114, 116, 119, 121, 122, 126, 128, 133, 135, 138, "Statement", -9, 143, 144, 147, 148, 150, 151, 152, 153, 154, "Pattern"],
    ["openedBy", 23, "(", 54, "[", 58, "{"],
    ["closedBy", 24, ")", 55, "]", 59, "}"]
  ],
  propSources: [mZ],
  skippedNodes: [0, 4],
  repeatNodeCount: 34,
  tokenData: "!2|~R!`OX%TXY%oY[%T[]%o]p%Tpq%oqr'ars)Yst*xtu%Tuv,dvw-hwx.Uxy/tyz0[z{0r{|2S|}2p}!O3W!O!P4_!P!Q:Z!Q!R;k!R![>_![!]Do!]!^Es!^!_FZ!_!`Gk!`!aHX!a!b%T!b!cIf!c!dJU!d!eK^!e!hJU!h!i!#f!i!tJU!t!u!,|!u!wJU!w!x!.t!x!}JU!}#O!0S#O#P&o#P#Q!0j#Q#R!1Q#R#SJU#S#T%T#T#UJU#U#VK^#V#YJU#Y#Z!#f#Z#fJU#f#g!,|#g#iJU#i#j!.t#j#oJU#o#p!1n#p#q!1s#q#r!2a#r#s!2f#s$g%T$g;'SJU;'S;=`KW<%lOJU`%YT&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T`%lP;=`<%l%To%v]&n`%c_OX%TXY%oY[%T[]%o]p%Tpq%oq#O%T#O#P&o#P#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To&tX&n`OY%TYZ%oZ]%T]^%o^#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc'f[&n`O!_%T!_!`([!`#T%T#T#U(r#U#f%T#f#g(r#g#h(r#h#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc(cTmR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc(yT!mR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk)aV&n`&[ZOr%Trs)vs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk){V&n`Or%Trs*bs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk*iT&n`&^ZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To+PZS_&n`OY*xYZ%TZ]*x]^%T^#o*x#o#p+r#p#q*x#q#r+r#r;'S*x;'S;=`,^<%lO*x_+wTS_OY+rZ]+r^;'S+r;'S;=`,W<%lO+r_,ZP;=`<%l+ro,aP;=`<%l*xj,kV%rQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj-XT!xY&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj-oV%lQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk.]V&n`&ZZOw%Twx.rx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk.wV&n`Ow%Twx/^x#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk/eT&n`&]ZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk/{ThZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc0cTgR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk0yXVZ&n`Oz%Tz{1f{!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk1mVaR&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk2ZV%oZ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc2wTzR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To3_W%pZ&n`O!_%T!_!`-Q!`!a3w!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Td4OT&{S&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk4fX!fQ&n`O!O%T!O!P5R!P!Q%T!Q![6T![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk5WV&n`O!O%T!O!P5m!P#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk5tT!rZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti6[a!hX&n`O!Q%T!Q![6T![!g%T!g!h7a!h!l%T!l!m9s!m#R%T#R#S6T#S#X%T#X#Y7a#Y#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti7fZ&n`O{%T{|8X|}%T}!O8X!O!Q%T!Q![8s![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti8^V&n`O!Q%T!Q![8s![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti8z]!hX&n`O!Q%T!Q![8s![!l%T!l!m9s!m#R%T#R#S8s#S#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti9zT!hX&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk:bX%qR&n`O!P%T!P!Q:}!Q!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj;UV%sQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti;ro!hX&n`O!O%T!O!P=s!P!Q%T!Q![>_![!d%T!d!e?q!e!g%T!g!h7a!h!l%T!l!m9s!m!q%T!q!rA]!r!z%T!z!{Bq!{#R%T#R#S>_#S#U%T#U#V?q#V#X%T#X#Y7a#Y#^%T#^#_9s#_#c%T#c#dA]#d#l%T#l#mBq#m#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti=xV&n`O!Q%T!Q![6T![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti>fc!hX&n`O!O%T!O!P=s!P!Q%T!Q![>_![!g%T!g!h7a!h!l%T!l!m9s!m#R%T#R#S>_#S#X%T#X#Y7a#Y#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti?vY&n`O!Q%T!Q!R@f!R!S@f!S#R%T#R#S@f#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti@mY!hX&n`O!Q%T!Q!R@f!R!S@f!S#R%T#R#S@f#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiAbX&n`O!Q%T!Q!YA}!Y#R%T#R#SA}#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiBUX!hX&n`O!Q%T!Q!YA}!Y#R%T#R#SA}#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiBv]&n`O!Q%T!Q![Co![!c%T!c!iCo!i#R%T#R#SCo#S#T%T#T#ZCo#Z#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiCv]!hX&n`O!Q%T!Q![Co![!c%T!c!iCo!i#R%T#R#SCo#S#T%T#T#ZCo#Z#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%ToDvV{_&n`O!_%T!_!`E]!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TcEdT%{R&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkEzT#gZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkFbXmR&n`O!^%T!^!_F}!_!`([!`!a([!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TjGUV%mQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkGrV%zZ&n`O!_%T!_!`([!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkH`WmR&n`O!_%T!_!`([!`!aHx!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TjIPV%nQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkIoV_Q#}P&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%ToJ_]&n`&YS%uZO!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUoKZP;=`<%lJUoKge&n`&YS%uZOr%Trs)Ysw%Twx.Ux!Q%T!Q![JU![!c%T!c!tJU!t!uLx!u!}JU!}#R%T#R#SJU#S#T%T#T#fJU#f#gLx#g#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUoMRa&n`&YS%uZOr%TrsNWsw%Twx! vx!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUkN_V&n`&`ZOr%TrsNts#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkNyV&n`Or%Trs! `s#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk! gT&n`&bZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk! }V&n`&_ZOw%Twx!!dx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!!iV&n`Ow%Twx!#Ox#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!#VT&n`&aZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!#oe&n`&YS%uZOr%Trs!%Qsw%Twx!&px!Q%T!Q![JU![!c%T!c!tJU!t!u!(`!u!}JU!}#R%T#R#SJU#S#T%T#T#fJU#f#g!(`#g#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!%XV&n`&dZOr%Trs!%ns#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!%sV&n`Or%Trs!&Ys#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!&aT&n`&fZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!&wV&n`&cZOw%Twx!'^x#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!'cV&n`Ow%Twx!'xx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!(PT&n`&eZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!(ia&n`&YS%uZOr%Trs!)nsw%Twx!+^x!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!)uV&n`&hZOr%Trs!*[s#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!*aV&n`Or%Trs!*vs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!*}T&n`&jZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!+eV&n`&gZOw%Twx!+zx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!,PV&n`Ow%Twx!,fx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!,mT&n`&iZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!-Vi&n`&YS%uZOr%TrsNWsw%Twx! vx!Q%T!Q![JU![!c%T!c!dJU!d!eLx!e!hJU!h!i!(`!i!}JU!}#R%T#R#SJU#S#T%T#T#UJU#U#VLx#V#YJU#Y#Z!(`#Z#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUo!.}a&n`&YS%uZOr%Trs)Ysw%Twx.Ux!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!0ZT!XZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc!0qT!WR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj!1XV%kQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T~!1sO!]~k!1zV%jR&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T~!2fO![~i!2mT%tX&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T",
  tokenizers: [OZ, cZ, oZ, dZ, 0, 1, 2, 3, 4],
  topRules: { Script: [0, 5] },
  specialized: [{ term: 221, get: (n) => gZ[n] || -1 }],
  tokenPrec: 7668
}), SQ = /* @__PURE__ */ new Xb(), gk = /* @__PURE__ */ new Set([
  "Script",
  "Body",
  "FunctionDefinition",
  "ClassDefinition",
  "LambdaExpression",
  "ForStatement",
  "MatchClause"
]);
function Gc(n) {
  return (t, e, i) => {
    if (i)
      return !1;
    let s = t.node.getChild("VariableName");
    return s && e(s, n), !0;
  };
}
const SZ = {
  FunctionDefinition: /* @__PURE__ */ Gc("function"),
  ClassDefinition: /* @__PURE__ */ Gc("class"),
  ForStatement(n, t, e) {
    if (e) {
      for (let i = n.node.firstChild; i; i = i.nextSibling)
        if (i.name == "VariableName")
          t(i, "variable");
        else if (i.name == "in")
          break;
    }
  },
  ImportStatement(n, t) {
    var e, i;
    let { node: s } = n, a = ((e = s.firstChild) === null || e === void 0 ? void 0 : e.name) == "from";
    for (let o = s.getChild("import"); o; o = o.nextSibling)
      o.name == "VariableName" && ((i = o.nextSibling) === null || i === void 0 ? void 0 : i.name) != "as" && t(o, a ? "variable" : "namespace");
  },
  AssignStatement(n, t) {
    for (let e = n.node.firstChild; e; e = e.nextSibling)
      if (e.name == "VariableName")
        t(e, "variable");
      else if (e.name == ":" || e.name == "AssignOp")
        break;
  },
  ParamList(n, t) {
    for (let e = null, i = n.node.firstChild; i; i = i.nextSibling)
      i.name == "VariableName" && (!e || !/\*|AssignOp/.test(e.name)) && t(i, "variable"), e = i;
  },
  CapturePattern: /* @__PURE__ */ Gc("variable"),
  AsPattern: /* @__PURE__ */ Gc("variable"),
  __proto__: null
};
function yk(n, t) {
  let e = SQ.get(t);
  if (e)
    return e;
  let i = [], s = !0;
  function a(o, u) {
    let h = n.sliceString(o.from, o.to);
    i.push({ label: h, type: u });
  }
  return t.cursor(ae.IncludeAnonymous).iterate((o) => {
    if (o.name) {
      let u = SZ[o.name];
      if (u && u(o, a, s) || !s && gk.has(o.name))
        return !1;
      s = !1;
    } else if (o.to - o.from > 8192) {
      for (let u of yk(n, o.node))
        i.push(u);
      return !1;
    }
  }), SQ.set(t, i), i;
}
const QQ = /^[\w\xa1-\uffff][\w\d\xa1-\uffff]*$/, Sk = ["String", "FormatString", "Comment", "PropertyName"];
function QZ(n) {
  let t = ue(n.state).resolveInner(n.pos, -1);
  if (Sk.indexOf(t.name) > -1)
    return null;
  let e = t.name == "VariableName" || t.to - t.from < 20 && QQ.test(n.state.sliceDoc(t.from, t.to));
  if (!e && !n.explicit)
    return null;
  let i = [];
  for (let s = t; s; s = s.parent)
    gk.has(s.name) && (i = i.concat(yk(n.state.doc, s)));
  return {
    options: i,
    from: e ? t.from : n.pos,
    validFor: QQ
  };
}
const vZ = /* @__PURE__ */ [
  "__annotations__",
  "__builtins__",
  "__debug__",
  "__doc__",
  "__import__",
  "__name__",
  "__loader__",
  "__package__",
  "__spec__",
  "False",
  "None",
  "True"
].map((n) => ({ label: n, type: "constant" })).concat(/* @__PURE__ */ [
  "ArithmeticError",
  "AssertionError",
  "AttributeError",
  "BaseException",
  "BlockingIOError",
  "BrokenPipeError",
  "BufferError",
  "BytesWarning",
  "ChildProcessError",
  "ConnectionAbortedError",
  "ConnectionError",
  "ConnectionRefusedError",
  "ConnectionResetError",
  "DeprecationWarning",
  "EOFError",
  "Ellipsis",
  "EncodingWarning",
  "EnvironmentError",
  "Exception",
  "FileExistsError",
  "FileNotFoundError",
  "FloatingPointError",
  "FutureWarning",
  "GeneratorExit",
  "IOError",
  "ImportError",
  "ImportWarning",
  "IndentationError",
  "IndexError",
  "InterruptedError",
  "IsADirectoryError",
  "KeyError",
  "KeyboardInterrupt",
  "LookupError",
  "MemoryError",
  "ModuleNotFoundError",
  "NameError",
  "NotADirectoryError",
  "NotImplemented",
  "NotImplementedError",
  "OSError",
  "OverflowError",
  "PendingDeprecationWarning",
  "PermissionError",
  "ProcessLookupError",
  "RecursionError",
  "ReferenceError",
  "ResourceWarning",
  "RuntimeError",
  "RuntimeWarning",
  "StopAsyncIteration",
  "StopIteration",
  "SyntaxError",
  "SyntaxWarning",
  "SystemError",
  "SystemExit",
  "TabError",
  "TimeoutError",
  "TypeError",
  "UnboundLocalError",
  "UnicodeDecodeError",
  "UnicodeEncodeError",
  "UnicodeError",
  "UnicodeTranslateError",
  "UnicodeWarning",
  "UserWarning",
  "ValueError",
  "Warning",
  "ZeroDivisionError"
].map((n) => ({ label: n, type: "type" }))).concat(/* @__PURE__ */ [
  "bool",
  "bytearray",
  "bytes",
  "classmethod",
  "complex",
  "float",
  "frozenset",
  "int",
  "list",
  "map",
  "memoryview",
  "object",
  "range",
  "set",
  "staticmethod",
  "str",
  "super",
  "tuple",
  "type"
].map((n) => ({ label: n, type: "class" }))).concat(/* @__PURE__ */ [
  "abs",
  "aiter",
  "all",
  "anext",
  "any",
  "ascii",
  "bin",
  "breakpoint",
  "callable",
  "chr",
  "compile",
  "delattr",
  "dict",
  "dir",
  "divmod",
  "enumerate",
  "eval",
  "exec",
  "exit",
  "filter",
  "format",
  "getattr",
  "globals",
  "hasattr",
  "hash",
  "help",
  "hex",
  "id",
  "input",
  "isinstance",
  "issubclass",
  "iter",
  "len",
  "license",
  "locals",
  "max",
  "min",
  "next",
  "oct",
  "open",
  "ord",
  "pow",
  "print",
  "property",
  "quit",
  "repr",
  "reversed",
  "round",
  "setattr",
  "slice",
  "sorted",
  "sum",
  "vars",
  "zip"
].map((n) => ({ label: n, type: "function" }))), bZ = [
  /* @__PURE__ */ Kt("def ${name}(${params}):\n	${}", {
    label: "def",
    detail: "function",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt("for ${name} in ${collection}:\n	${}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt("while ${}:\n	${}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt("try:\n	${}\nexcept ${error}:\n	${}", {
    label: "try",
    detail: "/ except block",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt(`if \${}:
	
`, {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt("if ${}:\n	${}\nelse:\n	${}", {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt("class ${name}:\n	def __init__(self, ${params}):\n			${}", {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt("import ${module}", {
    label: "import",
    detail: "statement",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt("from ${module} import ${names}", {
    label: "from",
    detail: "import",
    type: "keyword"
  })
], xZ = /* @__PURE__ */ Nx(Sk, /* @__PURE__ */ Gp(/* @__PURE__ */ vZ.concat(bZ)));
function td(n) {
  let { node: t, pos: e } = n, i = n.lineIndent(e, -1), s = null;
  for (; ; ) {
    let a = t.childBefore(e);
    if (a)
      if (a.name == "Comment")
        e = a.from;
      else if (a.name == "Body" || a.name == "MatchBody")
        n.baseIndentFor(a) + n.unit <= i && (s = a), t = a;
      else if (a.name == "MatchClause")
        t = a;
      else if (a.type.is("Statement"))
        t = a;
      else
        break;
    else break;
  }
  return s;
}
function ed(n, t) {
  let e = n.baseIndentFor(t), i = n.lineAt(n.pos, -1), s = i.from + i.text.length;
  return /^\s*($|#)/.test(i.text) && n.node.to < s + 100 && !/\S/.test(n.state.sliceDoc(s, n.node.to)) && n.lineIndent(n.pos, -1) <= e || /^\s*(else:|elif |except |finally:|case\s+[^=:]+:)/.test(n.textAfter) && n.lineIndent(n.pos, -1) > e ? null : e + n.unit;
}
const id = /* @__PURE__ */ Da.define({
  name: "python",
  parser: /* @__PURE__ */ yZ.configure({
    props: [
      /* @__PURE__ */ Xp.add({
        Body: (n) => {
          var t;
          let e = /^\s*(#|$)/.test(n.textAfter) && td(n) || n.node;
          return (t = ed(n, e)) !== null && t !== void 0 ? t : n.continue();
        },
        MatchBody: (n) => {
          var t;
          let e = td(n);
          return (t = ed(n, e || n.node)) !== null && t !== void 0 ? t : n.continue();
        },
        IfStatement: (n) => /^\s*(else:|elif )/.test(n.textAfter) ? n.baseIndent : n.continue(),
        "ForStatement WhileStatement": (n) => /^\s*else:/.test(n.textAfter) ? n.baseIndent : n.continue(),
        TryStatement: (n) => /^\s*(except[ :]|finally:|else:)/.test(n.textAfter) ? n.baseIndent : n.continue(),
        MatchStatement: (n) => /^\s*case /.test(n.textAfter) ? n.baseIndent + n.unit : n.continue(),
        "TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression": /* @__PURE__ */ lu({ closing: ")" }),
        "DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression": /* @__PURE__ */ lu({ closing: "}" }),
        "ArrayExpression ArrayComprehensionExpression": /* @__PURE__ */ lu({ closing: "]" }),
        MemberExpression: (n) => n.baseIndent + n.unit,
        "String FormatString": () => null,
        Script: (n) => {
          var t;
          let e = td(n);
          return (t = e && ed(n, e)) !== null && t !== void 0 ? t : n.continue();
        }
      }),
      /* @__PURE__ */ zp.add({
        "ArrayExpression DictionaryExpression SetExpression TupleExpression": Bb,
        Body: (n, t) => ({ from: n.from + 1, to: n.to - (n.to == t.doc.length ? 0 : 1) }),
        "String FormatString": (n, t) => ({ from: t.doc.lineAt(n.from).to, to: n.to })
      })
    ]
  }),
  languageData: {
    closeBrackets: {
      brackets: ["(", "[", "{", "'", '"', "'''", '"""'],
      stringPrefixes: [
        "f",
        "fr",
        "rf",
        "r",
        "u",
        "b",
        "br",
        "rb",
        "F",
        "FR",
        "RF",
        "R",
        "U",
        "B",
        "BR",
        "RB"
      ]
    },
    commentTokens: { line: "#" },
    // Indent logic logic are triggered upon below input patterns
    indentOnInput: /^\s*([\}\]\)]|else:|elif |except |finally:|case\s+[^:]*:?)$/
  }
});
function kZ() {
  return new Ub(id, [
    id.data.of({ autocomplete: QZ }),
    id.data.of({ autocomplete: xZ })
  ]);
}
function wZ({ initialCode: n = "" }) {
  const t = lv(), [e, i] = kn(t.codeAtom), [s] = kn(t.pyodideReadyAtom), [, a] = kn(t.executePyCodeAtom), [, o] = kn(t.initializePyodideAtom);
  St.useEffect(() => {
    n && !e && i(n), o();
  }, []), St.useEffect(() => {
    s && e && a();
  }, [s]);
  const u = Jl.of([
    {
      key: "Alt-Enter",
      run: () => (a(), !0)
    }
  ]);
  return /* @__PURE__ */ ie.createElement("div", { className: "app-container" }, /* @__PURE__ */ ie.createElement("div", { className: "editor-container" }, /* @__PURE__ */ ie.createElement(
    em,
    {
      value: e,
      extensions: [kZ(), u],
      onChange: i
    }
  )), /* @__PURE__ */ ie.createElement("div", { className: "visualization-container" }, /* @__PURE__ */ ie.createElement(Pk, null)));
}
const TZ = 315, $Z = 316, vQ = 1, PZ = 2, RZ = 3, AZ = 4, MZ = 317, qZ = 319, CZ = 320, ZZ = 5, EZ = 6, XZ = 0, rp = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], Qk = 125, _Z = 59, ap = 47, zZ = 42, DZ = 43, VZ = 45, YZ = 60, UZ = 44, jZ = 63, LZ = 46, BZ = 91, GZ = new ck({
  start: !1,
  shift(n, t) {
    return t == ZZ || t == EZ || t == qZ ? n : t == CZ;
  },
  strict: !1
}), NZ = new Rn((n, t) => {
  let { next: e } = n;
  (e == Qk || e == -1 || t.context) && n.acceptToken(MZ);
}, { contextual: !0, fallback: !0 }), WZ = new Rn((n, t) => {
  let { next: e } = n, i;
  rp.indexOf(e) > -1 || e == ap && ((i = n.peek(1)) == ap || i == zZ) || e != Qk && e != _Z && e != -1 && !t.context && n.acceptToken(TZ);
}, { contextual: !0 }), HZ = new Rn((n, t) => {
  n.next == BZ && !t.context && n.acceptToken($Z);
}, { contextual: !0 }), KZ = new Rn((n, t) => {
  let { next: e } = n;
  if (e == DZ || e == VZ) {
    if (n.advance(), e == n.next) {
      n.advance();
      let i = !t.context && t.canShift(vQ);
      n.acceptToken(i ? vQ : PZ);
    }
  } else e == jZ && n.peek(1) == LZ && (n.advance(), n.advance(), (n.next < 48 || n.next > 57) && n.acceptToken(RZ));
}, { contextual: !0 });
function nd(n, t) {
  return n >= 65 && n <= 90 || n >= 97 && n <= 122 || n == 95 || n >= 192 || !t && n >= 48 && n <= 57;
}
const JZ = new Rn((n, t) => {
  if (n.next != YZ || !t.dialectEnabled(XZ) || (n.advance(), n.next == ap)) return;
  let e = 0;
  for (; rp.indexOf(n.next) > -1; )
    n.advance(), e++;
  if (nd(n.next, !0)) {
    for (n.advance(), e++; nd(n.next, !1); )
      n.advance(), e++;
    for (; rp.indexOf(n.next) > -1; )
      n.advance(), e++;
    if (n.next == UZ) return;
    for (let i = 0; ; i++) {
      if (i == 7) {
        if (!nd(n.next, !0)) return;
        break;
      }
      if (n.next != "extends".charCodeAt(i)) break;
      n.advance(), e++;
    }
  }
  n.acceptToken(AZ, -e);
}), IZ = Cp({
  "get set async static": w.modifier,
  "for while do if else switch try catch finally return throw break continue default case": w.controlKeyword,
  "in of await yield void typeof delete instanceof as satisfies": w.operatorKeyword,
  "let var const using function class extends": w.definitionKeyword,
  "import export from": w.moduleKeyword,
  "with debugger new": w.keyword,
  TemplateString: w.special(w.string),
  super: w.atom,
  BooleanLiteral: w.bool,
  this: w.self,
  null: w.null,
  Star: w.modifier,
  VariableName: w.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": w.function(w.variableName),
  VariableDefinition: w.definition(w.variableName),
  Label: w.labelName,
  PropertyName: w.propertyName,
  PrivatePropertyName: w.special(w.propertyName),
  "CallExpression/MemberExpression/PropertyName": w.function(w.propertyName),
  "FunctionDeclaration/VariableDefinition": w.function(w.definition(w.variableName)),
  "ClassDeclaration/VariableDefinition": w.definition(w.className),
  "NewExpression/VariableName": w.className,
  PropertyDefinition: w.definition(w.propertyName),
  PrivatePropertyDefinition: w.definition(w.special(w.propertyName)),
  UpdateOp: w.updateOperator,
  "LineComment Hashbang": w.lineComment,
  BlockComment: w.blockComment,
  Number: w.number,
  String: w.string,
  Escape: w.escape,
  ArithOp: w.arithmeticOperator,
  LogicOp: w.logicOperator,
  BitOp: w.bitwiseOperator,
  CompareOp: w.compareOperator,
  RegExp: w.regexp,
  Equals: w.definitionOperator,
  Arrow: w.function(w.punctuation),
  ": Spread": w.punctuation,
  "( )": w.paren,
  "[ ]": w.squareBracket,
  "{ }": w.brace,
  "InterpolationStart InterpolationEnd": w.special(w.brace),
  ".": w.derefOperator,
  ", ;": w.separator,
  "@": w.meta,
  TypeName: w.typeName,
  TypeDefinition: w.definition(w.typeName),
  "type enum interface implements namespace module declare": w.definitionKeyword,
  "abstract global Privacy readonly override": w.modifier,
  "is keyof unique infer asserts": w.operatorKeyword,
  JSXAttributeValue: w.attributeValue,
  JSXText: w.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": w.angleBracket,
  "JSXIdentifier JSXNameSpacedName": w.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": w.attributeName,
  "JSXBuiltin/JSXIdentifier": w.standard(w.tagName)
}), FZ = { __proto__: null, export: 20, as: 25, from: 33, default: 36, async: 41, function: 42, in: 52, out: 55, const: 56, extends: 60, this: 64, true: 72, false: 72, null: 84, void: 88, typeof: 92, super: 108, new: 142, delete: 154, yield: 163, await: 167, class: 172, public: 235, private: 235, protected: 235, readonly: 237, instanceof: 256, satisfies: 259, import: 292, keyof: 349, unique: 353, infer: 359, asserts: 395, is: 397, abstract: 417, implements: 419, type: 421, let: 424, var: 426, using: 429, interface: 435, enum: 439, namespace: 445, module: 447, declare: 451, global: 455, for: 474, of: 483, while: 486, with: 490, do: 494, if: 498, else: 500, switch: 504, case: 510, try: 516, catch: 520, finally: 524, return: 528, throw: 532, break: 536, continue: 540, debugger: 544 }, tE = { __proto__: null, async: 129, get: 131, set: 133, declare: 195, public: 197, private: 197, protected: 197, static: 199, abstract: 201, override: 203, readonly: 209, accessor: 211, new: 401 }, eE = { __proto__: null, "<": 193 }, iE = Na.deserialize({
  version: 14,
  states: "$EOQ%TQlOOO%[QlOOO'_QpOOP(lO`OOO*zQ!0MxO'#CiO+RO#tO'#CjO+aO&jO'#CjO+oO#@ItO'#DaO.QQlO'#DgO.bQlO'#DrO%[QlO'#DzO0fQlO'#ESOOQ!0Lf'#E['#E[O1PQ`O'#EXOOQO'#Ep'#EpOOQO'#Ik'#IkO1XQ`O'#GsO1dQ`O'#EoO1iQ`O'#EoO3hQ!0MxO'#JqO6[Q!0MxO'#JrO6uQ`O'#F]O6zQ,UO'#FtOOQ!0Lf'#Ff'#FfO7VO7dO'#FfO7eQMhO'#F|O9[Q`O'#F{OOQ!0Lf'#Jr'#JrOOQ!0Lb'#Jq'#JqO9aQ`O'#GwOOQ['#K^'#K^O9lQ`O'#IXO9qQ!0LrO'#IYOOQ['#J_'#J_OOQ['#I^'#I^Q`QlOOQ`QlOOO9yQ!L^O'#DvO:QQlO'#EOO:XQlO'#EQO9gQ`O'#GsO:`QMhO'#CoO:nQ`O'#EnO:yQ`O'#EyO;OQMhO'#FeO;mQ`O'#GsOOQO'#K_'#K_O;rQ`O'#K_O<QQ`O'#G{O<QQ`O'#G|O<QQ`O'#HOO9gQ`O'#HRO<wQ`O'#HUO>`Q`O'#CeO>pQ`O'#HbO>xQ`O'#HhO>xQ`O'#HjO`QlO'#HlO>xQ`O'#HnO>xQ`O'#HqO>}Q`O'#HwO?SQ!0LsO'#H}O%[QlO'#IPO?_Q!0LsO'#IRO?jQ!0LsO'#ITO9qQ!0LrO'#IVO?uQ!0MxO'#CiO@wQpO'#DlQOQ`OOO%[QlO'#EQOA_Q`O'#ETO:`QMhO'#EnOAjQ`O'#EnOAuQ!bO'#FeOOQ['#Cg'#CgOOQ!0Lb'#Dq'#DqOOQ!0Lb'#Ju'#JuO%[QlO'#JuOOQO'#Jx'#JxOOQO'#Ig'#IgOBuQpO'#EgOOQ!0Lb'#Ef'#EfOOQ!0Lb'#J|'#J|OCqQ!0MSO'#EgOC{QpO'#EWOOQO'#Jw'#JwODaQpO'#JxOEnQpO'#EWOC{QpO'#EgPE{O&2DjO'#CbPOOO)CD|)CD|OOOO'#I_'#I_OFWO#tO,59UOOQ!0Lh,59U,59UOOOO'#I`'#I`OFfO&jO,59UOFtQ!L^O'#DcOOOO'#Ib'#IbOF{O#@ItO,59{OOQ!0Lf,59{,59{OGZQlO'#IcOGnQ`O'#JsOImQ!fO'#JsO+}QlO'#JsOItQ`O,5:ROJ[Q`O'#EpOJiQ`O'#KSOJtQ`O'#KROJtQ`O'#KROJ|Q`O,5;^OKRQ`O'#KQOOQ!0Ln,5:^,5:^OKYQlO,5:^OMWQ!0MxO,5:fOMwQ`O,5:nONbQ!0LrO'#KPONiQ`O'#KOO9aQ`O'#KOON}Q`O'#KOO! VQ`O,5;]O! [Q`O'#KOO!#aQ!fO'#JrOOQ!0Lh'#Ci'#CiO%[QlO'#ESO!$PQ!fO,5:sOOQS'#Jy'#JyOOQO-E<i-E<iO9gQ`O,5=_O!$gQ`O,5=_O!$lQlO,5;ZO!&oQMhO'#EkO!(YQ`O,5;ZO!(_QlO'#DyO!(iQpO,5;dO!(qQpO,5;dO%[QlO,5;dOOQ['#FT'#FTOOQ['#FV'#FVO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eOOQ['#FZ'#FZO!)PQlO,5;tOOQ!0Lf,5;y,5;yOOQ!0Lf,5;z,5;zOOQ!0Lf,5;|,5;|O%[QlO'#IoO!+SQ!0LrO,5<iO%[QlO,5;eO!&oQMhO,5;eO!+qQMhO,5;eO!-cQMhO'#E^O%[QlO,5;wOOQ!0Lf,5;{,5;{O!-jQ,UO'#FjO!.gQ,UO'#KWO!.RQ,UO'#KWO!.nQ,UO'#KWOOQO'#KW'#KWO!/SQ,UO,5<SOOOW,5<`,5<`O!/eQlO'#FvOOOW'#In'#InO7VO7dO,5<QO!/lQ,UO'#FxOOQ!0Lf,5<Q,5<QO!0]Q$IUO'#CyOOQ!0Lh'#C}'#C}O!0pO#@ItO'#DRO!1^QMjO,5<eO!1eQ`O,5<hO!3QQ(CWO'#GXO!3_Q`O'#GYO!3dQ`O'#GYO!5SQ(CWO'#G^O!6XQpO'#GbOOQO'#Gn'#GnO!+xQMhO'#GmOOQO'#Gp'#GpO!+xQMhO'#GoO!6zQ$IUO'#JkOOQ!0Lh'#Jk'#JkO!7UQ`O'#JjO!7dQ`O'#JiO!7lQ`O'#CuOOQ!0Lh'#C{'#C{O!7}Q`O'#C}OOQ!0Lh'#DV'#DVOOQ!0Lh'#DX'#DXO1SQ`O'#DZO!+xQMhO'#GPO!+xQMhO'#GRO!8SQ`O'#GTO!8XQ`O'#GUO!3dQ`O'#G[O!+xQMhO'#GaO<QQ`O'#JjO!8^Q`O'#EqO!8{Q`O,5<gOOQ!0Lb'#Cr'#CrO!9TQ`O'#ErO!9}QpO'#EsOOQ!0Lb'#KQ'#KQO!:UQ!0LrO'#K`O9qQ!0LrO,5=cO`QlO,5>sOOQ['#Jg'#JgOOQ[,5>t,5>tOOQ[-E<[-E<[O!<TQ!0MxO,5:bO!9xQpO,5:`O!>nQ!0MxO,5:jO%[QlO,5:jO!AUQ!0MxO,5:lOOQO,5@y,5@yO!AuQMhO,5=_O!BTQ!0LrO'#JhO9[Q`O'#JhO!BfQ!0LrO,59ZO!BqQpO,59ZO!ByQMhO,59ZO:`QMhO,59ZO!CUQ`O,5;ZO!C^Q`O'#HaO!CrQ`O'#KcO%[QlO,5;}O!9xQpO,5<PO!CzQ`O,5=zO!DPQ`O,5=zO!DUQ`O,5=zO9qQ!0LrO,5=zO<QQ`O,5=jOOQO'#Cy'#CyO!DdQpO,5=gO!DlQMhO,5=hO!DwQ`O,5=jO!D|Q!bO,5=mO!EUQ`O'#K_O>}Q`O'#HWO9gQ`O'#HYO!EZQ`O'#HYO:`QMhO'#H[O!E`Q`O'#H[OOQ[,5=p,5=pO!EeQ`O'#H]O!EvQ`O'#CoO!E{Q`O,59PO!FVQ`O,59PO!H[QlO,59POOQ[,59P,59PO!HlQ!0LrO,59PO%[QlO,59PO!JwQlO'#HdOOQ['#He'#HeOOQ['#Hf'#HfO`QlO,5=|O!K_Q`O,5=|O`QlO,5>SO`QlO,5>UO!KdQ`O,5>WO`QlO,5>YO!KiQ`O,5>]O!KnQlO,5>cOOQ[,5>i,5>iO%[QlO,5>iO9qQ!0LrO,5>kOOQ[,5>m,5>mO# xQ`O,5>mOOQ[,5>o,5>oO# xQ`O,5>oOOQ[,5>q,5>qO#!fQpO'#D_O%[QlO'#JuO##XQpO'#JuO##cQpO'#DmO##tQpO'#DmO#&VQlO'#DmO#&^Q`O'#JtO#&fQ`O,5:WO#&kQ`O'#EtO#&yQ`O'#KTO#'RQ`O,5;_O#'WQpO'#DmO#'eQpO'#EVOOQ!0Lf,5:o,5:oO%[QlO,5:oO#'lQ`O,5:oO>}Q`O,5;YO!BqQpO,5;YO!ByQMhO,5;YO:`QMhO,5;YO#'tQ`O,5@aO#'yQ07dO,5:sOOQO-E<e-E<eO#)PQ!0MSO,5;ROC{QpO,5:rO#)ZQpO,5:rOC{QpO,5;RO!BfQ!0LrO,5:rOOQ!0Lb'#Ej'#EjOOQO,5;R,5;RO%[QlO,5;RO#)hQ!0LrO,5;RO#)sQ!0LrO,5;RO!BqQpO,5:rOOQO,5;X,5;XO#*RQ!0LrO,5;RPOOO'#I]'#I]P#*gO&2DjO,58|POOO,58|,58|OOOO-E<]-E<]OOQ!0Lh1G.p1G.pOOOO-E<^-E<^OOOO,59},59}O#*rQ!bO,59}OOOO-E<`-E<`OOQ!0Lf1G/g1G/gO#*wQ!fO,5>}O+}QlO,5>}OOQO,5?T,5?TO#+RQlO'#IcOOQO-E<a-E<aO#+`Q`O,5@_O#+hQ!fO,5@_O#+oQ`O,5@mOOQ!0Lf1G/m1G/mO%[QlO,5@nO#+wQ`O'#IiOOQO-E<g-E<gO#+oQ`O,5@mOOQ!0Lb1G0x1G0xOOQ!0Ln1G/x1G/xOOQ!0Ln1G0Y1G0YO%[QlO,5@kO#,]Q!0LrO,5@kO#,nQ!0LrO,5@kO#,uQ`O,5@jO9aQ`O,5@jO#,}Q`O,5@jO#-]Q`O'#IlO#,uQ`O,5@jOOQ!0Lb1G0w1G0wO!(iQpO,5:uO!(tQpO,5:uOOQS,5:w,5:wO#-}QdO,5:wO#.VQMhO1G2yO9gQ`O1G2yOOQ!0Lf1G0u1G0uO#.eQ!0MxO1G0uO#/jQ!0MvO,5;VOOQ!0Lh'#GW'#GWO#0WQ!0MzO'#JkO!$lQlO1G0uO#2cQ!fO'#JvO%[QlO'#JvO#2mQ`O,5:eOOQ!0Lh'#D_'#D_OOQ!0Lf1G1O1G1OO%[QlO1G1OOOQ!0Lf1G1f1G1fO#2rQ`O1G1OO#5WQ!0MxO1G1PO#5_Q!0MxO1G1PO#7uQ!0MxO1G1PO#7|Q!0MxO1G1PO#:dQ!0MxO1G1PO#<zQ!0MxO1G1PO#=RQ!0MxO1G1PO#=YQ!0MxO1G1PO#?pQ!0MxO1G1PO#?wQ!0MxO1G1PO#BUQ?MtO'#CiO#DPQ?MtO1G1`O#DWQ?MtO'#JrO#DkQ!0MxO,5?ZOOQ!0Lb-E<m-E<mO#FxQ!0MxO1G1PO#GuQ!0MzO1G1POOQ!0Lf1G1P1G1PO#HxQMjO'#J{O#ISQ`O,5:xO#IXQ!0MxO1G1cO#I{Q,UO,5<WO#JTQ,UO,5<XO#J]Q,UO'#FoO#JtQ`O'#FnOOQO'#KX'#KXOOQO'#Im'#ImO#JyQ,UO1G1nOOQ!0Lf1G1n1G1nOOOW1G1y1G1yO#K[Q?MtO'#JqO#KfQ`O,5<bO!)PQlO,5<bOOOW-E<l-E<lOOQ!0Lf1G1l1G1lO#KkQpO'#KWOOQ!0Lf,5<d,5<dO#KsQpO,5<dO#KxQMhO'#DTOOOO'#Ia'#IaO#LPO#@ItO,59mOOQ!0Lh,59m,59mO%[QlO1G2PO!8XQ`O'#IqO#L[Q`O,5<zOOQ!0Lh,5<w,5<wO!+xQMhO'#ItO#LxQMjO,5=XO!+xQMhO'#IvO#MkQMjO,5=ZO!&oQMhO,5=]OOQO1G2S1G2SO#MuQ!dO'#CrO#NYQ(CWO'#ErO$ _QpO'#GbO$ uQ!dO,5<sO$ |Q`O'#KZO9aQ`O'#KZO$![Q`O,5<uO!+xQMhO,5<tO$!aQ`O'#GZO$!rQ`O,5<tO$!wQ!dO'#GWO$#UQ!dO'#K[O$#`Q`O'#K[O!&oQMhO'#K[O$#eQ`O,5<xO$#jQlO'#JuO$#tQpO'#GcO##tQpO'#GcO$$VQ`O'#GgO!3dQ`O'#GkO$$[Q!0LrO'#IsO$$gQpO,5<|OOQ!0Lp,5<|,5<|O$$nQpO'#GcO$${QpO'#GdO$%^QpO'#GdO$%cQMjO,5=XO$%sQMjO,5=ZOOQ!0Lh,5=^,5=^O!+xQMhO,5@UO!+xQMhO,5@UO$&TQ`O'#IxO$&iQ`O,5@TO$&qQ`O,59aOOQ!0Lh,59i,59iO$'hQ$IYO,59uOOQ!0Lh'#Jo'#JoO$(ZQMjO,5<kO$(|QMjO,5<mO@oQ`O,5<oOOQ!0Lh,5<p,5<pO$)WQ`O,5<vO$)]QMjO,5<{O$)mQ`O,5@UO$){Q`O'#KOO!$lQlO1G2RO$*QQ`O1G2RO9aQ`O'#KRO9aQ`O'#EtO%[QlO'#EtO9aQ`O'#IzO$*VQ!0LrO,5@zOOQ[1G2}1G2}OOQ[1G4_1G4_OOQ!0Lf1G/|1G/|OOQ!0Lf1G/z1G/zO$,XQ!0MxO1G0UOOQ[1G2y1G2yO!&oQMhO1G2yO%[QlO1G2yO#.YQ`O1G2yO$.]QMhO'#EkOOQ!0Lb,5@S,5@SO$.jQ!0LrO,5@SOOQ[1G.u1G.uO!BfQ!0LrO1G.uO!BqQpO1G.uO!ByQMhO1G.uO$.{Q`O1G0uO$/QQ`O'#CiO$/]Q`O'#KdO$/eQ`O,5={O$/jQ`O'#KdO$/oQ`O'#KdO$/}Q`O'#JQO$0]Q`O,5@}O$0eQ!fO1G1iOOQ!0Lf1G1k1G1kO9gQ`O1G3fO@oQ`O1G3fO$0lQ`O1G3fO$0qQ`O1G3fOOQ[1G3f1G3fO!DwQ`O1G3UO!&oQMhO1G3RO$0vQ`O1G3ROOQ[1G3S1G3SO!&oQMhO1G3SO$0{Q`O1G3SO$1TQpO'#HQOOQ[1G3U1G3UO!6SQpO'#I|O!D|Q!bO1G3XOOQ[1G3X1G3XOOQ[,5=r,5=rO$1]QMhO,5=tO9gQ`O,5=tO$$VQ`O,5=vO9[Q`O,5=vO!BqQpO,5=vO!ByQMhO,5=vO:`QMhO,5=vO$1kQ`O'#KbO$1vQ`O,5=wOOQ[1G.k1G.kO$1{Q!0LrO1G.kO@oQ`O1G.kO$2WQ`O1G.kO9qQ!0LrO1G.kO$4`Q!fO,5APO$4mQ`O,5APO9aQ`O,5APO$4xQlO,5>OO$5PQ`O,5>OOOQ[1G3h1G3hO`QlO1G3hOOQ[1G3n1G3nOOQ[1G3p1G3pO>xQ`O1G3rO$5UQlO1G3tO$9YQlO'#HsOOQ[1G3w1G3wO$9gQ`O'#HyO>}Q`O'#H{OOQ[1G3}1G3}O$9oQlO1G3}O9qQ!0LrO1G4TOOQ[1G4V1G4VOOQ!0Lb'#G_'#G_O9qQ!0LrO1G4XO9qQ!0LrO1G4ZO$=vQ`O,5@aO!)PQlO,5;`O9aQ`O,5;`O>}Q`O,5:XO!)PQlO,5:XO!BqQpO,5:XO$={Q?MtO,5:XOOQO,5;`,5;`O$>VQpO'#IdO$>mQ`O,5@`OOQ!0Lf1G/r1G/rO$>uQpO'#IjO$?PQ`O,5@oOOQ!0Lb1G0y1G0yO##tQpO,5:XOOQO'#If'#IfO$?XQpO,5:qOOQ!0Ln,5:q,5:qO#'oQ`O1G0ZOOQ!0Lf1G0Z1G0ZO%[QlO1G0ZOOQ!0Lf1G0t1G0tO>}Q`O1G0tO!BqQpO1G0tO!ByQMhO1G0tOOQ!0Lb1G5{1G5{O!BfQ!0LrO1G0^OOQO1G0m1G0mO%[QlO1G0mO$?`Q!0LrO1G0mO$?kQ!0LrO1G0mO!BqQpO1G0^OC{QpO1G0^O$?yQ!0LrO1G0mOOQO1G0^1G0^O$@_Q!0MxO1G0mPOOO-E<Z-E<ZPOOO1G.h1G.hOOOO1G/i1G/iO$@iQ!bO,5<iO$@qQ!fO1G4iOOQO1G4o1G4oO%[QlO,5>}O$@{Q`O1G5yO$ATQ`O1G6XO$A]Q!fO1G6YO9aQ`O,5?TO$AgQ!0MxO1G6VO%[QlO1G6VO$AwQ!0LrO1G6VO$BYQ`O1G6UO$BYQ`O1G6UO9aQ`O1G6UO$BbQ`O,5?WO9aQ`O,5?WOOQO,5?W,5?WO$BvQ`O,5?WO$){Q`O,5?WOOQO-E<j-E<jOOQS1G0a1G0aOOQS1G0c1G0cO#.QQ`O1G0cOOQ[7+(e7+(eO!&oQMhO7+(eO%[QlO7+(eO$CUQ`O7+(eO$CaQMhO7+(eO$CoQ!0MzO,5=XO$EzQ!0MzO,5=ZO$HVQ!0MzO,5=XO$JhQ!0MzO,5=ZO$LyQ!0MzO,59uO% OQ!0MzO,5<kO%#ZQ!0MzO,5<mO%%fQ!0MzO,5<{OOQ!0Lf7+&a7+&aO%'wQ!0MxO7+&aO%(kQlO'#IeO%(xQ`O,5@bO%)QQ!fO,5@bOOQ!0Lf1G0P1G0PO%)[Q`O7+&jOOQ!0Lf7+&j7+&jO%)aQ?MtO,5:fO%[QlO7+&zO%)kQ?MtO,5:bO%)xQ?MtO,5:jO%*SQ?MtO,5:lO%*^QMhO'#IhO%*hQ`O,5@gOOQ!0Lh1G0d1G0dOOQO1G1r1G1rOOQO1G1s1G1sO%*pQ!jO,5<ZO!)PQlO,5<YOOQO-E<k-E<kOOQ!0Lf7+'Y7+'YOOOW7+'e7+'eOOOW1G1|1G1|O%*{Q`O1G1|OOQ!0Lf1G2O1G2OOOOO,59o,59oO%+QQ!dO,59oOOOO-E<_-E<_OOQ!0Lh1G/X1G/XO%+XQ!0MxO7+'kOOQ!0Lh,5?],5?]O%+{QMhO1G2fP%,SQ`O'#IqPOQ!0Lh-E<o-E<oO%,pQMjO,5?`OOQ!0Lh-E<r-E<rO%-cQMjO,5?bOOQ!0Lh-E<t-E<tO%-mQ!dO1G2wO%-tQ!dO'#CrO%.[QMhO'#KRO$#jQlO'#JuOOQ!0Lh1G2_1G2_O%.cQ`O'#IpO%.wQ`O,5@uO%.wQ`O,5@uO%/PQ`O,5@uO%/[Q`O,5@uOOQO1G2a1G2aO%/jQMjO1G2`O!+xQMhO1G2`O%/zQ(CWO'#IrO%0XQ`O,5@vO!&oQMhO,5@vO%0aQ!dO,5@vOOQ!0Lh1G2d1G2dO%2qQ!fO'#CiO%2{Q`O,5=POOQ!0Lb,5<},5<}O%3TQpO,5<}OOQ!0Lb,5=O,5=OOClQ`O,5<}O%3`QpO,5<}OOQ!0Lb,5=R,5=RO$){Q`O,5=VOOQO,5?_,5?_OOQO-E<q-E<qOOQ!0Lp1G2h1G2hO##tQpO,5<}O$#jQlO,5=PO%3nQ`O,5=OO%3yQpO,5=OO!+xQMhO'#ItO%4sQMjO1G2sO!+xQMhO'#IvO%5fQMjO1G2uO%5pQMjO1G5pO%5zQMjO1G5pOOQO,5?d,5?dOOQO-E<v-E<vOOQO1G.{1G.{O!9xQpO,59wO%[QlO,59wOOQ!0Lh,5<j,5<jO%6XQ`O1G2ZO!+xQMhO1G2bO!+xQMhO1G5pO!+xQMhO1G5pO%6^Q!0MxO7+'mOOQ!0Lf7+'m7+'mO!$lQlO7+'mO%7QQ`O,5;`OOQ!0Lb,5?f,5?fOOQ!0Lb-E<x-E<xO%7VQ!dO'#K]O#'oQ`O7+(eO4UQ!fO7+(eO$CXQ`O7+(eO%7aQ!0MvO'#CiO%7tQ!0MvO,5=SO%8fQ`O,5=SO%8nQ`O,5=SOOQ!0Lb1G5n1G5nOOQ[7+$a7+$aO!BfQ!0LrO7+$aO!BqQpO7+$aO!$lQlO7+&aO%8sQ`O'#JPO%9[Q`O,5AOOOQO1G3g1G3gO9gQ`O,5AOO%9[Q`O,5AOO%9dQ`O,5AOOOQO,5?l,5?lOOQO-E=O-E=OOOQ!0Lf7+'T7+'TO%9iQ`O7+)QO9qQ!0LrO7+)QO9gQ`O7+)QO@oQ`O7+)QOOQ[7+(p7+(pO%9nQ!0MvO7+(mO!&oQMhO7+(mO!DrQ`O7+(nOOQ[7+(n7+(nO!&oQMhO7+(nO%9xQ`O'#KaO%:TQ`O,5=lOOQO,5?h,5?hOOQO-E<z-E<zOOQ[7+(s7+(sO%;gQpO'#HZOOQ[1G3`1G3`O!&oQMhO1G3`O%[QlO1G3`O%;nQ`O1G3`O%;yQMhO1G3`O9qQ!0LrO1G3bO$$VQ`O1G3bO9[Q`O1G3bO!BqQpO1G3bO!ByQMhO1G3bO%<XQ`O'#JOO%<mQ`O,5@|O%<uQpO,5@|OOQ!0Lb1G3c1G3cOOQ[7+$V7+$VO@oQ`O7+$VO9qQ!0LrO7+$VO%=QQ`O7+$VO%[QlO1G6kO%[QlO1G6lO%=VQ!0LrO1G6kO%=aQlO1G3jO%=hQ`O1G3jO%=mQlO1G3jOOQ[7+)S7+)SO9qQ!0LrO7+)^O`QlO7+)`OOQ['#Kg'#KgOOQ['#JR'#JRO%=tQlO,5>_OOQ[,5>_,5>_O%[QlO'#HtO%>RQ`O'#HvOOQ[,5>e,5>eO9aQ`O,5>eOOQ[,5>g,5>gOOQ[7+)i7+)iOOQ[7+)o7+)oOOQ[7+)s7+)sOOQ[7+)u7+)uO%>WQpO1G5{O%>rQ?MtO1G0zO%>|Q`O1G0zOOQO1G/s1G/sO%?XQ?MtO1G/sO>}Q`O1G/sO!)PQlO'#DmOOQO,5?O,5?OOOQO-E<b-E<bOOQO,5?U,5?UOOQO-E<h-E<hO!BqQpO1G/sOOQO-E<d-E<dOOQ!0Ln1G0]1G0]OOQ!0Lf7+%u7+%uO#'oQ`O7+%uOOQ!0Lf7+&`7+&`O>}Q`O7+&`O!BqQpO7+&`OOQO7+%x7+%xO$@_Q!0MxO7+&XOOQO7+&X7+&XO%[QlO7+&XO%?cQ!0LrO7+&XO!BfQ!0LrO7+%xO!BqQpO7+%xO%?nQ!0LrO7+&XO%?|Q!0MxO7++qO%[QlO7++qO%@^Q`O7++pO%@^Q`O7++pOOQO1G4r1G4rO9aQ`O1G4rO%@fQ`O1G4rOOQS7+%}7+%}O#'oQ`O<<LPO4UQ!fO<<LPO%@tQ`O<<LPOOQ[<<LP<<LPO!&oQMhO<<LPO%[QlO<<LPO%@|Q`O<<LPO%AXQ!0MzO,5?`O%CdQ!0MzO,5?bO%EoQ!0MzO1G2`O%HQQ!0MzO1G2sO%J]Q!0MzO1G2uO%LhQ!fO,5?PO%[QlO,5?POOQO-E<c-E<cO%LrQ`O1G5|OOQ!0Lf<<JU<<JUO%LzQ?MtO1G0uO& RQ?MtO1G1PO& YQ?MtO1G1PO&#ZQ?MtO1G1PO&#bQ?MtO1G1PO&%cQ?MtO1G1PO&'dQ?MtO1G1PO&'kQ?MtO1G1PO&'rQ?MtO1G1PO&)sQ?MtO1G1PO&)zQ?MtO1G1PO&*RQ!0MxO<<JfO&+yQ?MtO1G1PO&,vQ?MvO1G1PO&-yQ?MvO'#JkO&0PQ?MtO1G1cO&0^Q?MtO1G0UO&0hQMjO,5?SOOQO-E<f-E<fO!)PQlO'#FqOOQO'#KY'#KYOOQO1G1u1G1uO&0rQ`O1G1tO&0wQ?MtO,5?ZOOOW7+'h7+'hOOOO1G/Z1G/ZO&1RQ!dO1G4wOOQ!0Lh7+(Q7+(QP!&oQMhO,5?]O!+xQMhO7+(cO&1YQ`O,5?[O9aQ`O,5?[OOQO-E<n-E<nO&1hQ`O1G6aO&1hQ`O1G6aO&1pQ`O1G6aO&1{QMjO7+'zO&2]Q!dO,5?^O&2gQ`O,5?^O!&oQMhO,5?^OOQO-E<p-E<pO&2lQ!dO1G6bO&2vQ`O1G6bO&3OQ`O1G2kO!&oQMhO1G2kOOQ!0Lb1G2i1G2iOOQ!0Lb1G2j1G2jO%3TQpO1G2iO!BqQpO1G2iOClQ`O1G2iOOQ!0Lb1G2q1G2qO&3TQpO1G2iO&3cQ`O1G2kO$){Q`O1G2jOClQ`O1G2jO$#jQlO1G2kO&3kQ`O1G2jO&4_QMjO,5?`OOQ!0Lh-E<s-E<sO&5QQMjO,5?bOOQ!0Lh-E<u-E<uO!+xQMhO7++[OOQ!0Lh1G/c1G/cO&5[Q`O1G/cOOQ!0Lh7+'u7+'uO&5aQMjO7+'|O&5qQMjO7++[O&5{QMjO7++[O&6YQ!0MxO<<KXOOQ!0Lf<<KX<<KXO&6|Q`O1G0zO!&oQMhO'#IyO&7RQ`O,5@wO&9TQ!fO<<LPO!&oQMhO1G2nO&9[Q!0LrO1G2nOOQ[<<G{<<G{O!BfQ!0LrO<<G{O&9mQ!0MxO<<I{OOQ!0Lf<<I{<<I{OOQO,5?k,5?kO&:aQ`O,5?kO&:fQ`O,5?kOOQO-E<}-E<}O&:tQ`O1G6jO&:tQ`O1G6jO9gQ`O1G6jO@oQ`O<<LlOOQ[<<Ll<<LlO&:|Q`O<<LlO9qQ!0LrO<<LlOOQ[<<LX<<LXO%9nQ!0MvO<<LXOOQ[<<LY<<LYO!DrQ`O<<LYO&;RQpO'#I{O&;^Q`O,5@{O!)PQlO,5@{OOQ[1G3W1G3WOOQO'#I}'#I}O9qQ!0LrO'#I}O&;fQpO,5=uOOQ[,5=u,5=uO&;mQpO'#EgO&;tQpO'#GeO&;yQ`O7+(zO&<OQ`O7+(zOOQ[7+(z7+(zO!&oQMhO7+(zO%[QlO7+(zO&<WQ`O7+(zOOQ[7+(|7+(|O9qQ!0LrO7+(|O$$VQ`O7+(|O9[Q`O7+(|O!BqQpO7+(|O&<cQ`O,5?jOOQO-E<|-E<|OOQO'#H^'#H^O&<nQ`O1G6hO9qQ!0LrO<<GqOOQ[<<Gq<<GqO@oQ`O<<GqO&<vQ`O7+,VO&<{Q`O7+,WO%[QlO7+,VO%[QlO7+,WOOQ[7+)U7+)UO&=QQ`O7+)UO&=VQlO7+)UO&=^Q`O7+)UOOQ[<<Lx<<LxOOQ[<<Lz<<LzOOQ[-E=P-E=POOQ[1G3y1G3yO&=cQ`O,5>`OOQ[,5>b,5>bO&=hQ`O1G4PO9aQ`O7+&fO!)PQlO7+&fOOQO7+%_7+%_O&=mQ?MtO1G6YO>}Q`O7+%_OOQ!0Lf<<Ia<<IaOOQ!0Lf<<Iz<<IzO>}Q`O<<IzOOQO<<Is<<IsO$@_Q!0MxO<<IsO%[QlO<<IsOOQO<<Id<<IdO!BfQ!0LrO<<IdO&=wQ!0LrO<<IsO&>SQ!0MxO<= ]O&>dQ`O<= [OOQO7+*^7+*^O9aQ`O7+*^OOQ[ANAkANAkO&>lQ!fOANAkO!&oQMhOANAkO#'oQ`OANAkO4UQ!fOANAkO&>sQ`OANAkO%[QlOANAkO&>{Q!0MzO7+'zO&A^Q!0MzO,5?`O&CiQ!0MzO,5?bO&EtQ!0MzO7+'|O&HVQ!fO1G4kO&HaQ?MtO7+&aO&JeQ?MvO,5=XO&LlQ?MvO,5=ZO&L|Q?MvO,5=XO&M^Q?MvO,5=ZO&MnQ?MvO,59uO' tQ?MvO,5<kO'#wQ?MvO,5<mO'&]Q?MvO,5<{O'(RQ?MtO7+'kO'(`Q?MtO7+'mO'(mQ`O,5<]OOQO7+'`7+'`OOQ!0Lh7+*c7+*cO'(rQMjO<<K}OOQO1G4v1G4vO'(yQ`O1G4vO')UQ`O1G4vO')dQ`O7++{O')dQ`O7++{O!&oQMhO1G4xO')lQ!dO1G4xO')vQ`O7++|O'*OQ`O7+(VO'*ZQ!dO7+(VOOQ!0Lb7+(T7+(TOOQ!0Lb7+(U7+(UO!BqQpO7+(TOClQ`O7+(TO'*eQ`O7+(VO!&oQMhO7+(VO$){Q`O7+(UO'*jQ`O7+(VOClQ`O7+(UO'*rQMjO<<NvOOQ!0Lh7+$}7+$}O!+xQMhO<<NvO'*|Q!dO,5?eOOQO-E<w-E<wO'+WQ!0MvO7+(YO!&oQMhO7+(YOOQ[AN=gAN=gO9gQ`O1G5VOOQO1G5V1G5VO'+hQ`O1G5VO'+mQ`O7+,UO'+mQ`O7+,UO9qQ!0LrOANBWO@oQ`OANBWOOQ[ANBWANBWOOQ[ANAsANAsOOQ[ANAtANAtO'+uQ`O,5?gOOQO-E<y-E<yO',QQ?MtO1G6gOOQO,5?i,5?iOOQO-E<{-E<{OOQ[1G3a1G3aO',[Q`O,5=POOQ[<<Lf<<LfO!&oQMhO<<LfO&;yQ`O<<LfO',aQ`O<<LfO%[QlO<<LfOOQ[<<Lh<<LhO9qQ!0LrO<<LhO$$VQ`O<<LhO9[Q`O<<LhO',iQpO1G5UO',tQ`O7+,SOOQ[AN=]AN=]O9qQ!0LrOAN=]OOQ[<= q<= qOOQ[<= r<= rO',|Q`O<= qO'-RQ`O<= rOOQ[<<Lp<<LpO'-WQ`O<<LpO'-]QlO<<LpOOQ[1G3z1G3zO>}Q`O7+)kO'-dQ`O<<JQO'-oQ?MtO<<JQOOQO<<Hy<<HyOOQ!0LfAN?fAN?fOOQOAN?_AN?_O$@_Q!0MxOAN?_OOQOAN?OAN?OO%[QlOAN?_OOQO<<Mx<<MxOOQ[G27VG27VO!&oQMhOG27VO#'oQ`OG27VO'-yQ!fOG27VO4UQ!fOG27VO'.QQ`OG27VO'.YQ?MtO<<JfO'.gQ?MvO1G2`O'0]Q?MvO,5?`O'2`Q?MvO,5?bO'4cQ?MvO1G2sO'6fQ?MvO1G2uO'8iQ?MtO<<KXO'8vQ?MtO<<I{OOQO1G1w1G1wO!+xQMhOANAiOOQO7+*b7+*bO'9TQ`O7+*bO'9`Q`O<= gO'9hQ!dO7+*dOOQ!0Lb<<Kq<<KqO$){Q`O<<KqOClQ`O<<KqO'9rQ`O<<KqO!&oQMhO<<KqOOQ!0Lb<<Ko<<KoO!BqQpO<<KoO'9}Q!dO<<KqOOQ!0Lb<<Kp<<KpO':XQ`O<<KqO!&oQMhO<<KqO$){Q`O<<KpO':^QMjOANDbO':hQ!0MvO<<KtOOQO7+*q7+*qO9gQ`O7+*qO':xQ`O<= pOOQ[G27rG27rO9qQ!0LrOG27rO!)PQlO1G5RO';QQ`O7+,RO';YQ`O1G2kO&;yQ`OANBQOOQ[ANBQANBQO!&oQMhOANBQO';_Q`OANBQOOQ[ANBSANBSO9qQ!0LrOANBSO$$VQ`OANBSOOQO'#H_'#H_OOQO7+*p7+*pOOQ[G22wG22wOOQ[ANE]ANE]OOQ[ANE^ANE^OOQ[ANB[ANB[O';gQ`OANB[OOQ[<<MV<<MVO!)PQlOAN?lOOQOG24yG24yO$@_Q!0MxOG24yO#'oQ`OLD,qOOQ[LD,qLD,qO!&oQMhOLD,qO';lQ!fOLD,qO';sQ?MvO7+'zO'=iQ?MvO,5?`O'?lQ?MvO,5?bO'AoQ?MvO7+'|O'CeQMjOG27TOOQO<<M|<<M|OOQ!0LbANA]ANA]O$){Q`OANA]OClQ`OANA]O'CuQ!dOANA]OOQ!0LbANAZANAZO'C|Q`OANA]O!&oQMhOANA]O'DXQ!dOANA]OOQ!0LbANA[ANA[OOQO<<N]<<N]OOQ[LD-^LD-^O'DcQ?MtO7+*mOOQO'#Gf'#GfOOQ[G27lG27lO&;yQ`OG27lO!&oQMhOG27lOOQ[G27nG27nO9qQ!0LrOG27nOOQ[G27vG27vO'DmQ?MtOG25WOOQOLD*eLD*eOOQ[!$(!]!$(!]O#'oQ`O!$(!]O!&oQMhO!$(!]O'DwQ!0MzOG27TOOQ!0LbG26wG26wO$){Q`OG26wO'GYQ`OG26wOClQ`OG26wO'GeQ!dOG26wO!&oQMhOG26wOOQ[LD-WLD-WO&;yQ`OLD-WOOQ[LD-YLD-YOOQ[!)9Ew!)9EwO#'oQ`O!)9EwOOQ!0LbLD,cLD,cO$){Q`OLD,cOClQ`OLD,cO'GlQ`OLD,cO'GwQ!dOLD,cOOQ[!$(!r!$(!rOOQ[!.K;c!.K;cO'HOQ?MvOG27TOOQ!0Lb!$( }!$( }O$){Q`O!$( }OClQ`O!$( }O'ItQ`O!$( }OOQ!0Lb!)9Ei!)9EiO$){Q`O!)9EiOClQ`O!)9EiOOQ!0Lb!.K;T!.K;TO$){Q`O!.K;TOOQ!0Lb!4/0o!4/0oO!)PQlO'#DzO1PQ`O'#EXO'JPQ!fO'#JqO'JWQ!L^O'#DvO'J_QlO'#EOO'JfQ!fO'#CiO'L|Q!fO'#CiO!)PQlO'#EQO'M^QlO,5;ZO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO'#IoO( aQ`O,5<iO!)PQlO,5;eO( iQMhO,5;eO(#SQMhO,5;eO!)PQlO,5;wO!&oQMhO'#GmO( iQMhO'#GmO!&oQMhO'#GoO( iQMhO'#GoO1SQ`O'#DZO1SQ`O'#DZO!&oQMhO'#GPO( iQMhO'#GPO!&oQMhO'#GRO( iQMhO'#GRO!&oQMhO'#GaO( iQMhO'#GaO!)PQlO,5:jO(#ZQpO'#D_O(#eQpO'#JuO!)PQlO,5@nO'M^QlO1G0uO(#oQ?MtO'#CiO!)PQlO1G2PO!&oQMhO'#ItO( iQMhO'#ItO!&oQMhO'#IvO( iQMhO'#IvO(#yQ!dO'#CrO!&oQMhO,5<tO( iQMhO,5<tO'M^QlO1G2RO!)PQlO7+&zO!&oQMhO1G2`O( iQMhO1G2`O!&oQMhO'#ItO( iQMhO'#ItO!&oQMhO'#IvO( iQMhO'#IvO!&oQMhO1G2bO( iQMhO1G2bO'M^QlO7+'mO'M^QlO7+&aO!&oQMhOANAiO( iQMhOANAiO($^Q`O'#EoO($cQ`O'#EoO($kQ`O'#F]O($pQ`O'#EyO($uQ`O'#KSO(%QQ`O'#KQO(%]Q`O,5;ZO(%bQMjO,5<eO(%iQ`O'#GYO(%nQ`O'#GYO(%sQ`O,5<gO(%{Q`O,5;ZO(&TQ?MtO1G1`O(&[Q`O,5<tO(&aQ`O,5<tO(&fQ`O,5<vO(&kQ`O,5<vO(&pQ`O1G2RO(&uQ`O1G0uO(&zQMjO<<K}O('RQMjO<<K}O7eQMhO'#F|O9[Q`O'#F{OAjQ`O'#EnO!)PQlO,5;tO!3dQ`O'#GYO!3dQ`O'#GYO!3dQ`O'#G[O!3dQ`O'#G[O!+xQMhO7+(cO!+xQMhO7+(cO%-mQ!dO1G2wO%-mQ!dO1G2wO!&oQMhO,5=]O!&oQMhO,5=]",
  stateData: "((X~O'{OS'|OSTOS'}RQ~OPYOQYOSfOY!VOaqOdzOeyOl!POpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!uwO!xxO!|]O$W|O$niO%h}O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO&V!WO&]!XO&_!YO&a!ZO&c![O&f!]O&l!^O&r!_O&t!`O&v!aO&x!bO&z!cO(SSO(UTO(XUO(`VO(n[O~OWtO~P`OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(S!dO(UTO(XUO(`VO(n[O~Oa!wOs!nO!S!oO!b!yO!c!vO!d!vO!|;wO#T!pO#U!pO#V!xO#W!pO#X!pO#[!zO#]!zO(T!lO(UTO(XUO(d!mO(n!sO~O'}!{O~OP]XR]X[]Xa]Xj]Xr]X!Q]X!S]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X'y]X(`]X(q]X(x]X(y]X~O!g%RX~P(qO_!}O(U#PO(V!}O(W#PO~O_#QO(W#PO(X#PO(Y#QO~Ox#SO!U#TO(a#TO(b#VO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(S;{O(UTO(XUO(`VO(n[O~O![#ZO!]#WO!Y(gP!Y(uP~P+}O!^#cO~P`OPYOQYOSfOd!jOe!iOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(UTO(XUO(`VO(n[O~Op#mO![#iO!|]O#i#lO#j#iO(S;|O!k(rP~P.iO!l#oO(S#nO~O!x#sO!|]O%h#tO~O#k#uO~O!g#vO#k#uO~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!]$_O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(`VO(q$YO(x#|O(y#}O~Oa(eX'y(eX'v(eX!k(eX!Y(eX!_(eX%i(eX!g(eX~P1qO#S$dO#`$eO$Q$eOP(fXR(fX[(fXj(fXr(fX!Q(fX!S(fX!](fX!l(fX!p(fX#R(fX#n(fX#o(fX#p(fX#q(fX#r(fX#s(fX#t(fX#u(fX#v(fX#x(fX#z(fX#{(fX(`(fX(q(fX(x(fX(y(fX!_(fX%i(fX~Oa(fX'y(fX'v(fX!Y(fX!k(fXv(fX!g(fX~P4UO#`$eO~O$]$hO$_$gO$f$mO~OSfO!_$nO$i$oO$k$qO~Oh%VOj%cOk%cOl%cOp%WOr%XOs$tOt$tOz%YO|%ZO!O%[O!S${O!_$|O!i%aO!l$xO#j%bO$W%_O$t%]O$v%^O$y%`O(S$sO(UTO(XUO(`$uO(x$}O(y%POg(]P~O!l%dO~O!S%gO!_%hO(S%fO~O!g%lO~Oa%mO'y%mO~O!Q%qO~P%[O(T!lO~P%[O%n%uO~P%[Oh%VO!l%dO(S%fO(T!lO~Oe%|O!l%dO(S%fO~Oj$RO~O!Q&RO!_&OO!l&QO%j&UO(S%fO(T!lO(UTO(XUO`)VP~O!x#sO~O%s&WO!S)RX!_)RX(S)RX~O(S&XO~Ol!PO!u&^O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO~Od&cOe&bO!x&`O%h&aO%{&_O~P<VOd&fOeyOl!PO!_&eO!u&^O!xxO!|]O%h}O%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO~Ob&iO#`&lO%j&gO(T!lO~P=[O!l&mO!u&qO~O!l#oO~O!_XO~Oa%mO'w&yO'y%mO~Oa%mO'w&|O'y%mO~Oa%mO'w'OO'y%mO~O'v]X!Y]Xv]X!k]X&Z]X!_]X%i]X!g]X~P(qO!b']O!c'UO!d'UO(T!lO(UTO(XUO~Os'SO!S'RO!['VO(d'QO!^(hP!^(wP~P@cOn'`O!_'^O(S%fO~Oe'eO!l%dO(S%fO~O!Q&RO!l&QO~Os!nO!S!oO!|;wO#T!pO#U!pO#W!pO#X!pO(T!lO(UTO(XUO(d!mO(n!sO~O!b'kO!c'jO!d'jO#V!pO#['lO#]'lO~PA}Oa%mOh%VO!g#vO!l%dO'y%mO(q'nO~O!p'rO#`'pO~PC]Os!nO!S!oO(UTO(XUO(d!mO(n!sO~O!_XOs(lX!S(lX!b(lX!c(lX!d(lX!|(lX#T(lX#U(lX#V(lX#W(lX#X(lX#[(lX#](lX(T(lX(U(lX(X(lX(d(lX(n(lX~O!c'jO!d'jO(T!lO~PC{O(O'vO(P'vO(Q'xO~O_!}O(U'zO(V!}O(W'zO~O_#QO(W'zO(X'zO(Y#QO~Ov'|O~P%[Ox#SO!U#TO(a#TO(b(PO~O![(RO!Y'VX!Y']X!]'VX!]']X~P+}O!](TO!Y(gX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!](TO!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(`VO(q$YO(x#|O(y#}O~O!Y(gX~PGvO!Y(YO~O!Y(tX!](tX!g(tX!k(tX(q(tX~O#`(tX#k#dX!^(tX~PIyO#`(ZO!Y(vX!](vX~O!]([O!Y(uX~O!Y(_O~O#`$eO~PIyO!^(`O~P`OR#zO!Q#yO!S#{O!l#xO(`VOP!na[!naj!nar!na!]!na!p!na#R!na#n!na#o!na#p!na#q!na#r!na#s!na#t!na#u!na#v!na#x!na#z!na#{!na(q!na(x!na(y!na~Oa!na'y!na'v!na!Y!na!k!nav!na!_!na%i!na!g!na~PKaO!k(aO~O!g#vO#`(bO(q'nO!](sXa(sX'y(sX~O!k(sX~PM|O!S%gO!_%hO!|]O#i(gO#j(fO(S%fO~O!](hO!k(rX~O!k(jO~O!S%gO!_%hO#j(fO(S%fO~OP(fXR(fX[(fXj(fXr(fX!Q(fX!S(fX!](fX!l(fX!p(fX#R(fX#n(fX#o(fX#p(fX#q(fX#r(fX#s(fX#t(fX#u(fX#v(fX#x(fX#z(fX#{(fX(`(fX(q(fX(x(fX(y(fX~O!g#vO!k(fX~P! jOR(lO!Q(kO!l#xO#S$dO!|!{a!S!{a~O!x!{a%h!{a!_!{a#i!{a#j!{a(S!{a~P!#kO!x(pO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(S!dO(UTO(XUO(`VO(n[O~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<eO!S${O!_$|O!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(S(tO(UTO(XUO(`$uO(x$}O(y%PO~O#k(vO~O![(xO!k(jP~P%[O(d(zO(n[O~O!S(|O!l#xO(d(zO(n[O~OP;vOQ;vOSfOd=rOe!iOpkOr;vOskOtkOzkO|;vO!O;vO!SWO!WkO!XkO!_!eO!i;yO!lZO!o;vO!p;vO!q;vO!s;zO!u;}O!x!hO$W!kO$n=pO(S)ZO(UTO(XUO(`VO(n[O~O!]$_Oa$qa'y$qa'v$qa!k$qa!Y$qa!_$qa%i$qa!g$qa~Ol)bO~P!&oOh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O%[O!S${O!_$|O!i%aO!l$xO#j%bO$W%_O$t%]O$v%^O$y%`O(S(tO(UTO(XUO(`$uO(x$}O(y%PO~Og(oP~P!+xO!Q)gO!g)fO!_$^X$Z$^X$]$^X$_$^X$f$^X~O!g)fO!_(zX$Z(zX$](zX$_(zX$f(zX~O!Q)gO~P!.RO!Q)gO!_(zX$Z(zX$](zX$_(zX$f(zX~O!_)iO$Z)mO$])hO$_)hO$f)nO~O![)qO~P!)PO$]$hO$_$gO$f)uO~On$zX!Q$zX#S$zX'x$zX(x$zX(y$zX~OgmXg$zXnmX!]mX#`mX~P!/wOx)wO(a)xO(b)zO~On*TO!Q)|O'x)}O(x$}O(y%PO~Og){O~P!0{Og*UO~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<eO!S*WO!_*XO!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(UTO(XUO(`$uO(x$}O(y%PO~O![*[O(S*VO!k(}P~P!1jO#k*^O~O!l*_O~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<eO!S${O!_$|O!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(S*aO(UTO(XUO(`$uO(x$}O(y%PO~O![*dO!Y)OP~P!3iOr*pOs!nO!S*fO!b*nO!c*hO!d*hO!l*_O#[*oO%`*jO(T!lO(UTO(XUO(d!mO~O!^*mO~P!5^O#S$dOn(_X!Q(_X'x(_X(x(_X(y(_X!](_X#`(_X~Og(_X$O(_X~P!6`On*uO#`*tOg(^X!](^X~O!]*vOg(]X~Oj%cOk%cOl%cO(S&XOg(]P~Os*yO~O!l+OO~O(S(tO~Op+TO!S%gO![#iO!_%hO!|]O#i#lO#j#iO(S%fO!k(rP~O!g#vO#k+UO~O!S%gO![+WO!]([O!_%hO(S%fO!Y(uP~Os'YO!S+YO![+XO(UTO(XUO(d(zO~O!^(wP~P!9iO!]+ZOa)SX'y)SX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(`VO(q$YO(x#|O(y#}O~Oa!ja!]!ja'y!ja'v!ja!Y!ja!k!jav!ja!_!ja%i!ja!g!ja~P!:aOR#zO!Q#yO!S#{O!l#xO(`VOP!ra[!raj!rar!ra!]!ra!p!ra#R!ra#n!ra#o!ra#p!ra#q!ra#r!ra#s!ra#t!ra#u!ra#v!ra#x!ra#z!ra#{!ra(q!ra(x!ra(y!ra~Oa!ra'y!ra'v!ra!Y!ra!k!rav!ra!_!ra%i!ra!g!ra~P!<wOR#zO!Q#yO!S#{O!l#xO(`VOP!ta[!taj!tar!ta!]!ta!p!ta#R!ta#n!ta#o!ta#p!ta#q!ta#r!ta#s!ta#t!ta#u!ta#v!ta#x!ta#z!ta#{!ta(q!ta(x!ta(y!ta~Oa!ta'y!ta'v!ta!Y!ta!k!tav!ta!_!ta%i!ta!g!ta~P!?_Oh%VOn+dO!_'^O%i+cO~O!g+fOa([X!_([X'y([X!]([X~Oa%mO!_XO'y%mO~Oh%VO!l%dO~Oh%VO!l%dO(S%fO~O!g#vO#k(vO~Ob+qO%j+rO(S+nO(UTO(XUO!^)WP~O!]+sO`)VX~O[+wO~O`+xO~O!_&OO(S%fO(T!lO`)VP~Oh%VO#`+}O~Oh%VOn,QO!_$|O~O!_,SO~O!Q,UO!_XO~O%n%uO~O!x,ZO~Oe,`O~Ob,aO(S#nO(UTO(XUO!^)UP~Oe%|O~O%j!QO(S&XO~P=[O[,fO`,eO~OPYOQYOSfOdzOeyOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!iuO!lZO!oYO!pYO!qYO!svO!xxO!|]O$niO%h}O(UTO(XUO(`VO(n[O~O!_!eO!u!gO$W!kO(S!dO~P!F_O`,eOa%mO'y%mO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!x!hO$W!kO$niO(S!dO(UTO(XUO(`VO(n[O~Oa,kOl!OO!uwO%l!OO%m!OO%n!OO~P!HwO!l&mO~O&],qO~O!_,sO~O&n,uO&p,vOP&kaQ&kaS&kaY&kaa&kad&kae&kal&kap&kar&kas&kat&kaz&ka|&ka!O&ka!S&ka!W&ka!X&ka!_&ka!i&ka!l&ka!o&ka!p&ka!q&ka!s&ka!u&ka!x&ka!|&ka$W&ka$n&ka%h&ka%j&ka%l&ka%m&ka%n&ka%q&ka%s&ka%v&ka%w&ka%y&ka&V&ka&]&ka&_&ka&a&ka&c&ka&f&ka&l&ka&r&ka&t&ka&v&ka&x&ka&z&ka'v&ka(S&ka(U&ka(X&ka(`&ka(n&ka!^&ka&d&kab&ka&i&ka~O(S,{O~Oh!eX!]!RX!^!RX!g!RX!g!eX!l!eX#`!RX~O!]!eX!^!eX~P# }O!g-QO#`-POh(iX!]#hX!^#hX!g(iX!l(iX~O!](iX!^(iX~P#!pOh%VO!g-SO!l%dO!]!aX!^!aX~Os!nO!S!oO(UTO(XUO(d!mO~OP;vOQ;vOSfOd=rOe!iOpkOr;vOskOtkOzkO|;vO!O;vO!SWO!WkO!XkO!_!eO!i;yO!lZO!o;vO!p;vO!q;vO!s;zO!u;}O!x!hO$W!kO$n=pO(UTO(XUO(`VO(n[O~O(S<rO~P#$VO!]-WO!^(hX~O!^-YO~O!g-QO#`-PO!]#hX!^#hX~O!]-ZO!^(wX~O!^-]O~O!c-^O!d-^O(T!lO~P##tO!^-aO~P'_On-dO!_'^O~O!Y-iO~Os!{a!b!{a!c!{a!d!{a#T!{a#U!{a#V!{a#W!{a#X!{a#[!{a#]!{a(T!{a(U!{a(X!{a(d!{a(n!{a~P!#kO!p-nO#`-lO~PC]O!c-pO!d-pO(T!lO~PC{Oa%mO#`-lO'y%mO~Oa%mO!g#vO#`-lO'y%mO~Oa%mO!g#vO!p-nO#`-lO'y%mO(q'nO~O(O'vO(P'vO(Q-uO~Ov-vO~O!Y'Va!]'Va~P!:aO![-zO!Y'VX!]'VX~P%[O!](TO!Y(ga~O!Y(ga~PGvO!]([O!Y(ua~O!S%gO![.OO!_%hO(S%fO!Y']X!]']X~O#`.QO!](sa!k(saa(sa'y(sa~O!g#vO~P#,]O!](hO!k(ra~O!S%gO!_%hO#j.UO(S%fO~Op.ZO!S%gO![.WO!_%hO!|]O#i.YO#j.WO(S%fO!]'`X!k'`X~OR._O!l#xO~Oh%VOn.bO!_'^O%i.aO~Oa#ci!]#ci'y#ci'v#ci!Y#ci!k#civ#ci!_#ci%i#ci!g#ci~P!:aOn=|O!Q)|O'x)}O(x$}O(y%PO~O#k#_aa#_a#`#_a'y#_a!]#_a!k#_a!_#_a!Y#_a~P#/XO#k(_XP(_XR(_X[(_Xa(_Xj(_Xr(_X!S(_X!l(_X!p(_X#R(_X#n(_X#o(_X#p(_X#q(_X#r(_X#s(_X#t(_X#u(_X#v(_X#x(_X#z(_X#{(_X'y(_X(`(_X(q(_X!k(_X!Y(_X'v(_Xv(_X!_(_X%i(_X!g(_X~P!6`O!].oO!k(jX~P!:aO!k.rO~O!Y.tO~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(`VO[#mia#mij#mir#mi!]#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'y#mi(q#mi(x#mi(y#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#n#mi~P#2wO#n$OO~P#2wOP$[OR#zOr$aO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(`VO[#mia#mij#mi!]#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'y#mi(q#mi(x#mi(y#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#r#mi~P#5fO#r$QO~P#5fOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO(`VOa#mi!]#mi#x#mi#z#mi#{#mi'y#mi(q#mi(x#mi(y#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#v#mi~P#8TOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO(`VO(y#}Oa#mi!]#mi#z#mi#{#mi'y#mi(q#mi(x#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#x$UO~P#:kO#x#mi~P#:kO#v$SO~P#8TOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO(`VO(x#|O(y#}Oa#mi!]#mi#{#mi'y#mi(q#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#z#mi~P#=aO#z$WO~P#=aOP]XR]X[]Xj]Xr]X!Q]X!S]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(`]X(q]X(x]X(y]X!]]X!^]X~O$O]X~P#@OOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O#v<TO#x<VO#z<XO#{<YO(`VO(q$YO(x#|O(y#}O~O$O.vO~P#B]O#S$dO#`<`O$Q<`O$O(fX!^(fX~P! jOa'ca!]'ca'y'ca'v'ca!k'ca!Y'cav'ca!_'ca%i'ca!g'ca~P!:aO[#mia#mij#mir#mi!]#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'y#mi(q#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(`VO(x#mi(y#mi~P#E_On=|O!Q)|O'x)}O(x$}O(y%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(`#mi~P#E_O!].zOg(oX~P!0{Og.|O~Oa$Pi!]$Pi'y$Pi'v$Pi!Y$Pi!k$Piv$Pi!_$Pi%i$Pi!g$Pi~P!:aO$].}O$_.}O~O$]/OO$_/OO~O!g)fO#`/PO!_$cX$Z$cX$]$cX$_$cX$f$cX~O![/QO~O!_)iO$Z/SO$])hO$_)hO$f/TO~O!]<ZO!^(eX~P#B]O!^/UO~O!g)fO$f(zX~O$f/WO~Ov/XO~P!&oOx)wO(a)xO(b/[O~O!S/_O~O(x$}On%aa!Q%aa'x%aa(y%aa!]%aa#`%aa~Og%aa$O%aa~P#LaO(y%POn%ca!Q%ca'x%ca(x%ca!]%ca#`%ca~Og%ca$O%ca~P#MSO!]fX!gfX!kfX!k$zX(qfX~P!/wO![/hO!]([O(S/gO!Y(uP!Y)OP~P!1jOr*pO!b*nO!c*hO!d*hO!l*_O#[*oO%`*jO(T!lO(UTO(XUO~Os<oO!S/iO![+XO!^*mO(d<nO!^(wP~P#NmO!k/jO~P#/XO!]/kO!g#vO(q'nO!k(}X~O!k/pO~O!S%gO![*[O!_%hO(S%fO!k(}P~O#k/rO~O!Y$zX!]$zX!g%RX~P!/wO!]/sO!Y)OX~P#/XO!g/uO~O!Y/wO~OpkO(S/xO~P.iOh%VOr/}O!g#vO!l%dO(q'nO~O!g+fO~Oa%mO!]0RO'y%mO~O!^0TO~P!5^O!c0UO!d0UO(T!lO~P##tOs!nO!S0VO(UTO(XUO(d!mO~O#[0XO~Og%aa!]%aa#`%aa$O%aa~P!0{Og%ca!]%ca#`%ca$O%ca~P!0{Oj%cOk%cOl%cO(S&XOg'lX!]'lX~O!]*vOg(]a~Og0bO~OR0cO!Q0cO!S0dO#S$dOn}a'x}a(x}a(y}a!]}a#`}a~Og}a$O}a~P$&vO!Q)|O'x)}On$sa(x$sa(y$sa!]$sa#`$sa~Og$sa$O$sa~P$'rO!Q)|O'x)}On$ua(x$ua(y$ua!]$ua#`$ua~Og$ua$O$ua~P$(eO#k0gO~Og%Ta!]%Ta#`%Ta$O%Ta~P!0{On0iO#`0hOg(^a!](^a~O!g#vO~O#k0lO~O!]+ZOa)Sa'y)Sa~OR#zO!Q#yO!S#{O!l#xO(`VOP!ri[!rij!rir!ri!]!ri!p!ri#R!ri#n!ri#o!ri#p!ri#q!ri#r!ri#s!ri#t!ri#u!ri#v!ri#x!ri#z!ri#{!ri(q!ri(x!ri(y!ri~Oa!ri'y!ri'v!ri!Y!ri!k!riv!ri!_!ri%i!ri!g!ri~P$*bOh%VOr%XOs$tOt$tOz%YO|%ZO!O<eO!S${O!_$|O!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(UTO(XUO(`$uO(x$}O(y%PO~Op0uO%]0vO(S0tO~P$,xO!g+fOa([a!_([a'y([a!]([a~O#k0|O~O[]X!]fX!^fX~O!]0}O!^)WX~O!^1PO~O[1QO~Ob1SO(S+nO(UTO(XUO~O!_&OO(S%fO`'tX!]'tX~O!]+sO`)Va~O!k1VO~P!:aO[1YO~O`1ZO~O#`1^O~On1aO!_$|O~O(d(zO!^)TP~Oh%VOn1jO!_1gO%i1iO~O[1tO!]1rO!^)UX~O!^1uO~O`1wOa%mO'y%mO~O(S#nO(UTO(XUO~O#S$dO#`$eO$Q$eOP(fXR(fX[(fXr(fX!Q(fX!S(fX!](fX!l(fX!p(fX#R(fX#n(fX#o(fX#p(fX#q(fX#r(fX#s(fX#t(fX#u(fX#v(fX#x(fX#z(fX#{(fX(`(fX(q(fX(x(fX(y(fX~Oj1zO&Z1{Oa(fX~P$2cOj1zO#`$eO&Z1{O~Oa1}O~P%[Oa2PO~O&d2SOP&biQ&biS&biY&bia&bid&bie&bil&bip&bir&bis&bit&biz&bi|&bi!O&bi!S&bi!W&bi!X&bi!_&bi!i&bi!l&bi!o&bi!p&bi!q&bi!s&bi!u&bi!x&bi!|&bi$W&bi$n&bi%h&bi%j&bi%l&bi%m&bi%n&bi%q&bi%s&bi%v&bi%w&bi%y&bi&V&bi&]&bi&_&bi&a&bi&c&bi&f&bi&l&bi&r&bi&t&bi&v&bi&x&bi&z&bi'v&bi(S&bi(U&bi(X&bi(`&bi(n&bi!^&bib&bi&i&bi~Ob2YO!^2WO&i2XO~P`O!_XO!l2[O~O&p,vOP&kiQ&kiS&kiY&kia&kid&kie&kil&kip&kir&kis&kit&kiz&ki|&ki!O&ki!S&ki!W&ki!X&ki!_&ki!i&ki!l&ki!o&ki!p&ki!q&ki!s&ki!u&ki!x&ki!|&ki$W&ki$n&ki%h&ki%j&ki%l&ki%m&ki%n&ki%q&ki%s&ki%v&ki%w&ki%y&ki&V&ki&]&ki&_&ki&a&ki&c&ki&f&ki&l&ki&r&ki&t&ki&v&ki&x&ki&z&ki'v&ki(S&ki(U&ki(X&ki(`&ki(n&ki!^&ki&d&kib&ki&i&ki~O!Y2bO~O!]!aa!^!aa~P#B]Os!nO!S!oO![2hO(d!mO!]'WX!^'WX~P@cO!]-WO!^(ha~O!]'^X!^'^X~P!9iO!]-ZO!^(wa~O!^2oO~P'_Oa%mO#`2xO'y%mO~Oa%mO!g#vO#`2xO'y%mO~Oa%mO!g#vO!p2|O#`2xO'y%mO(q'nO~Oa%mO'y%mO~P!:aO!]$_Ov$qa~O!Y'Vi!]'Vi~P!:aO!](TO!Y(gi~O!]([O!Y(ui~O!Y(vi!](vi~P!:aO!](si!k(sia(si'y(si~P!:aO#`3OO!](si!k(sia(si'y(si~O!](hO!k(ri~O!S%gO!_%hO!|]O#i3TO#j3SO(S%fO~O!S%gO!_%hO#j3SO(S%fO~On3[O!_'^O%i3ZO~Oh%VOn3[O!_'^O%i3ZO~O#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'y%aa(`%aa(q%aa!k%aa!Y%aa'v%aav%aa!_%aa%i%aa!g%aa~P#LaO#k%caP%caR%ca[%caa%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'y%ca(`%ca(q%ca!k%ca!Y%ca'v%cav%ca!_%ca%i%ca!g%ca~P#MSO#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!]%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'y%aa(`%aa(q%aa!k%aa!Y%aa'v%aa#`%aav%aa!_%aa%i%aa!g%aa~P#/XO#k%caP%caR%ca[%caa%caj%car%ca!S%ca!]%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'y%ca(`%ca(q%ca!k%ca!Y%ca'v%ca#`%cav%ca!_%ca%i%ca!g%ca~P#/XO#k}aP}a[}aa}aj}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a'y}a(`}a(q}a!k}a!Y}a'v}av}a!_}a%i}a!g}a~P$&vO#k$saP$saR$sa[$saa$saj$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa'y$sa(`$sa(q$sa!k$sa!Y$sa'v$sav$sa!_$sa%i$sa!g$sa~P$'rO#k$uaP$uaR$ua[$uaa$uaj$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua'y$ua(`$ua(q$ua!k$ua!Y$ua'v$uav$ua!_$ua%i$ua!g$ua~P$(eO#k%TaP%TaR%Ta[%Taa%Taj%Tar%Ta!S%Ta!]%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta'y%Ta(`%Ta(q%Ta!k%Ta!Y%Ta'v%Ta#`%Tav%Ta!_%Ta%i%Ta!g%Ta~P#/XOa#cq!]#cq'y#cq'v#cq!Y#cq!k#cqv#cq!_#cq%i#cq!g#cq~P!:aO![3dO!]'XX!k'XX~P%[O!].oO!k(ja~O!].oO!k(ja~P!:aO!Y3gO~O$O!na!^!na~PKaO$O!ja!]!ja!^!ja~P#B]O$O!ra!^!ra~P!<wO$O!ta!^!ta~P!?_Og'[X!]'[X~P!+xO!].zOg(oa~OSfO!_3{O$d3|O~O!^4QO~Ov4RO~P#/XOa$mq!]$mq'y$mq'v$mq!Y$mq!k$mqv$mq!_$mq%i$mq!g$mq~P!:aO!Y4TO~P!&oO!S4UO~O!Q)|O'x)}O(y%POn'ha(x'ha!]'ha#`'ha~Og'ha$O'ha~P%,XO!Q)|O'x)}On'ja(x'ja(y'ja!]'ja#`'ja~Og'ja$O'ja~P%,zO(q$YO~P#/XO!YfX!Y$zX!]fX!]$zX!g%RX#`fX~P!/wO(S<xO~P!1jO!S%gO![4XO!_%hO(S%fO!]'dX!k'dX~O!]/kO!k(}a~O!]/kO!g#vO!k(}a~O!]/kO!g#vO(q'nO!k(}a~Og$|i!]$|i#`$|i$O$|i~P!0{O![4aO!Y'fX!]'fX~P!3iO!]/sO!Y)Oa~O!]/sO!Y)Oa~P#/XOP]XR]X[]Xj]Xr]X!Q]X!S]X!Y]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(`]X(q]X(x]X(y]X~Oj%YX!g%YX~P%0kOj4fO!g#vO~Oh%VO!g#vO!l%dO~Oh%VOr4kO!l%dO(q'nO~Or4pO!g#vO(q'nO~Os!nO!S4qO(UTO(XUO(d!mO~O(x$}On%ai!Q%ai'x%ai(y%ai!]%ai#`%ai~Og%ai$O%ai~P%4[O(y%POn%ci!Q%ci'x%ci(x%ci!]%ci#`%ci~Og%ci$O%ci~P%4}Og(^i!](^i~P!0{O#`4wOg(^i!](^i~P!0{O!k4zO~Oa$oq!]$oq'y$oq'v$oq!Y$oq!k$oqv$oq!_$oq%i$oq!g$oq~P!:aO!Y5QO~O!]5RO!_)PX~P#/XOa$zX!_$zX%^]X'y$zX!]$zX~P!/wO%^5UOaoXnoX!QoX!_oX'xoX'yoX(xoX(yoX!]oX~Op5VO(S#nO~O%^5UO~Ob5]O%j5^O(S+nO(UTO(XUO!]'sX!^'sX~O!]0}O!^)Wa~O[5bO~O`5cO~Oa%mO'y%mO~P#/XO!]5kO#`5mO!^)TX~O!^5nO~Or5tOs!nO!S*fO!b!yO!c!vO!d!vO!|;wO#T!pO#U!pO#V!pO#W!pO#X!pO#[5sO#]!zO(T!lO(UTO(XUO(d!mO(n!sO~O!^5rO~P%:YOn5yO!_1gO%i5xO~Oh%VOn5yO!_1gO%i5xO~Ob6QO(S#nO(UTO(XUO!]'rX!^'rX~O!]1rO!^)Ua~O(UTO(XUO(d6SO~O`6WO~Oj6ZO&Z6[O~PM|O!k6]O~P%[Oa6_O~Oa6_O~P%[Ob2YO!^6dO&i2XO~P`O!g6fO~O!g6hOh(ii!](ii!^(ii!g(ii!l(iir(ii(q(ii~O!]#hi!^#hi~P#B]O#`6iO!]#hi!^#hi~O!]!ai!^!ai~P#B]Oa%mO#`6rO'y%mO~Oa%mO!g#vO#`6rO'y%mO~O!](sq!k(sqa(sq'y(sq~P!:aO!](hO!k(rq~O!S%gO!_%hO#j6yO(S%fO~O!_'^O%i6|O~On7QO!_'^O%i6|O~O#k'haP'haR'ha['haa'haj'har'ha!S'ha!l'ha!p'ha#R'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#t'ha#u'ha#v'ha#x'ha#z'ha#{'ha'y'ha(`'ha(q'ha!k'ha!Y'ha'v'hav'ha!_'ha%i'ha!g'ha~P%,XO#k'jaP'jaR'ja['jaa'jaj'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja'y'ja(`'ja(q'ja!k'ja!Y'ja'v'jav'ja!_'ja%i'ja!g'ja~P%,zO#k$|iP$|iR$|i[$|ia$|ij$|ir$|i!S$|i!]$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i'y$|i(`$|i(q$|i!k$|i!Y$|i'v$|i#`$|iv$|i!_$|i%i$|i!g$|i~P#/XO#k%aiP%aiR%ai[%aia%aij%air%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai'y%ai(`%ai(q%ai!k%ai!Y%ai'v%aiv%ai!_%ai%i%ai!g%ai~P%4[O#k%ciP%ciR%ci[%cia%cij%cir%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci'y%ci(`%ci(q%ci!k%ci!Y%ci'v%civ%ci!_%ci%i%ci!g%ci~P%4}O!]'Xa!k'Xa~P!:aO!].oO!k(ji~O$O#ci!]#ci!^#ci~P#B]OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(`VO[#mij#mir#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(q#mi(x#mi(y#mi!]#mi!^#mi~O#n#mi~P%MXO#n<PO~P%MXOP$[OR#zOr<]O!Q#yO!S#{O!l#xO!p$[O#n<PO#o<QO#p<QO#q<QO(`VO[#mij#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(q#mi(x#mi(y#mi!]#mi!^#mi~O#r#mi~P& aO#r<RO~P& aOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O(`VO#x#mi#z#mi#{#mi$O#mi(q#mi(x#mi(y#mi!]#mi!^#mi~O#v#mi~P&#iOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O#v<TO(`VO(y#}O#z#mi#{#mi$O#mi(q#mi(x#mi!]#mi!^#mi~O#x<VO~P&%jO#x#mi~P&%jO#v<TO~P&#iOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O#v<TO#x<VO(`VO(x#|O(y#}O#{#mi$O#mi(q#mi!]#mi!^#mi~O#z#mi~P&'yO#z<XO~P&'yOa#|y!]#|y'y#|y'v#|y!Y#|y!k#|yv#|y!_#|y%i#|y!g#|y~P!:aO[#mij#mir#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(q#mi!]#mi!^#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n<PO#o<QO#p<QO#q<QO(`VO(x#mi(y#mi~P&*uOn=}O!Q)|O'x)}O(x$}O(y%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(`#mi~P&*uO#S$dOP(_XR(_X[(_Xj(_Xn(_Xr(_X!Q(_X!S(_X!l(_X!p(_X#R(_X#n(_X#o(_X#p(_X#q(_X#r(_X#s(_X#t(_X#u(_X#v(_X#x(_X#z(_X#{(_X$O(_X'x(_X(`(_X(q(_X(x(_X(y(_X!](_X!^(_X~O$O$Pi!]$Pi!^$Pi~P#B]O$O!ri!^!ri~P$*bOg'[a!]'[a~P!0{O!^7dO~O!]'ca!^'ca~P#B]O!Y7eO~P#/XO!g#vO(q'nO!]'da!k'da~O!]/kO!k(}i~O!]/kO!g#vO!k(}i~Og$|q!]$|q#`$|q$O$|q~P!0{O!Y'fa!]'fa~P#/XO!g7lO~O!]/sO!Y)Oi~P#/XO!]/sO!Y)Oi~O!Y7oO~Oh%VOr7tO!l%dO(q'nO~Oj7vO!g#vO~Or7yO!g#vO(q'nO~O!Q)|O'x)}O(y%POn'ia(x'ia!]'ia#`'ia~Og'ia$O'ia~P&3vO!Q)|O'x)}On'ka(x'ka(y'ka!]'ka#`'ka~Og'ka$O'ka~P&4iO!Y7{O~Og%Oq!]%Oq#`%Oq$O%Oq~P!0{Og(^q!](^q~P!0{O#`7|Og(^q!](^q~P!0{Oa$oy!]$oy'y$oy'v$oy!Y$oy!k$oyv$oy!_$oy%i$oy!g$oy~P!:aO!g6hO~O!]5RO!_)Pa~O!_'^OP$TaR$Ta[$Taj$Tar$Ta!Q$Ta!S$Ta!]$Ta!l$Ta!p$Ta#R$Ta#n$Ta#o$Ta#p$Ta#q$Ta#r$Ta#s$Ta#t$Ta#u$Ta#v$Ta#x$Ta#z$Ta#{$Ta(`$Ta(q$Ta(x$Ta(y$Ta~O%i6|O~P&7ZO%^8QOa%[i!_%[i'y%[i!]%[i~Oa#cy!]#cy'y#cy'v#cy!Y#cy!k#cyv#cy!_#cy%i#cy!g#cy~P!:aO[8SO~Ob8UO(S+nO(UTO(XUO~O!]0}O!^)Wi~O`8YO~O(d(zO!]'oX!^'oX~O!]5kO!^)Ta~O!^8cO~P%:YO(n!sO~P$${O#[8dO~O!_1gO~O!_1gO%i8fO~On8iO!_1gO%i8fO~O[8nO!]'ra!^'ra~O!]1rO!^)Ui~O!k8rO~O!k8sO~O!k8vO~O!k8vO~P%[Oa8xO~O!g8yO~O!k8zO~O!](vi!^(vi~P#B]Oa%mO#`9SO'y%mO~O!](sy!k(sya(sy'y(sy~P!:aO!](hO!k(ry~O%i9VO~P&7ZO!_'^O%i9VO~O#k$|qP$|qR$|q[$|qa$|qj$|qr$|q!S$|q!]$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q'y$|q(`$|q(q$|q!k$|q!Y$|q'v$|q#`$|qv$|q!_$|q%i$|q!g$|q~P#/XO#k'iaP'iaR'ia['iaa'iaj'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia'y'ia(`'ia(q'ia!k'ia!Y'ia'v'iav'ia!_'ia%i'ia!g'ia~P&3vO#k'kaP'kaR'ka['kaa'kaj'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka'y'ka(`'ka(q'ka!k'ka!Y'ka'v'kav'ka!_'ka%i'ka!g'ka~P&4iO#k%OqP%OqR%Oq[%Oqa%Oqj%Oqr%Oq!S%Oq!]%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq'y%Oq(`%Oq(q%Oq!k%Oq!Y%Oq'v%Oq#`%Oqv%Oq!_%Oq%i%Oq!g%Oq~P#/XO!]'Xi!k'Xi~P!:aO$O#cq!]#cq!^#cq~P#B]O(x$}OP%aaR%aa[%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa$O%aa(`%aa(q%aa!]%aa!^%aa~On%aa!Q%aa'x%aa(y%aa~P&HnO(y%POP%caR%ca[%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca$O%ca(`%ca(q%ca!]%ca!^%ca~On%ca!Q%ca'x%ca(x%ca~P&JuOn=}O!Q)|O'x)}O(y%PO~P&HnOn=}O!Q)|O'x)}O(x$}O~P&JuOR0cO!Q0cO!S0dO#S$dOP}a[}aj}an}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a$O}a'x}a(`}a(q}a(x}a(y}a!]}a!^}a~O!Q)|O'x)}OP$saR$sa[$saj$san$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa$O$sa(`$sa(q$sa(x$sa(y$sa!]$sa!^$sa~O!Q)|O'x)}OP$uaR$ua[$uaj$uan$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua$O$ua(`$ua(q$ua(x$ua(y$ua!]$ua!^$ua~On=}O!Q)|O'x)}O(x$}O(y%PO~OP%TaR%Ta[%Taj%Tar%Ta!S%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta$O%Ta(`%Ta(q%Ta!]%Ta!^%Ta~P'%zO$O$mq!]$mq!^$mq~P#B]O$O$oq!]$oq!^$oq~P#B]O!^9dO~O$O9eO~P!0{O!g#vO!]'di!k'di~O!g#vO(q'nO!]'di!k'di~O!]/kO!k(}q~O!Y'fi!]'fi~P#/XO!]/sO!Y)Oq~Or9lO!g#vO(q'nO~O[9nO!Y9mO~P#/XO!Y9mO~Oj9tO!g#vO~Og(^y!](^y~P!0{O!]'ma!_'ma~P#/XOa%[q!_%[q'y%[q!]%[q~P#/XO[9yO~O!]0}O!^)Wq~O#`9}O!]'oa!^'oa~O!]5kO!^)Ti~P#B]O!S:PO~O!_1gO%i:SO~O(UTO(XUO(d:XO~O!]1rO!^)Uq~O!k:[O~O!k:]O~O!k:^O~O!k:^O~P%[O#`:aO!]#hy!^#hy~O!]#hy!^#hy~P#B]O%i:fO~P&7ZO!_'^O%i:fO~O$O#|y!]#|y!^#|y~P#B]OP$|iR$|i[$|ij$|ir$|i!S$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i$O$|i(`$|i(q$|i!]$|i!^$|i~P'%zO!Q)|O'x)}O(y%POP'haR'ha['haj'han'har'ha!S'ha!l'ha!p'ha#R'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#t'ha#u'ha#v'ha#x'ha#z'ha#{'ha$O'ha(`'ha(q'ha(x'ha!]'ha!^'ha~O!Q)|O'x)}OP'jaR'ja['jaj'jan'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja$O'ja(`'ja(q'ja(x'ja(y'ja!]'ja!^'ja~O(x$}OP%aiR%ai[%aij%ain%air%ai!Q%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai$O%ai'x%ai(`%ai(q%ai(y%ai!]%ai!^%ai~O(y%POP%ciR%ci[%cij%cin%cir%ci!Q%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci$O%ci'x%ci(`%ci(q%ci(x%ci!]%ci!^%ci~O$O$oy!]$oy!^$oy~P#B]O$O#cy!]#cy!^#cy~P#B]O!g#vO!]'dq!k'dq~O!]/kO!k(}y~O!Y'fq!]'fq~P#/XOr:pO!g#vO(q'nO~O[:tO!Y:sO~P#/XO!Y:sO~Og(^!R!](^!R~P!0{Oa%[y!_%[y'y%[y!]%[y~P#/XO!]0}O!^)Wy~O!]5kO!^)Tq~O(S:zO~O!_1gO%i:}O~O!k;QO~O%i;VO~P&7ZOP$|qR$|q[$|qj$|qr$|q!S$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q$O$|q(`$|q(q$|q!]$|q!^$|q~P'%zO!Q)|O'x)}O(y%POP'iaR'ia['iaj'ian'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia$O'ia(`'ia(q'ia(x'ia!]'ia!^'ia~O!Q)|O'x)}OP'kaR'ka['kaj'kan'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka$O'ka(`'ka(q'ka(x'ka(y'ka!]'ka!^'ka~OP%OqR%Oq[%Oqj%Oqr%Oq!S%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq$O%Oq(`%Oq(q%Oq!]%Oq!^%Oq~P'%zOg%e!Z!]%e!Z#`%e!Z$O%e!Z~P!0{O!Y;ZO~P#/XOr;[O!g#vO(q'nO~O[;^O!Y;ZO~P#/XO!]'oq!^'oq~P#B]O!]#h!Z!^#h!Z~P#B]O#k%e!ZP%e!ZR%e!Z[%e!Za%e!Zj%e!Zr%e!Z!S%e!Z!]%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z'y%e!Z(`%e!Z(q%e!Z!k%e!Z!Y%e!Z'v%e!Z#`%e!Zv%e!Z!_%e!Z%i%e!Z!g%e!Z~P#/XOr;fO!g#vO(q'nO~O!Y;gO~P#/XOr;nO!g#vO(q'nO~O!Y;oO~P#/XOP%e!ZR%e!Z[%e!Zj%e!Zr%e!Z!S%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z$O%e!Z(`%e!Z(q%e!Z!]%e!Z!^%e!Z~P'%zOr;rO!g#vO(q'nO~Ov(eX~P1qO!Q%qO~P!)PO(T!lO~P!)PO!YfX!]fX#`fX~P%0kOP]XR]X[]Xj]Xr]X!Q]X!S]X!]]X!]fX!l]X!p]X#R]X#S]X#`]X#`fX#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(`]X(q]X(x]X(y]X~O!gfX!k]X!kfX(qfX~P'JsOP;vOQ;vOSfOd=rOe!iOpkOr;vOskOtkOzkO|;vO!O;vO!SWO!WkO!XkO!_XO!i;yO!lZO!o;vO!p;vO!q;vO!s;zO!u;}O!x!hO$W!kO$n=pO(S)ZO(UTO(XUO(`VO(n[O~O!]<ZO!^$qa~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<fO!S${O!_$|O!i=wO!l$xO#j<lO$W%_O$t<hO$v<jO$y%`O(S(tO(UTO(XUO(`$uO(x$}O(y%PO~Ol)bO~P( iOr!eX(q!eX~P# }Or(iX(q(iX~P#!pO!^]X!^fX~P'JsO!YfX!Y$zX!]fX!]$zX#`fX~P!/wO#k<OO~O!g#vO#k<OO~O#`<`O~Oj<SO~O#`<pO!](vX!^(vX~O#`<`O!](tX!^(tX~O#k<qO~Og<sO~P!0{O#k<yO~O#k<zO~O!g#vO#k<{O~O!g#vO#k<qO~O$O<|O~P#B]O#k<}O~O#k=OO~O#k=TO~O#k=UO~O#k=VO~O#k=WO~O$O=XO~P!0{O$O=YO~P!0{Ok#S#T#U#W#X#[#i#j#u$n$t$v$y%]%^%h%i%j%q%s%v%w%y%{~'}T#o!X'{(T#ps#n#qr!Q'|$]'|(S$_(d~",
  goto: "$8g)[PPPPPP)]PP)`P)qP+R/WPPPP6bPP6xPP<pPPP@dP@zP@zPPP@zPCSP@zP@zP@zPCWPC]PCzPHtPPPHxPPPPHxK{PPPLRLsPHxPHxPP! RHxPPPHxPHxP!#YHxP!&p!'u!(OP!(r!(v!(r!,TPPPPPPP!,t!'uPP!-U!.vP!2SHxHx!2X!5e!:R!:R!>QPPP!>YHxPPPPPPPPP!AiP!BvPPHx!DXPHxPHxHxHxHxHxPHx!EkP!HuP!K{P!LP!LZ!L_!L_P!HrP!Lc!LcP# iP# mHxPHx# s#$xCW@zP@zP@z@zP#&V@z@z#(i@z#+a@z#-m@z@z#.]#0q#0q#0v#1P#0q#1[PP#0qP@z#1t@z#5s@z@z6bPPP#9xPPP#:c#:cP#:cP#:y#:cPP#;PP#:vP#:v#;d#:v#<O#<U#<X)`#<[)`P#<c#<c#<cP)`P)`P)`P)`PP)`P#<i#<lP#<l)`P#<pP#<sP)`P)`P)`P)`P)`P)`)`PP#<y#=P#=[#=b#=h#=n#=t#>S#>Y#>d#>j#>t#>z#?[#?b#@S#@f#@l#@r#AQ#Ag#C[#Cj#Cq#E]#Ek#G]#Gk#Gq#Gw#G}#HX#H_#He#Ho#IR#IXPPPPPPPPPPP#I_PPPPPPP#JS#MZ#Ns#Nz$ SPPP$&nP$&w$)p$0Z$0^$0a$1`$1c$1j$1rP$1x$1{P$2i$2m$3e$4s$4x$5`PP$5e$5k$5o$5r$5v$5z$6v$7_$7v$7z$7}$8Q$8W$8Z$8_$8cR!|RoqOXst!Z#d%l&p&r&s&u,n,s2S2VY!vQ'^-`1g5qQ%svQ%{yQ&S|Q&h!VS'U!e-WQ'd!iS'j!r!yU*h$|*X*lQ+l%|Q+y&UQ,_&bQ-^']Q-h'eQ-p'kQ0U*nQ1q,`R<m;z%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y,k,n,s-d-l-z.Q.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3d4q5y6Z6[6_6r8i8x9SS#q];w!r)]$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sU*{%[<e<fQ+q&OQ,a&eQ,h&mQ0r+dQ0w+fQ1S+rQ1y,fQ3W.bQ5V0vQ5]0}Q6Q1rQ7O3[Q8U5^R9Y7Q'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s!S!nQ!r!v!y!z$|'U']'^'j'k'l*h*l*n*o-W-^-`-p0U0X1g5q5s%[$ti#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}Q&V|Q'S!eS'Y%h-ZQ+q&OQ,a&eQ0f+OQ1S+rQ1X+xQ1x,eQ1y,fQ5]0}Q5f1ZQ6Q1rQ6T1tQ6U1wQ8U5^Q8X5cQ8q6WQ9|8YQ:Y8nR<o*XrnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VR,c&i&z^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=r=s[#]WZ#W#Z'V(R!b%im#h#i#l$x%d%g([(f(g(h*W*[*_+W+X+Z,j-Q.O.U.V.W.Y/h/k2[3S3T4X6h6yQ%vxQ%zyS&P|&UQ&]!TQ'a!hQ'c!iQ(o#sS+k%{%|Q+o&OQ,Y&`Q,^&bS-g'd'eQ.d(pQ0{+lQ1R+rQ1T+sQ1W+wQ1l,ZS1p,_,`Q2t-hQ5[0}Q5`1QQ5e1YQ6P1qQ8T5^Q8W5bQ9x8SR:w9y!U$zi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y!^%xy!i!u%z%{%|'T'c'd'e'i's*g+k+l-T-g-h-o/{0O0{2m2t2{4i4j4m7s9pQ+e%vQ,O&YQ,R&ZQ,]&bQ.c(oQ1k,YU1o,^,_,`Q3].dQ5z1lS6O1p1qQ8m6P#f=t#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}o=u<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YW%Ti%V*v=pS&Y!Q&gQ&Z!RQ&[!SQ+S%cR+|&W%]%Si#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}T)x$u)yV*{%[<e<fW'Y!e%h*X-ZS({#y#zQ+`%qQ+v&RS.](k(lQ1b,SQ4x0cR8^5k'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s$i$^c#Y#e%p%r%t(Q(W(r(w)P)Q)R)S)T)U)V)W)X)Y)[)^)`)e)o+a+u-U-s-x-}.P.n.q.u.w.x.y/]0j2c2f2v2}3c3h3i3j3k3l3m3n3o3p3q3r3s3t3w3x4P5O5Y6k6q6v7V7W7a7b8`8|9Q9[9b9c:c:y;R;x=gT#TV#U'RkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ'W!eR2i-W!W!nQ!e!r!v!y!z$|'U']'^'j'k'l*X*h*l*n*o-W-^-`-p0U0X1g5q5sR1d,UnqOXst!Z#d%l&p&r&s&u,n,s2S2VQ&w!^Q't!xS(q#u<OQ+i%yQ,W&]Q,X&_Q-e'bQ-r'mS.m(v<qS0k+U<{Q0y+jQ1f,VQ2Z,uQ2],vQ2e-RQ2r-fQ2u-jS5P0l=VQ5W0zS5Z0|=WQ6j2gQ6n2sQ6s2zQ8R5XQ8}6lQ9O6oQ9R6tR:`8z$d$]c#Y#e%r%t(Q(W(r(w)P)Q)R)S)T)U)V)W)X)Y)[)^)`)e)o+a+u-U-s-x-}.P.n.q.u.x.y/]0j2c2f2v2}3c3h3i3j3k3l3m3n3o3p3q3r3s3t3w3x4P5O5Y6k6q6v7V7W7a7b8`8|9Q9[9b9c:c:y;R;x=gS(m#p'gQ(}#zS+_%p.wS.^(l(nR3U._'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sS#q];wQ&r!XQ&s!YQ&u![Q&v!]R2R,qQ'_!hQ+b%vQ-c'aS.`(o+eQ2p-bW3Y.c.d0q0sQ6m2qW6z3V3X3]5TU9U6{6}7PU:e9W9X9ZS;T:d:gQ;b;UR;j;cU!wQ'^-`T5o1g5q!Q_OXZ`st!V!Z#d#h%d%l&g&i&p&r&s&u(h,n,s.V2S2V]!pQ!r'^-`1g5qT#q];w%^{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SS({#y#zS.](k(l!s=^$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sU$fd)],hS(n#p'gU*s%R(u3vU0e*z.i7]Q5T0rQ6{3WQ9X7OR:g9Ym!tQ!r!v!y!z'^'j'k'l-`-p1g5q5sQ'r!uS(d#g1|S-n'i'uQ/n*ZQ/{*gQ2|-qQ4]/oQ4i/}Q4j0OQ4o0WQ7h4WS7s4k4mS7w4p4rQ9g7iQ9k7oQ9p7tQ9u7yS:o9l9mS;Y:p:sS;e;Z;[S;m;f;gS;q;n;oR;t;rQ#wbQ'q!uS(c#g1|S(e#m+TQ+V%eQ+g%wQ+m%}U-m'i'r'uQ.R(dQ/m*ZQ/|*gQ0P*iQ0x+hQ1m,[S2y-n-qQ3R.ZS4[/n/oQ4e/yS4h/{0WQ4l0QQ5|1nQ6u2|Q7g4WQ7k4]U7r4i4o4rQ7u4nQ8k5}S9f7h7iQ9j7oQ9r7wQ9s7xQ:V8lQ:m9gS:n9k9mQ:v9uQ;P:WS;X:o:sS;d;Y;ZS;l;e;gS;p;m;oQ;s;qQ;u;tQ=a=[Q=l=eR=m=fV!wQ'^-`%^aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SS#wz!j!r=Z$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sR=a=r%^bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SQ%ej!^%wy!i!u%z%{%|'T'c'd'e'i's*g+k+l-T-g-h-o/{0O0{2m2t2{4i4j4m7s9pS%}z!jQ+h%xQ,[&bW1n,],^,_,`U5}1o1p1qS8l6O6PQ:W8m!r=[$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ=e=qR=f=r%QeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SY#bWZ#W#Z(R!b%im#h#i#l$x%d%g([(f(g(h*W*[*_+W+X+Z,j-Q.O.U.V.W.Y/h/k2[3S3T4X6h6yQ,i&m!p=]$Z$n)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sR=`'VU'Z!e%h*XR2k-Z%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y,k,n,s-d-l-z.Q.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3d4q5y6Z6[6_6r8i8x9S!r)]$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ,h&mQ0r+dQ3W.bQ7O3[R9Y7Q!b$Tc#Y%p(Q(W(r(w)X)Y)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;x!P<U)[)o-U.w2c2f3h3q3r3w4P6k7W7a7b8`8|9[9b9c:y;R=g!f$Vc#Y%p(Q(W(r(w)U)V)X)Y)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;x!T<W)[)o-U.w2c2f3h3n3o3q3r3w4P6k7W7a7b8`8|9[9b9c:y;R=g!^$Zc#Y%p(Q(W(r(w)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;xQ4V/fz=s)[)o-U.w2c2f3h3w4P6k7W7a7b8`8|9[9b9c:y;R=gQ=x=zR=y={'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sS$oh$pR3|/P'XgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/P/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sT$kf$qQ$ifS)h$l)lR)t$qT$jf$qT)j$l)l'XhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/P/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sT$oh$pQ$rhR)s$p%^jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9S!s=q$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s#glOPXZst!Z!`!o#S#d#o#{$n%l&i&l&m&p&r&s&u&y'R'`(|)q*f+Y+d,k,n,s-d.b/Q/i0V0d1j1z1{1}2P2S2V2X3[3{4q5y6Z6[6_7Q8i8x!U%Ri$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y#f(u#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}Q+P%`Q/^)|o3v<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!U$yi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=yQ*`$zU*i$|*X*lQ+Q%aQ0Q*j#f=c#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n=d<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YQ=h=tQ=i=uQ=j=vR=k=w!U%Ri$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y#f(u#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}o3v<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YnoOXst!Z#d%l&p&r&s&u,n,s2S2VS*c${*WQ,|&|Q,}'OR4`/s%[%Si#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}Q,P&ZQ1`,RQ5i1_R8]5jV*k$|*X*lU*k$|*X*lT5p1g5qS/y*f/iQ4n0VT7x4q:PQ+g%wQ0P*iQ0x+hQ1m,[Q5|1nQ8k5}Q:V8lR;P:W!U%Oi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=yx*P$v)c*Q*r+R/q0^0_3y4^4{4|4}7f7z9v:l=b=n=oS0Y*q0Z#f<a#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n<b<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!d<t(s)a*Y*b.e.h.l/Y/f/v0p1]3`4S4_4c5h7R7U7m7p7}8P9i9q9w:q:u;W;];h=z={`<u3u7X7[7`9]:h:k;kS=P.g3aT=Q7Z9`!U%Qi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y|*R$v)c*S*q+R/b/q0^0_3y4^4s4{4|4}7f7z9v:l=b=n=oS0[*r0]#f<c#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n<d<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!h<v(s)a*Y*b.f.g.l/Y/f/v0p1]3^3`4S4_4c5h7R7S7U7m7p7}8P9i9q9w:q:u;W;];h=z={d<w3u7Y7Z7`9]9^:h:i:k;kS=R.h3bT=S7[9arnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VQ&d!UR,k&mrnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VR&d!UQ,T&[R1[+|snOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VQ1h,YS5w1k1lU8e5u5v5zS:R8g8hS:{:Q:TQ;_:|R;i;`Q&k!VR,d&gR6T1tR:Y8nS&P|&UR1T+sQ&p!WR,n&qR,t&vT2T,s2VR,x&wQ,w&wR2^,xQ'w!{R-t'wSsOtQ#dXT%os#dQ#OTR'y#OQ#RUR'{#RQ)y$uR/Z)yQ#UVR(O#UQ#XWU(U#X(V-{Q(V#YR-{(WQ-X'WR2j-XQ.p(wS3e.p3fR3f.qQ-`'^R2n-`Y!rQ'^-`1g5qR'h!rQ.{)cR3z.{U#_W%g*WU(]#_(^-|Q(^#`R-|(XQ-['ZR2l-[t`OXst!V!Z#d%l&g&i&p&r&s&u,n,s2S2VS#hZ%dU#r`#h.VR.V(hQ(i#jQ.S(eW.[(i.S3P6wQ3P.TR6w3QQ)l$lR/R)lQ$phR)r$pQ$`cU)_$`-w<[Q-w;xR<[)oQ/l*ZW4Y/l4Z7j9hU4Z/m/n/oS7j4[4]R9h7k$e*O$v(s)a)c*Y*b*q*r*|*}+R.g.h.j.k.l/Y/b/d/f/q/v0^0_0p1]3^3_3`3u3y4S4^4_4c4s4u4{4|4}5h7R7S7T7U7Z7[7^7_7`7f7m7p7z7}8P9]9^9_9i9q9v9w:h:i:j:k:l:q:u;W;];h;k=b=n=o=z={Q/t*bU4b/t4d7nQ4d/vR7n4cS*l$|*XR0S*lx*Q$v)c*q*r+R/q0^0_3y4^4{4|4}7f7z9v:l=b=n=o!d.e(s)a*Y*b.g.h.l/Y/f/v0p1]3`4S4_4c5h7R7U7m7p7}8P9i9q9w:q:u;W;];h=z={U/c*Q.e7Xa7X3u7Z7[7`9]:h:k;kQ0Z*qQ3a.gU4t0Z3a9`R9`7Z|*S$v)c*q*r+R/b/q0^0_3y4^4s4{4|4}7f7z9v:l=b=n=o!h.f(s)a*Y*b.g.h.l/Y/f/v0p1]3^3`4S4_4c5h7R7S7U7m7p7}8P9i9q9w:q:u;W;];h=z={U/e*S.f7Ye7Y3u7Z7[7`9]9^:h:i:k;kQ0]*rQ3b.hU4v0]3b9aR9a7[Q*w%UR0a*wQ5S0pR8O5SQ+[%jR0o+[Q5l1bS8_5l:OR:O8`Q,V&]R1e,VQ5q1gR8b5qQ1s,aS6R1s8oR8o6TQ1O+oW5_1O5a8V9zQ5a1RQ8V5`R9z8WQ+t&PR1U+tQ2V,sR6c2VYrOXst#dQ&t!ZQ+^%lQ,m&pQ,o&rQ,p&sQ,r&uQ2Q,nS2T,s2VR6b2SQ%npQ&x!_Q&{!aQ&}!bQ'P!cQ'o!uQ+]%kQ+i%yQ+{&VQ,c&kQ,z&zW-k'i'q'r'uQ-r'mQ0R*kQ0y+jS1v,d,gQ2_,yQ2`,|Q2a,}Q2u-jW2w-m-n-q-sQ5W0zQ5d1XQ5g1]Q5{1mQ6V1xQ6a2RU6p2v2y2|Q6s2zQ8R5XQ8Z5fQ8[5hQ8a5pQ8j5|Q8p6US9P6q6uQ9R6tQ9{8XQ:U8kQ:Z8qQ:b9QQ:x9|Q;O:VQ;S:cR;a;PQ%yyQ'b!iQ'm!uU+j%z%{%|Q-R'TU-f'c'd'eS-j'i'sQ/z*gS0z+k+lQ2g-TS2s-g-hQ2z-oS4g/{0OQ5X0{Q6l2mQ6o2tQ6t2{U7q4i4j4mQ9o7sR:r9pS$wi=pR*x%VU%Ui%V=pR0`*vQ$viS(s#v+fS)a$b$cQ)c$dQ*Y$xS*b${*WQ*q%OQ*r%QQ*|%]Q*}%^Q+R%bQ.g<aQ.h<cQ.j<gQ.k<iQ.l<kQ/Y)wQ/b*PQ/d*RQ/f*TQ/q*^S/v*d/hQ0^*tQ0_*ul0p+c,Q.a1a1i3Z5x6|8f9V:S:f:};VQ1]+}Q3^<tQ3_<vQ3`<yS3u<^<_Q3y.zS4S/_4UQ4^/rQ4_/sQ4c/uQ4s0YQ4u0[Q4{0gQ4|0hQ4}0iQ5h1^Q7R<}Q7S=PQ7T=RQ7U=TQ7Z<bQ7[<dQ7^<hQ7_<jQ7`<lQ7f4VQ7m4aQ7p4fQ7z4wQ7}5RQ8P5UQ9]<zQ9^<uQ9_<wQ9i7lQ9q7vQ9v7|Q9w8QQ:h=OQ:i=QQ:j=SQ:k=UQ:l9eQ:q9nQ:u9tQ;W=XQ;]:tQ;h;^Q;k=YQ=b=pQ=n=xQ=o=yQ=z=|R={=}Q*z%[Q.i<eR7]<fnpOXst!Z#d%l&p&r&s&u,n,s2S2VQ!fPS#fZ#oQ&z!`W'f!o*f0V4qQ'}#SQ)O#{Q)p$nS,g&i&lQ,l&mQ,y&yS-O'R/iQ-b'`Q.s(|Q/V)qQ0m+YQ0s+dQ2O,kQ2q-dQ3X.bQ4O/QQ4y0dQ5v1jQ6X1zQ6Y1{Q6^1}Q6`2PQ6e2XQ7P3[Q7c3{Q8h5yQ8t6ZQ8u6[Q8w6_Q9Z7QQ:T8iR:_8x#[cOPXZst!Z!`!o#d#o#{%l&i&l&m&p&r&s&u&y'R'`(|*f+Y+d,k,n,s-d.b/i0V0d1j1z1{1}2P2S2V2X3[4q5y6Z6[6_7Q8i8xQ#YWQ#eYQ%puQ%rvS%tw!gS(Q#W(TQ(W#ZQ(r#uQ(w#xQ)P$OQ)Q$PQ)R$QQ)S$RQ)T$SQ)U$TQ)V$UQ)W$VQ)X$WQ)Y$XQ)[$ZQ)^$_Q)`$aQ)e$eW)o$n)q/Q3{Q+a%sQ+u&QS-U'V2hQ-s'pS-x(R-zQ-}(ZQ.P(bQ.n(vQ.q(xQ.u;vQ.w;yQ.x;zQ.y;}Q/]){Q0j+UQ2c-PQ2f-SQ2v-lQ2}.QQ3c.oQ3h<OQ3i<PQ3j<QQ3k<RQ3l<SQ3m<TQ3n<UQ3o<VQ3p<WQ3q<XQ3r<YQ3s.vQ3t<]Q3w<`Q3x<mQ4P<ZQ5O0lQ5Y0|Q6k<pQ6q2xQ6v3OQ7V3dQ7W<qQ7a<sQ7b<{Q8`5mQ8|6iQ9Q6rQ9[<|Q9b=VQ9c=WQ:c9SQ:y9}Q;R:aQ;x#SR=g=sR#[WR'X!el!tQ!r!v!y!z'^'j'k'l-`-p1g5q5sS'T!e-WU*g$|*X*lS-T'U']S0O*h*nQ0W*oQ2m-^Q4m0UR4r0XR(y#xQ!fQT-_'^-`]!qQ!r'^-`1g5qQ#p]R'g;wR)d$dY!uQ'^-`1g5qQ'i!rS's!v!yS'u!z5sS-o'j'kQ-q'lR2{-pT#kZ%dS#jZ%dS%jm,jU(e#h#i#lS.T(f(gQ.X(hQ0n+ZQ3Q.UU3R.V.W.YS6x3S3TR9T6yd#^W#W#Z%g(R([*W+W.O/hr#gZm#h#i#l%d(f(g(h+Z.U.V.W.Y3S3T6yS*Z$x*_Q/o*[Q1|,jQ2d-QQ4W/kQ6g2[Q7i4XQ8{6hT=_'V+XV#aW%g*WU#`W%g*WS(S#W([U(X#Z+W/hS-V'V+XT-y(R.OV'[!e%h*XQ$lfR)v$qT)k$l)lR3}/PT*]$x*_T*e${*WQ0q+cQ1_,QQ3V.aQ5j1aQ5u1iQ6}3ZQ8g5xQ9W6|Q:Q8fQ:d9VQ:|:SQ;U:fQ;`:}R;c;VnqOXst!Z#d%l&p&r&s&u,n,s2S2VQ&j!VR,c&gtmOXst!U!V!Z#d%l&g&p&r&s&u,n,s2S2VR,j&mT%km,jR1c,SR,b&eQ&T|R+z&UR+p&OT&n!W&qT&o!W&qT2U,s2V",
  nodeNames: "⚠ ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList in out const TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast < ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate asserts is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 379,
  context: GZ,
  nodeProps: [
    ["isolate", -8, 5, 6, 14, 37, 39, 51, 53, 55, ""],
    ["group", -26, 9, 17, 19, 68, 207, 211, 215, 216, 218, 221, 224, 234, 236, 242, 244, 246, 248, 251, 257, 263, 265, 267, 269, 271, 273, 274, "Statement", -34, 13, 14, 32, 35, 36, 42, 51, 54, 55, 57, 62, 70, 72, 76, 80, 82, 84, 85, 110, 111, 120, 121, 136, 139, 141, 142, 143, 144, 145, 147, 148, 167, 169, 171, "Expression", -23, 31, 33, 37, 41, 43, 45, 173, 175, 177, 178, 180, 181, 182, 184, 185, 186, 188, 189, 190, 201, 203, 205, 206, "Type", -3, 88, 103, 109, "ClassItem"],
    ["openedBy", 23, "<", 38, "InterpolationStart", 56, "[", 60, "{", 73, "(", 160, "JSXStartCloseTag"],
    ["closedBy", -2, 24, 168, ">", 40, "InterpolationEnd", 50, "]", 61, "}", 74, ")", 165, "JSXEndTag"]
  ],
  propSources: [IZ],
  skippedNodes: [0, 5, 6, 277],
  repeatNodeCount: 37,
  tokenData: "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$i&j(Y!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(Y!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$i&j(VpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(VpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$i&j(Vp(Y!b'{0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(W#S$i&j'|0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$i&j(Vp(Y!b'|0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$i&j!p),Q(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#v(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#v(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(U':f$i&j(Y!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$i&j(Y!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$i&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$d`$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$d``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$d`$i&j(Y!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(Y!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$d`(Y!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$i&j(Vp(Y!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$i&j(Vp(Y!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$i&j(Y!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$i&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(Y!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$i&j(VpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(VpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Vp(Y!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$i&j(n%1l(Vp(Y!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$i&j(Vp(Y!b$]#t(S,2j(d$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$i&j(Vp(Y!b$]#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$i&j(Vp(Y!b#p(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$i&j$Q(Ch(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(y+JY$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$i&j#z(Ch(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(X';W$i&j(VpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$i&j(VpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$i&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$d`$i&j(VpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(VpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$d`(VpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!l/.^$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!k!Lf$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$i&j(Vp(Y!b(T%&f#q(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$i&j(Vp(Y!b#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$i&j(Vp(Y!br+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!]+Jf$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$i&j(Vp(Y!b!Q.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_![!L^$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$i&j(Vp(Y!b#o(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$i&j(Vp(Y!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$i&j(Y!b!X7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$i&j!X7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$i&j!X7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!X7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!X7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$i&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$i&j(Y!b!X7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(Y!b!X7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(Y!b!X7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(Y!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$i&j(Y!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$i&j(Vp!X7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$i&j(Vp!X7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Vp!X7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Vp!X7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(VpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$i&j(VpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$i&j(Vp(Y!b!X7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Vp(Y!b!X7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Vp(Y!b!X7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Vp(Y!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$i&j(Vp(Y!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$i&j(Vp(Y!b'}0/l!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$i&j(Vp(Y!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$i&j(Y!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$i&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(Y!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$i&j(VpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(VpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Vp(Y!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$i&j$Q(Ch(Vp(Y!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Z#t$i&j(Vp(Y!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!g$b$i&j$O)Lv(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#R-<U(Vp(Y!b$n7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$k&j(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#r(Ch(Vp(Y!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$Q(Ch(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#s(Ch(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#`*!Y$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#k(Cl$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#s(Ch$f#|$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#s(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#r(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#r(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(q(Ct$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$i&j#{(Ch(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!|$Ip$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!S0,v$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$i&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$i&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$i&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$i&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$i&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!Y#)l$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#x(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$i&j(Vp(Y!b(`+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$i&j(Vp(Y!b(S,2j$_#t(d$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$i&j(Vp(Y!b$_#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X!_#Hb(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(x+JY$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z)>v$?V_!^(CdvBr$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!q7`$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$i&j(Vp(Y!b'{0/l$]#t(S,2j(d$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$i&j(Vp(Y!b'|0/l$]#t(S,2j(d$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [WZ, HZ, KZ, JZ, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, NZ, new lp("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOx~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!U~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(b~~", 141, 339), new lp("j~RQYZXz{^~^O(P~~aP!P!Qd~iO(Q~~", 25, 322)],
  topRules: { Script: [0, 7], SingleExpression: [1, 275], SingleClassItem: [2, 276] },
  dialects: { jsx: 0, ts: 15098 },
  dynamicPrecedences: { 80: 1, 82: 1, 94: 1, 169: 1, 199: 1 },
  specialized: [{ term: 326, get: (n) => FZ[n] || -1 }, { term: 342, get: (n) => tE[n] || -1 }, { term: 95, get: (n) => eE[n] || -1 }],
  tokenPrec: 15124
}), vk = [
  /* @__PURE__ */ Kt("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], nE = /* @__PURE__ */ vk.concat([
  /* @__PURE__ */ Kt("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]), bQ = /* @__PURE__ */ new Xb(), bk = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function ma(n) {
  return (t, e) => {
    let i = t.node.getChild("VariableDefinition");
    return i && e(i, n), !0;
  };
}
const lE = ["FunctionDeclaration"], sE = {
  FunctionDeclaration: /* @__PURE__ */ ma("function"),
  ClassDeclaration: /* @__PURE__ */ ma("class"),
  ClassExpression: () => !0,
  EnumDeclaration: /* @__PURE__ */ ma("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ ma("type"),
  NamespaceDeclaration: /* @__PURE__ */ ma("namespace"),
  VariableDefinition(n, t) {
    n.matchContext(lE) || t(n, "variable");
  },
  TypeDefinition(n, t) {
    t(n, "type");
  },
  __proto__: null
};
function xk(n, t) {
  let e = bQ.get(t);
  if (e)
    return e;
  let i = [], s = !0;
  function a(o, u) {
    let h = n.sliceString(o.from, o.to);
    i.push({ label: h, type: u });
  }
  return t.cursor(ae.IncludeAnonymous).iterate((o) => {
    if (s)
      s = !1;
    else if (o.name) {
      let u = sE[o.name];
      if (u && u(o, a) || bk.has(o.name))
        return !1;
    } else if (o.to - o.from > 8192) {
      for (let u of xk(n, o.node))
        i.push(u);
      return !1;
    }
  }), bQ.set(t, i), i;
}
const xQ = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, kk = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  "JSXText",
  "JSXAttributeValue",
  "JSXOpenTag",
  "JSXCloseTag",
  "JSXSelfClosingTag",
  ".",
  "?."
];
function rE(n) {
  let t = ue(n.state).resolveInner(n.pos, -1);
  if (kk.indexOf(t.name) > -1)
    return null;
  let e = t.name == "VariableName" || t.to - t.from < 20 && xQ.test(n.state.sliceDoc(t.from, t.to));
  if (!e && !n.explicit)
    return null;
  let i = [];
  for (let s = t; s; s = s.parent)
    bk.has(s.name) && (i = i.concat(xk(n.state.doc, s)));
  return {
    options: i,
    from: e ? t.from : n.pos,
    validFor: xQ
  };
}
const Ll = /* @__PURE__ */ Da.define({
  name: "javascript",
  parser: /* @__PURE__ */ iE.configure({
    props: [
      /* @__PURE__ */ Xp.add({
        IfStatement: /* @__PURE__ */ DO({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ DO({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: oA,
        SwitchBody: (n) => {
          let t = n.textAfter, e = /^\s*\}/.test(t), i = /^\s*(case|default)\b/.test(t);
          return n.baseIndent + (e ? 0 : i ? 1 : 2) * n.unit;
        },
        Block: /* @__PURE__ */ lu({ closing: "}" }),
        ArrowFunction: (n) => n.baseIndent + n.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ DO({ except: /^\s*{/ }),
        JSXElement(n) {
          let t = /^\s*<\//.test(n.textAfter);
          return n.lineIndent(n.node.from) + (t ? 0 : n.unit);
        },
        JSXEscape(n) {
          let t = /\s*\}/.test(n.textAfter);
          return n.lineIndent(n.node.from) + (t ? 0 : n.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(n) {
          return n.column(n.node.from) + n.unit;
        }
      }),
      /* @__PURE__ */ zp.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": Bb,
        BlockComment(n) {
          return { from: n.from + 2, to: n.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), wk = {
  test: (n) => /^JSX/.test(n.name),
  facet: /* @__PURE__ */ Vb({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
}, aE = /* @__PURE__ */ Ll.configure({ dialect: "ts" }, "typescript"), oE = /* @__PURE__ */ Ll.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ Zp.add((n) => n.isTop ? [wk] : void 0)]
}), cE = /* @__PURE__ */ Ll.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ Zp.add((n) => n.isTop ? [wk] : void 0)]
}, "typescript");
let Tk = (n) => ({ label: n, type: "keyword" });
const $k = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(Tk), uE = /* @__PURE__ */ $k.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(Tk));
function fE(n = {}) {
  let t = n.jsx ? n.typescript ? cE : oE : n.typescript ? aE : Ll, e = n.typescript ? nE.concat(uE) : vk.concat($k);
  return new Ub(t, [
    Ll.data.of({
      autocomplete: Nx(kk, Gp(e))
    }),
    Ll.data.of({
      autocomplete: rE
    }),
    n.jsx ? dE : []
  ]);
}
function hE(n) {
  for (; ; ) {
    if (n.name == "JSXOpenTag" || n.name == "JSXSelfClosingTag" || n.name == "JSXFragmentTag")
      return n;
    if (n.name == "JSXEscape" || !n.parent)
      return null;
    n = n.parent;
  }
}
function kQ(n, t, e = n.length) {
  for (let i = t == null ? void 0 : t.firstChild; i; i = i.nextSibling)
    if (i.name == "JSXIdentifier" || i.name == "JSXBuiltin" || i.name == "JSXNamespacedName" || i.name == "JSXMemberExpression")
      return n.sliceString(i.from, Math.min(i.to, e));
  return "";
}
const OE = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), dE = /* @__PURE__ */ it.inputHandler.of((n, t, e, i, s) => {
  if ((OE ? n.composing : n.compositionStarted) || n.state.readOnly || t != e || i != ">" && i != "/" || !Ll.isActiveAt(n.state, t, -1))
    return !1;
  let a = s(), { state: o } = a, u = o.changeByRange((h) => {
    var d;
    let { head: p } = h, g = ue(o).resolveInner(p - 1, -1), y;
    if (g.name == "JSXStartTag" && (g = g.parent), !(o.doc.sliceString(p - 1, p) != i || g.name == "JSXAttributeValue" && g.to > p)) {
      if (i == ">" && g.name == "JSXFragmentTag")
        return { range: h, changes: { from: p, insert: "</>" } };
      if (i == "/" && g.name == "JSXStartCloseTag") {
        let Q = g.parent, b = Q.parent;
        if (b && Q.from == p - 2 && ((y = kQ(o.doc, b.firstChild, p)) || ((d = b.firstChild) === null || d === void 0 ? void 0 : d.name) == "JSXFragmentTag")) {
          let x = `${y}>`;
          return { range: j.cursor(p + x.length, -1), changes: { from: p, insert: x } };
        }
      } else if (i == ">") {
        let Q = hE(g);
        if (Q && Q.name == "JSXOpenTag" && !/^\/?>|^<\//.test(o.doc.sliceString(p, p + 2)) && (y = kQ(o.doc, Q, p)))
          return { range: h, changes: { from: p, insert: `</${y}>` } };
      }
    }
    return { range: h };
  });
  return u.changes.empty ? !1 : (n.dispatch([
    a,
    o.update(u, { userEvent: "input.complete", scrollIntoView: !0 })
  ]), !0);
});
function pE({ initialCode: n = "" }) {
  const t = rv(), [e, i] = kn(t.codeAtom), [s] = kn(t.molstarReadyAtom), [, a] = kn(t.executeJsCodeAtom), [, o] = kn(t.initializeMolstarAtom), [u, h] = St.useState(!1);
  St.useEffect(() => {
    n && !e && i(n), o().then(() => {
      h(!0);
    });
  }, []), St.useEffect(() => {
    s && e && u && a();
  }, [s, u]);
  const d = Jl.of([
    {
      key: "Alt-Enter",
      run: () => (a(), !0)
    }
  ]);
  return /* @__PURE__ */ ie.createElement("div", { className: "app-container" }, /* @__PURE__ */ ie.createElement("div", { className: "editor-container" }, /* @__PURE__ */ ie.createElement(
    em,
    {
      value: e,
      extensions: [fE(), d],
      onChange: i
    }
  )), /* @__PURE__ */ ie.createElement("div", { className: "visualization-container" }, !s && /* @__PURE__ */ ie.createElement("div", { className: "loading" }, "Loading Molstar..."), /* @__PURE__ */ ie.createElement(Pk, null)));
}
const mE = {
  allowMajorPerformanceCaveat: !0,
  collapseLeftPanel: !1,
  collapseRightPanel: !1,
  customFormats: [],
  disableAntialiasing: !1,
  disabledExtensions: [],
  emdbProvider: "rcsb",
  illumination: !1,
  layoutIsExpanded: !1,
  layoutShowControls: !1,
  layoutShowLeftPanel: !1,
  layoutShowLog: !1,
  layoutShowRemoteState: !1,
  layoutShowSequence: !0,
  pdbProvider: "rcsb",
  pickScale: 1,
  pixelScale: 1,
  pluginStateServer: "",
  powerPreference: "default",
  preferWebgl1: !1,
  rcsbAssemblySymmetryApplyColors: !0,
  rcsbAssemblySymmetryDefaultServerType: "full",
  rcsbAssemblySymmetryDefaultServerUrl: "",
  resolutionMode: "auto",
  saccharideCompIdMapType: "default",
  transparency: !0,
  viewportShowAnimation: !1,
  viewportShowControls: !0,
  viewportShowExpand: !0,
  viewportShowSelectionMode: !1,
  viewportShowSettings: !0,
  viewportShowTrajectoryControls: !1,
  volumeStreamingDisabled: !1
};
function Pk() {
  const n = St.useRef(null), t = St.useRef(null), e = gE(), [i] = kn(e.molViewSpecJsonAtom);
  return St.useEffect(() => {
    if (n.current)
      return molstar.Viewer.create(n.current, mE).then((s) => {
        t.current = s, i && s.loadMvsData(i, "mvsj", {
          replaceExisting: !0
        });
      }).catch(
        (s) => console.error(`Failed to initialize MolStar: ${s.message}`)
      ), () => {
        t.current && (t.current.dispose(), t.current = null);
      };
  }, []), St.useEffect(() => {
    if (t.current && i) {
      console.log("MolStar: Loading new data", typeof i, i);
      try {
        t.current.loadMvsData(i, "mvsj", {
          replaceExisting: !0
        });
      } catch (s) {
        console.error("MolStar: Error loading data:", s);
      }
    }
  }, [i]), /* @__PURE__ */ ie.createElement("div", { className: "molstar-container" }, /* @__PURE__ */ ie.createElement("div", { className: "molstar", ref: n }));
}
const Rk = ie.createContext("python"), wQ = function(n) {
  const t = n.implementation || "python", e = n.children;
  return St.createElement(
    Rk.Provider,
    { value: t },
    e
  );
};
function gE() {
  return ie.useContext(Rk) === "js" ? rv() : lv();
}
function vE(n, t, e, i = "python") {
  if (!n) return;
  const s = r$.createRoot(n);
  i === "python" ? s.render(
    St.createElement(
      wQ,
      { implementation: "python" },
      St.createElement(
        C$,
        { initialCode: e },
        St.createElement(wZ, { initialCode: e })
      )
    )
  ) : i === "js" && s.render(
    St.createElement(
      wQ,
      { implementation: "js" },
      St.createElement(
        E$,
        { initialCode: e },
        St.createElement(pE, { initialCode: e })
      )
    )
  );
}
const yE = {}, Yi = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: yE
}, Symbol.toStringTag, { value: "Module" }));
export {
  wZ as CodeMirrorEditor,
  wQ as ImplementationProvider,
  Pk as MolStar,
  C$ as MolViewSpecApp,
  vE as appInit,
  vE as default,
  gE as useAtomScope
};
